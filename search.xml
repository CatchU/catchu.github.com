<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springcloud中使用Hystrix保护应用]]></title>
    <url>%2F2017%2F12%2F14%2Fspringcloud%E4%B8%AD%E4%BD%BF%E7%94%A8Hystrix%E4%BF%9D%E6%8A%A4%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.Hystrix入门示例1.1目前存在的问题当前项目中如果服务提供者的响速度十分缓慢，导致消费者请求一直处于等待状态，资源得不到释放，一旦请求积累过多，资源耗尽，就会导致服务不可用。顺便提一个名词雪崩效应就是这么引起的，比如存在服务ABCD，服务B是服务A的消费者，服务C，D又是服务B的消费者，服务A的不可用，随后引起服务B的不可用，进而导致服务C,D都不可用，这种因服务提供者的不可用导致消费者不可用，并将服务不可用状态放大的过程就是雪崩效应。那么如何避免雪崩效应的发生呢： 超时机制通过网络请求服务时必须设置超时时间。正常请求时，一般会很快获得响应，当服务提供者不可用或者网络不可用时响应时间都会变的很长，这将会导致请求者会一直等待响应，而每个请求都会对应指定的线程或进程，那么这些资源将无法释放，一般请求堆积或并发量高时就会拖坏这个应用，所以设置超时时间很有必要，在规定的时间内，如果没有获得响应，就默认这个请求失败，释放请求占用的资源。 熔断机制这个类似于家用断路器，当发生火灾或线路过载等问题时，断路器就会自动断开（跳闸），我们这里的熔断就是也是同样的道理，比如设置请求超时时间是1秒，一连100个请求都没获得响应，那么基本就可以判断这个服务挂了，为了避免资源的浪费，没有必要再去访问这个不可用的服务了，可以采用断路器断开这个服务。最后再补充一下监控。1.2简单的Hystrix的示例 引入jar1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 老规矩，使用某个组件的功能，首先要在pom文件中引入这个文件的jar Main方法中加入断路器的注解@EnableCircuitBreaker1234567891011121314@SpringBootApplication@EnableEurekaClient@RibbonClient(name=&quot;microservice-provider-user&quot;,configuration = BalanceConfiguration.class)@EnableCircuitBreakerpublic class MicroserviceConsumerMovieRibbonWithHystixApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123;SpringApplication.run(MicroserviceConsumerMovieRibbonWithHystixApplication.class, args); &#125;&#125; @EnableCircuitBreaker的作用是声明这个主方法已经引入了断路器的注解，可以使用断路器了。 实际调用方法中加入出现错误之后的处理方法，并用fallbackMethod指向这个方法123456789101112131415161718@RestControllerpublic class MovieController &#123; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/simple/&#123;id&#125;&quot;) @HystrixCommand(fallbackMethod =&quot;findUserByIdFallBack&quot; ) public User findUserById(@PathVariable Long id)&#123; return restTemplate.getForObject(&quot;http://microservice-provider-user/simple/&quot;+id, User.class); &#125; public User findUserByIdFallBack(Long id)&#123; User user = new User(); user.setId(1L); user.setUsername(&quot;出错了&quot;); return user; &#125;&#125; 定义一个方法findUserByIdFallBack作为服务提供者不可用时的处理方法，注意这个方法与原调用方法findUserById参数用和返回类型必须一致，并用@HystrixCommand指定提供者不可用时调用此方法作为响应。 application.yml中加入超时时间1hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 5000 #设置超时时间为5秒 配置文件中加入Hystrix的超时时间，这里设置的5秒，但并不是必须。 测试依次启动注册中心，服务提供者user，服务消费者movie，第一次正常调用获得响应，随后将提供者user的服务停掉，再次调用发现返回的是我们定义的服务出错时的信息。2.健康指标（Health Indicator）和指标流（metrics stream） 健康检查 ：健康检查就是通过访问 http://你的服务ip:你的服务端口/health 来确定服务的可用状态，上面的一开始是可用的（UP），当把提供者停掉之后，再重复的刷新调用者，触发断路器，发现健康检查里面就会提示服务不可用 。 Hystrix指标流：若想使用Hystrix的指标流需要引入spring-boot-starter-actuator的依赖。1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 使用Hystrix指标流可以将/hystrix.stream作为管理端点，访问http://你的服务ip:你的服务端口/hystrix.stream 可以查看项目运行的各个指标。说白了hystrix.stream其实就是一个监控，监控每个API的运行状态，但是它的可读性很差，整页整页的代码不便查看，后面将会说Hystrix的仪表盘（Hystrix Dashboard）。 3.Feign对Hystrix的支持3.1引入Hystrix的jar依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 3.2给Main方法加入@EnableCircuitBreaker12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableCircuitBreakerpublic class MicroserviceConsumerMovieFeignWithHystrixApplication &#123; public static void main(String[] args) &#123;SpringApplication.run(MicroserviceConsumerMovieFeignWithHystrixApplication.class, args); &#125;&#125; 加入@EnableCircuitBreaker注解表明这个模块对断路器是支持的。 3.3实现自定义Feign的接口并在这个接口里面写服务不可用的处理方式12345678910@Componentpublic class UserFeignFallBack implements UserFeign&#123; @Override public User findUserbyId(Long id) &#123; User user = new User(); user.setId(-1L); user.setUsername(&quot;服务者出错了&quot;); return user; &#125;&#125; UserFeign就是我们自己定义的那个调用服务的接口客户端，UserFeignFallBack是出错时的处理类，里面重写方法，在其内写出错处理代码。注意UserFeignFallBack类要被Spring管理，添加@Component注解，不然报错。 3.4在Feign客户端中指明出错时的处理类12345@FeignClient(name = &quot;microservice-provider-user&quot;, fallback = UserFeignFallBack.class)public interface UserFeign &#123; @RequestMapping(value = &quot;/simple/&#123;id&#125;&quot;,method = RequestMethod.GET) public User findUserbyId(@PathVariable(&quot;id&quot;) Long id);&#125; 上面的UserFeignFallBack类就是实现的这个UserFeign接口，现在在这个接口上面添加fallback时的处理类为UserFeignFallBack.class，现在就已经写完了，可以起服务进行测试。 4.Hystrix Dashboard的使用上面我们说过当我们使用指标流，即访问http://192.168.0.12:7909/hystrix.stream 可以看到项目的运行指标，但是可读性很差，如果有一种图形化的界面可以直观的反映出项目的运行状况就非常棒了，确实存在这样的一个东西，那就是Hystrix Dashboard。首先我们需要创建一个Dashboard项目。 新建项目microservice-hystrix-dashboard，引入spring-cloud-starter-hystrix-dashboard的jar。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; main方法中加入@EnableHystrixDashboard注解 12345678@SpringBootApplication@EnableHystrixDashboardpublic class MicroserviceHystrixDashboardApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceHystrixDashboardApplication.class, args); &#125;&#125; yml配置文件中配置端口号 12server: port: 8030 启动项目访问：http://localhost:8030/hystrix 会看到如下界面：在地址栏中输入你要访问的项目的hystrix.stream可以看到如下页面，这里反映的就是项目运行状态。 5.Turbin的使用使用Dashboard可以获取访问实例的状态，但是生产环境中通常是集群部署，监控单一项目意义不大，Turbin可以做一个数据的聚合，达到监控整个集群的目的。 创建microservice-hystrix-turbin项目，并引入spring-cloud-starter-turbine的jar 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt; &lt;version&gt;1.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; main方法中注入EnableTurbine注解 12345678@SpringBootApplication@EnableTurbinepublic class MicroserviceHystrixTurbinApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceHystrixTurbinApplication.class, args); &#125;&#125; yml文件中配置要聚合的实例 12345678910111213141516server: port: 8031spring: application: name: microservice-hystrix-turbineeureka: client: serviceUrl: defaultZone: http://admin:qwe123@localhost:8761/eureka instance: prefer-ip-address: trueturbine: aggregator: clusterConfig: default appConfig: microservice-consumer-movie-ribbon-with-hystrix,microservice-consumer-movie-feign-with-hystrix clusterNameExpression: &quot;&apos;default&apos;&quot; 比如我这里要监控的是microservice-consumer-movie-ribbon-with-hystrix和microservice-consumer-movie-feign-with-hystrix项目。之后分别启动注册中心，消费者，服务者，turbin和dashboard项目，在dashboard项目中访问turbin项目的指标流即可看到聚合项目的运行状况。]]></content>
      <categories>
        <category>后台—springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud中使用Ribbon和Feign调用服务以及服务的高可用]]></title>
    <url>%2F2017%2F12%2F14%2Fspringcloud%E4%B8%AD%E4%BD%BF%E7%94%A8Ribbon%E5%92%8CFeign%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.消费者使用Ribbon组件负载均衡的调用服务者接口在上一节中只介绍了如何将服务者和消费者注册到Eureka注册中心中，消费者并没有调用服务者，现在开始介绍，首先为了避免混淆，不再用上一节的消费者，重新建一个名为microservice-consumer-movie-ribbon的消费者，代码跟microservice-consumer-movie的一样，下面介绍如何负载均衡的调用。 1.1 使用Ribbon默认的轮询方式调用服务者 引入jar包如果调用者要使用Ribbon实现调用服务者的负载均衡首先想到的是引入Ribbon的jar包，这里Eureka中已经包含了此jar，我们上一节已经引入了Eureka的jar，这里可以不用再引入了。 Main方法中引入@LoadBalanced负载均衡注解在MicroserviceConsumerMovieRibbonApplication的创建调用实例对象RestTemplate中加入注解@LoadBalanced注解，默认是轮询。 1234567891011@SpringBootApplication@EnableEurekaClientpublic class MicroserviceConsumerMovieRibbonApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceConsumerMovieRibbonApplication.class, args); &#125;&#125; 启动两个或两个以上服务者进行测试启动注册中项目和服务者，消费者项目，这里因为要测负载均衡，所以至少要启动两个服务者才行。启动完第一个服务者之后，修改application.yml的端口号，接着启动第二个服务者，如下图：经过以上步骤即可创建另一个服务者实例MicroserviceProviderUserApplication2，启动它将其注册到注册中心中。访问消费者的项目，多刷新一次会发现交替调用服务者MicroserviceProviderUserApplication和MicroserviceProviderUserApplication2，测试成功。 1.2自定义负载均衡算法调用服务者可以自己定义一个负载均衡策略的类，我这里定义一个随机策略。 123456789101112131415/** * @author 刘俊重 * @Description 负载均衡配置,配置调用者调用服务者的调用策略 * @date 13:56 */@Configurationpublic class BalanceConfiguration &#123; /** * @Description 定义随机调用的负载均衡算法 */ @Bean public IRule ribbonRule()&#123; return new RandomRule(); &#125;&#125; 在Main方法中，RibbonClient注解中指明调用某个服务使用某个指定的策略。1@RibbonClient(name=&quot;microservice-provider-user&quot;,configuration = BalanceConfiguration.class) 调用microservice-provider-user服务时，使用BalanceConfiguration定义的负载均衡策略，完整的代码如下：1234567891011121314@SpringBootApplication@EnableEurekaClient@RibbonClient(name=&quot;microservice-provider-user&quot;,configuration = BalanceConfiguration.class)public class MicroserviceConsumerMovieRibbonApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceConsumerMovieRibbonApplication.class, args); &#125;&#125; 注意：所有用到Ribbon负载均衡的均要有@LoadBalanced注解，只是我们没有定义自己的调用策略时，默认会使用轮询的策略。同时这里有坑，不能把定义的策略类BalanceConfiguration放在Main方法同级或子包下面，会有冲突（或者你自己用注解@ComponentScan再写方法，不让spring扫描这个自定义的策略类），官方文档中写的非常清楚，不懂的可以看看：https://springcloud.cc/spring-cloud-dalston.html#_customizing_the_ribbon_client 1.3使用配置文件自定义RibbonClient实现客户端负载均衡springcloud从1.2.0版本之后支持通过自定义配置文件的方式配置负载均衡策略。官方在application.yml中这样配置的：123users: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule 你只需要把users改成你的服务提供者的应用名称即可，WeightedResponseTimeRule可以配置成其他的策略，这里为了不影响其它代码，我再重新创建一个microservice-consumer-movie-ribbon-custom-properties项目。之前Main方法的@RibbonClient可以去掉了，application.yml中这么配置：123microservice-provider-user: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 这段配置的意思就是通过Ribbon调用microservice-provider-user服务时采用RandomRule（随机）的策略。小结：消费者调用服务者时，我们使用Ribbon实现请求的负载均衡，而且Eureka的jar中已经集成了Ribbon，不用再引jar包即可直接使用。使用有三种方法：1.直接在RestTemplate实例中添加@LoadBalanced即可实现默认轮询的负载均衡，2.自定义负载均衡策略类，并在RibbonClient中引入这个策略类，3.在yml配置文件中自定义负载策略，其中第三种比较方便。 2.使用Ribbon不使用Eureka为防止污染其它代码，再创建一个microservice-consumer-movie-ribbon-without-eureka项目，用来演示使用Ribbon时不适用Eureka。官方文档中在application.yml中这样配置：123stores: ribbon: listOfServers: example.com,google.com 意为通过ribbon调用stores不适用Eureka中注册的服务者，而是调用example.com和google.com这两个服务。那我也这样做，配置文件如下：123microservice-provider-user: ribbon: listOfServers: localhost:7100 当使用ribbon调用microservice-provider-user服务时调用localhost:7100的服务，虽然Eureka中microservice-provider-user注册了好几个服务提供者（比如localhost:7100，localhost:7101，localhost:7102），但只会调用localhost:7100，这就是使用Ribbon不使用Eureka。注意：@LoadBalanced注解不要落下，因为listOfServers这里也可以配置多个主机，同样需要负载均衡。文档地址：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon-without-eureka 3.在Ribbon中禁用Eurekaapplication.yml中这样配置即可：123ribbon: eureka: enabled: false 文档地址：https://springcloud.cc/spring-cloud-dalston.html#_example_disable_eureka_use_in_ribbon 4.声明式的Rest客户端:FeignFeign是一种声明式的Web服务客户端，通过它可以方便的调用服务提供者的服务。使用Feign的步骤如下： 引入Feign的jar 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 自定义Feign客户端类 1234567891011/** * @Description 用户自定义Feign客户端 * @Author 刘俊重 * @Date 2017/11/8 */@FeignClient(&quot;microservice-provider-user&quot;)public interface UserFeign &#123; @RequestMapping(value = &quot;/simple/&#123;id&#125;&quot;,method = RequestMethod.GET) public User findUserbyId(@PathVariable(&quot;id&quot;) Long id);&#125; @FeignClient注明要调用的服务microservice-provider-user，public User findUserbyId(@PathVariable(“id”) Long id)这个接口是服务提供者接受调用的。 Main方法中加入@EnableFeignClients表明这个Feign客户端 1234567@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class MicroserviceConsumerMovieFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceConsumerMovieFeignApplication.class, args); &#125;&#125; 消费者调用端注入自定义的Feign客户端，发起调用请求。 123456789@RestControllerpublic class MovieController &#123; @Autowired private UserFeign userFeign; @GetMapping(&quot;/simple/&#123;id&#125;&quot;) public User findUserById(@PathVariable Long id)&#123; return userFeign.findUserbyId(id); &#125;&#125; 自定义了Feign客户端就不需要再使用RestTemplate调用了，现在的调用顺序是调用者通过调用自定义Feign客户端调用，自定义的Feign客户端又通过@FeignClient声明要调用的服务，通过跟服务者同名的方法调用。但是这里还有几个坑： @GetMapping不支持,需要使用@RequestMapping，在括号里面指定请求方式。 @PathVariable得设置value，@PathVariable(“id”)如果没有(“id”)会报错 Feign里面方法的参数如果是复杂对象（引用数据类型），即使你通过method = RequestMethod.GET指定这个get请求，请求到达服务提供者时依然是以Post请求方式到达的。5.覆盖Feign的默认值（自定义Feign的配置方式）默认情况下，Feign使用的是SpringMvcContract（Springmvc的契约），可以在Feign客户端中使用1@RequestMapping(value = &quot;/simple/&#123;id&#125;&quot;,method = RequestMethod.GET) 这种方式调用服务者，但是假如我们不想采用这种方式，而是通过自定义的方式那就可以定义这样一个类。 定义Feign配置类，覆盖默认配置 1234567891011/** * @author 刘俊重 * @Description 自定义Feign的配置 */@Configurationpublic class CustomFeignConfiguration &#123; @Bean public Contract feignContract() &#123; return new feign.Contract.Default(); &#125;&#125; 在Feign客户端中引入刚才定义的配置类 12345@FeignClient(name=&quot;microservice-provider-user&quot;,configuration = CustomFeignConfiguration.class)public interface UserFeign &#123; @RequestLine(&quot;GET /simple/&#123;id&#125;&quot;) public User findUserbyId(@Param(&quot;id&quot;) Long id);&#125; 因为我们已经覆盖了Feign的默认配置，自定义了CustomFeignConfiguration，里面定义契约不再采用springmvc的而是采用Feign的，所以这里请求注解@RequestMapping要改成@RequestLine，相应参数也要改变了，不然会报错。参考文档：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign-overriding-defaults 6.解决Feign第一次请求超时的问题在实际测试中发现如果机器配置比较低，第一次使用Feign调用服务者时经常会出现超时的现象，之后再调用就没有问题了，可以通过以下方法解决。123456# 解决第一次请求报超时异常的方案：# hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 5000 (将请求超时时间设为5秒)# 或者： （直接禁用超时提醒）# hystrix.command.default.execution.timeout.enabled: false# 或者：feign.hystrix.enabled: false ## 索性禁用feign的hystrix支持 Eureka的高可用设置Eureka在这里充当的是注册中心的作用，所以必须要保证高可用，每个Eureka服务器同时也是一个Eureka客户端，同时还需要至少一个服务来定位对等体。Eureka的高可用可以采用下面的步骤来完成。 application.xml中配置多个Eureka对等体12345678910111213141516171819202122232425spring: application: name: EUREKA-HA---server: port: 8761spring: profiles: peer1eureka: instance: hostname: peer1 client: serviceUrl: defaultZone: http://peer2:8762/eureka/---server: port: 8762spring: profiles: peer2eureka: instance: hostname: peer2 client: serviceUrl: defaultZone: http://peer1:8761/eureka/ 上面的意思就是定义一个应用名为EUREKA-HA，定义一个profiles名为peer1,它的主机名是peer1，将其注册到http://peer2:8762/eureka/ 服务器上，peer2跟它同理，现在peer1跟peer2就是对等体（名字可以随便定）。 window系统修改hosts文件。进入“C:\Windows\System32\drivers\etc”，修改hosts文件 1127.0.0.1 peer1 peer2 依次启动peer1和peer2。启动pee1时可能会报错，因为它要把服务注册到peer2上，但是peer2还未启动，不用管它，访问http://localhost:8761 ,发现什么都没有；接着启动peer2，访问http://localhost:8762 ，发现8761和8762都注册在了8762上，此时在刷新8761的浏览器页面发现8761和8762已经都在了，因为peer1和peer2是对等体，他们互相注册，服务注册表也是共享了，由此就组成了Eureka的高可用。启动peer1和peer2图片如下图（Active profiles必须配置，否则报错）：注意：如果你引入了spring-boot-starter-security包，但是并没有指定用户名和密码，那么Eureka会为你生成一个随机密码，导致你登录不上，所以请不要引入spring-boot-starter-security或者自己指定密码。参考地址：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-eureka-server-zones-and-regions总结：本节首先是将服务提供者和消费者注册在了Eureka的注册中心上，之后消费者通过两种方式调用服务者，一种是Ribbon负载均衡调用，一种是用Feign客户端调用，当然在每种调用方式中都可以进行自定义配置；鉴于Eureka注册中心的地位非常重要，一旦宕机将导致其它服务都不可用，所以需要保证Eureka注册中心的高可用。代码地址：https://gitee.com/catchu/springcloud-study]]></content>
      <categories>
        <category>后台—springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud将服务者和消费者注册到注册中心(Eureka)]]></title>
    <url>%2F2017%2F12%2F14%2Fspringcloud%E5%B0%86%E6%9C%8D%E5%8A%A1%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%B3%A8%E5%86%8C%E5%88%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-Eureka%2F</url>
    <content type="text"><![CDATA[###1.服务注册和发现的一些术语解释 ####1.1服务发现组件的功能 服务注册表：服务注册表是一个记录当前可用服务实例的数据库，是服务发现机制的核心。服务注册表提供查询API和管理API，通过查询Api可以查看当前可用的服务实例，通过管理Api可以注册或注册实例。 服务注册：就是服务在启动时，将服务实例的网络地址注册到服务注册表中 健康检查：服务注册表会通过某些机制（如心跳监测）定期检查已注册的服务，如果发现某个服务不可用，就将其从注册表中移除。 服务注册组件：不同人的称谓可能不同，不过说的都是一个组件，有的称为注册中心，服务注册，服务发现，在这里统一称为服务注册发现组件（如Dubbo使用Zookeeper,Edas使用阿里自己定制的AliTomcat，我们这里使用Netfix提供的Eureka，当然springcloud也支持其它的注册发现组件）。1.2服务注册发现方式不同的框架用的组件可能不能，不过总的来说有客户端发现和服务端发现，Eureka和Zookeeper使用客户端发现方式，Consul属于服务端发现方式。2.将服务端和客户端注册到Eureka注册组件中今天介绍的内容均可以查看这里的中文文档：https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_netflix 。2.1创建Eureka服务注册组件项目这里的注册中心跟zookeeper不同，zookeeper启动之后再启动服务即可注册实例，我们这里需要自己开发注册中心项目。使用IDEA创建名为microservice-discovery-eureka的项目，pom中引入 spring-cloud-starter-eureka-server的jar包。12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在MicroserviceDiscoveryEurekaApplication方法中添加注解@EnableEurekaServer，表明这是一个服务注册组件的服务端1234567@SpringBootApplication@EnableEurekaServerpublic class MicroserviceDiscoveryEurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceDiscoveryEurekaApplication.class, args); &#125;&#125; 将application.porperties注册文件改名为application.yml，之后进行配置。12345678server: port: 8761eureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://localhost:8761/eureka Eureka的默认端口就是8761，其中“defaultZone”是一个魔术字符串后备值，为任何不表示首选项的客户端提供服务URL（即defaultZone是有用的默认值）。现在就可以启动这个Main方法，之后再浏览器中输入http://localhost:8761 ,打开页面如下： 2.2将服务者注册到Eureka中首先引入jar包spring-cloud-starter-eureka，这里引的跟上面引的jar不一样，上面的服务端，这里的是客户端。12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在之前的main方法中添加@EnableEurekaClient注解，表明它是客户端。1234567@SpringBootApplication@EnableEurekaClientpublic class MicroserviceProviderUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceProviderUserApplication.class, args); &#125;&#125; 修改application.yml配置文件，配置应用实例名称，应用访问方式等。123456789101112131415161718192021server: port: 7900spring: jpa: generate-ddl: false show-sql: true hibernate: ddl-auto: none datasource: platform: h2 schema: classpath:schema.sql data: classpath:data.sql application: name: microservice-provider-user #应用名称eureka: client: #配置eureka客户端 service-url: defaultZone: http://localhost:8761/eureka instance: prefer-ip-address: true #配置在eureka中显示ip地址 instance-id: $&#123;spring.application.name&#125;:$&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125; #配置应用访问方式。应用名:IP:端口号 现在启动服务者项目即可将服务注册到Eureka中，刷新eureka的页面可看到注册的服务实例。 2.3将调用者注册到Eureka中调用者和服务者注册到Eureka的方式一样，首先引入spring-cloud-starter-eureka的jar包，之后给main方法配置@EnableEurekaClient注解，再修改application.yml的配置文件，不再赘余。123456789101112server: port: 7901spring: application: name: microservice-consumer-movie #配置项目名eureka: client: #配置要访问的注册中心地址，即eureka所在的地址 service-url: defaultZone: http://localhost:8761/eureka instance: #配置是否显示ip prefer-ip-address: true instance-id: $&#123;spring.application.name&#125;:$&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125; 至此服务者和调用者均已经注册到服务注册组件Eureka中了，刷新http://localhost:8761/ 即可查看，至于如何调用，下一节介绍 3.补充知识补充身份认证和健康检查。 3.1身份认证在Eureka的项目中引入springboot提供的安全认证jar包,服务者和调用者不用引入。12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;1.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在application.yml中配置要访问的用户名和密码，注册中心，服务者，消费者均要修改访问路径跟Eureka中defaultZone的一致。1234567891011121314security: basic: enabled: true user: name: admin password: qwe123server: port: 8761eureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://admin:qwe123@localhost:8761/eureka 这样在访问http://localhost:8761/ 的时候就需要输入用户名和密码了。 3.2健康检查微服务中要想保证服务可用就必须要保证每个服务均是可用的，Eureka中提供了健康检查机制，检测到某个服务不可用会将其从注册表中移除，下面介绍如何进行健康检查： 在每一个需要注册到注册中心的服务项目中都引入spring-boot-starter-actuator的jar包（Eureka项目中不引入） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;1.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在每个要注册到注册中心的项目的application.yml中都加入 healthcheck:enabled: true的配置（Eureka的配置文件不加）。示例如下： 12345678910111213141516server: port: 7901user: userServicePath: http://localhost:7900/simple/spring: application: name: microservice-consumer-movie #配置项目名eureka: client: #配置要访问的注册中心地址，即eureka所在的地址 healthcheck: enabled: true service-url: defaultZone: http://admin:qwe123@localhost:8761/eureka instance: #配置是否显示ip prefer-ip-address: true instance-id: $&#123;spring.application.name&#125;:$&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125; 这样在某个服务不可用是就会从注册表中剔除。]]></content>
      <categories>
        <category>后台—springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SpringCloud构建简单的服务者和消费者]]></title>
    <url>%2F2017%2F12%2F14%2F%E4%BD%BF%E7%94%A8SpringCloud%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[0.SpringCloud的特点Springcloud具有下列特点： 约定优于配置； 开箱即用，快速启动（springboot可以以jar或war的方式启动） 适用于多种环境（Pc Server、Docker） 组件轻量，选型中立（例如注册中心可以是Eureka、Consul、Zookeeper） 组件丰富，功能齐全（注册中心，配置中心，智能路由，负载均衡，熔断机制）1.创建springboot的项目springcloud分布式项目里面的每个小项目都是springboot项目，所以首先搭建springboot项目（这里不主要讲），有两种方法，我使用的编辑器是inteiilij idea. 方法一：File—— new Project ——左侧选择Spring Initializr（如果没有这个选项，在插件里面搜索spring boot并安装，之后重启idea），右侧选择jdk版本，default选项不用管，之后接着下一步下一步选择依赖（具体方法网上写的有，可以参考：http://blog.csdn.net/yxl8359026/article/details/51464041） 方法二：直接到http://start.spring.io/ 填写项目信息和依赖的服务，之后生成一个压缩包，解压缩就是一个maven类的项目，直接导入编辑工具即可。至此服务者microservice-simple-provider-user和消费者microservice-simple-consumer-movie创建完毕。2.配置springboot的application.yml配置文件默认生成之后是application.properties格式的文件，直接把后缀名改为yml结尾的即可，yml格式的是类似于树型结构的配置文件，示例如下：12345678910111213141516171819server: port: 7900spring: jpa: generate-ddl: false show-sql: true hibernate: ddl-auto: none datasource: platform: h2 schema: classpath:schema.sql data: classpath:data.sqllogging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACE com.catchu: DEBUG 这种yml的配置文件首先需要idea识别你的maven工程，才会给出提示，不然不会提示，自己写的话容易出错（yml对格式要求比较严），树型配置文件，与我们熟悉的properties的差不多，比如server:port:7900就相当于server.port=7900。上面配置的意思是配置端口为7900，配置jpa和数据源（为模拟简便使用h2数据库），配置日志级别。 3.开发服务提供者为模拟简单，这里直接用controller调用dao，不在写业务层，dao直接继承JpaRepository。12345678910111213package com.catchu.microservice.dao;import com.catchu.microservice.entity.User;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;/** * @author 刘俊重 * @Description 用户数据访问层 * @date 18:06 */@Repositorypublic interface UserDao extends JpaRepository&lt;User,Long&gt;&#123;&#125; controller代码如下：123456789101112131415161718192021package com.catchu.microservice.controller;import com.catchu.microservice.dao.UserDao;import com.catchu.microservice.entity.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;/** * @author 刘俊重 * @Description * @date 18:09 */@RestControllerpublic class UserController &#123; @Autowired private UserDao userDao; @GetMapping(&quot;/simple/&#123;id&#125;&quot;) public User findUserbyId(@PathVariable Long id)&#123; return userDao.findOne(id); &#125;&#125; 至此提供者写完了，直接运行根包下面的main项目即可，不用单独配置tomcat，浏览器访问http://localhost:7900/simple/3 接收到返回的数据。 4.开发服务消费者同样是先配置application.yml文件，本例中配置一下端口即可，随后在main方法中创建RestTemplate示例对象，来调用服务者的接口。1234567891011121314@SpringBootApplicationpublic class MicroserviceSimpleConsumerMovieApplication &#123; /** * @Description 在这里创建RestTemplate实例供其他调用者调用消费者 * @Author 刘俊重 * @Date 2017/10/30 */ @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceSimpleConsumerMovieApplication.class, args); &#125;&#125; 在消费者的控制层中调用服务者的控制层。1234567891011121314151617181920212223/** * @author 刘俊重 * @Description 电影服务控制层 * @date 18:29 */@RestControllerpublic class MovieController &#123; /** * @Description restTemplate名字与MicroserviceSimpleConsumerMovieApplication里面@bean创建的对象名要一样 */ @Autowired private RestTemplate restTemplate; @Value(&quot;$&#123;user.userServicePath&#125;&quot;) private String userServicePath; /** * @Description 使用restTemplate对象调用服务者——用户模块 */ @GetMapping(&quot;/simple/&#123;id&#125;&quot;) public User findUserById(@PathVariable Long id)&#123; return restTemplate.getForObject(userServicePath+id, User.class); &#125;&#125; 到这里消费者已经写好了，直接启动main方法，访问http://localhost:7901/simple/3 就可以看到调用了7900端口下的服务。总结：首先创建服务的提供者和消费者两个项目，之后修改配置文件，编写服务者和消费者。两个项目是独立的单元，都有自己的控制层，业务层，可以独立部署运行，但它们之前的服务又互相调用；同时服务依赖太严重又会导致不稳定，之后介绍使用注册中心的服务注册和发现。代码地址：https://gitee.com/catchu/springcloud-study]]></content>
      <categories>
        <category>后台—springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven项目打包遇到的两个问题]]></title>
    <url>%2F2017%2F12%2F14%2FMaven%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[项目部署上线时需要打包，我们的项目是采用maven工程，打包时碰到过两个问题，做下记录： 1.Maven如何打入本地jar包使用支付宝API时发现有些jar没有在中央仓库中，只能从支付宝下载jar，然后引入到项目中，这种情况下再使用平时的打包方式存在问题，需要做如下处理： 我在与src并列的目录下新建一个lib的文件夹，将支付宝的alipay-sdk-java-ALL20171128134549.jar包放在这个文件夹里面。 pom的依赖中这样写： 1234567 &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;ALL20171128134549&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;basedir&#125;/lib/alipay-sdk-java-ALL20171128134549.jar&lt;/systemPath&gt;&lt;/dependency&gt; pom的引入插件中这样写： 1234567891011121314151617181920&lt;plugins&gt; &lt;!--打包war,引入lib下的jar--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;warName&gt;$&#123;project.artifactId&#125;&lt;/warName&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;lib/&lt;/directory&gt; &lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 这样就可以在部署时将本地jar包打入war包中了。 2.使用maven的profiles动态选择配置文件日常开发中通常会有开发环境和生产环境，配置文件一般都是在xxx.properties中配置着，如果变动比较少还尚可采用注释掉不用的配置，放开需要的配置，但是如果生产和开发好多配置文件都不一样，每次打包之前都要不停的改动，不紧浪费时间，而且顾此失彼容易出错，maven的profiles可以解决这个问题，我们只需要勾选需要的环境，就可以动态的打包出不同的配置了。如下图： pom.xml中的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;ALL20171128134549&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;basedir&#125;/lib/alipay-sdk-java-ALL20171128134549.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;env&gt;prod&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;build&gt; &lt;finalName&gt;scm&lt;/finalName&gt; &lt;filters&gt; &lt;filter&gt;src/main/resources/profiles/$&#123;env&#125;.properties&lt;/filter&gt; &lt;/filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--打包war,引入lib下的jar--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;warName&gt;$&#123;project.artifactId&#125;&lt;/warName&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;lib/&lt;/directory&gt; &lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;!-- &lt;url&gt;http://192.168.25.138:8080/manager/text&lt;/url&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;password&gt;tomcat&lt;/password&gt; --&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; dev.properties的配置 123456789101112131415profile.env=dev#支付宝网关alipay.gateway = https://openapi.alipaydev.com/gateway.do#支付宝appidalipay.app.id = appid#私钥alipay.private.key = 私钥#公钥alipay.public.key =公钥#支付宝授权登录页alipay.url = https://openauth.alipaydev.com/oauth2/publicAppAuthorize.htm#支付宝授权成功之后的回调地址redirect.url = 回调地址#我们自己网站的域名,用于重定向至错误页面web.site = www.baidu.com prod.properties的配置 123456789101112131415profile.env=prod#支付宝网关alipay.gateway = https://openapi.alipaydev.com/gateway.do#支付宝appidalipay.app.id = appid#私钥alipay.private.key = 私钥#公钥alipay.public.key =公钥#支付宝授权登录页alipay.url = https://openauth.alipaydev.com/oauth2/publicAppAuthorize.htm#支付宝授权成功之后的回调地址redirect.url = 回调地址#我们自己网站的域名,用于重定向至错误页面web.site = www.baidu.com 通过profile.env指定不同的环境 sys-config.properties核心文件的配置（看你spring中引入的是哪个配置文件了）12345678910env=$&#123;profile.env&#125;alipay.gateway=$&#123;alipay.gateway&#125;alipay.app.id=$&#123;alipay.app.id&#125;alipay.private.key=$&#123;alipay.private.key&#125;alipay.public.key=$&#123;alipay.public.key&#125;alipay.url=$&#123;alipay.url&#125;redirect.url=$&#123;redirect.url&#125;web.site=$&#123;web.site&#125;#endpoint = http://oss-cn-qingdao.aliyuncs.com 如果没有特别的需要是不用再这里在写alipay.gateway=${alipay.gateway}，我这里因为java类中用到了读配置文件的value值来生成实例，我就让java类来读这个sys-config.properties，而不去读dev.properties，所以这里用占位符的方式指定不确定的值。 打包时如果用的是idea（eclipse我没试）直接在右上角的位置选定你需要的环境打就可以了，比较方便。3.补充之前知识：我之前写过一篇【spring.xm中配置文件使用占位符】，再次贴出来，可以结合着一块来看，全文如下：在spring中，可以使用PropertyPlaceholderConfigurer引入properties的配置文件，在配置文件中定义key，value形式的键值对，之后在xml中读取${key}的值，可以灵活的配置常用参数。1.定义.properties的配置文件这里用一个mysql数据库连接的配置文件做测试。1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://192.168.49.127\:3306/test?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;useSSL=truejdbc.username=rootjdbc.password=root 2.在.xml中引入.properties配置文件12345678&lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath*:jdbc.properties&lt;/value&gt; &lt;value&gt;/WEB-INF/mail.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 注意上面一种classpath是引用src目录下的文件写法，下面一种是引入在WEB-INF下面的文件。如果引入单个文件，还可以不用list。1234567&lt;bean id=&quot;propertyConfigurerForProject1&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;location&quot;&gt; &lt;value&gt;classpath:/com/catchu/me/jdbc.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 3.使用配置文件123456&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/bean&gt; 使用时直接使用${}就可以了，类似于EL表达式。]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用支付宝账号授权登录网站]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%94%AF%E4%BB%98%E5%AE%9D%E8%B4%A6%E5%8F%B7%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[本周在项目开发中使用到了支付宝授权登录（一键登录）我们的网站，周末做一下总结： 0.总体思路为防止各位朋友看迷糊，先说一下整体执行流程：用户在我们网站点击一个“支付宝授权登录”按钮，请求到了java后台，完成跳转至支付宝之前的字符串拼接（包括回调地址，appid，scope，state），后台将这个地址处理完成之后返回给前端，前端通过window.href=”url”的形式跳转至支付宝登录页面，用户通过输入密码或者扫码，支付宝判断如果正确就会携带支付宝用户id和access_token跳转至我写的回调地址里面（这个回调地址是我们自己写的，让支付宝调用的，需要在支付宝页面配置，下面会说），我根据alipay_user_id查自己的库，看用户是否存在，如果存在说明已经与我们平台的用户系统进行绑定，将其重定向至成功页，否则重定向至绑定用户信息页，完善信息。需要明白的是我们平台也有自己的用户系统，必须将从支付宝拿过来的alipay_user_id与我们平台的用户系统进行绑定，否则区分不出哪个是哪个用户，绑定就是在这个完善用户信息页面进行的。 1.开通蚂蚁金服开发服务并配置完成。上面只说了思路，下面说具体的操作流程。既然需要调用支付宝的接口，那就要开通蚂蚁金服的服务，通过下面地址开通：https://openhome.alipay.com/platform/appManage.htm ，需要营业执照或者身份证信息，审核通过后创建应用，并在功能选项中选择要使用的服务，比如我这里使用“获取会员信息”，点击“继续添加”可以添加其他的，如下图：点击概览下面的应用信息，配置回调地址和公钥，密钥，如下图：随后下载支付宝sdk的jar，已经集成了非常简单的调用方法。参考文档如下：https://docs.open.alipay.com/289/105656#s3 2.代码开发代码开发不太难，有点绕的是怎么传参。我是通过state传递的。从官方文档中可以看到：state参数不是必须参数，属于商户自定义参数，用户授权后，重定向到redirect_uri时会原样回传给商户，而且最大长度只能是100，最好是做到既不可预测，又可以证明客户端和当前第三方网站的登录认证状态存在关联，那我们就可以通过state参数进行传递，比如我这里通过1_0，2_500这种形式拼接的，前面的数代表操作类型，比如我这里1代表登录，2代表修改支付宝账号，0代表无上级id，大于0表示那就是上级id，如500代表上级id，然后拿到传递过来的参数之后使用split参数进行分割、解析、判断不同情况，部分示例代码如下：12345678910111213141516171819/** * @Description 登录接口 * @Author 刘俊重 */@NoLogin@RequestMapping(&quot;/supplierLogin&quot;)public R supplierLogin(@RequestBody Map&lt;String, Object&gt; map) throws Exception &#123; //获取核心企业id，0表示不是通过核心企业邀请链接登录 Object coreId = map.get(&quot;coreId&quot;); if (null == coreId || coreId == &quot;&quot;) &#123; coreId = 0; &#125; String s = DbEnum.CallBack.Type.LOGIN+&quot;_&quot;+coreId; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;s&quot;+s); /***重定向至支付宝授权登录页*/ String encode = URLEncoder.encode(SystemVar.REDIRECT_URL,&quot;UTF-8&quot;); return R.ok().put(&quot;visitUrl&quot;, SystemVar.ALIPAY_URL+&quot;?app_id=&quot; + SystemVar.APP_ID + &quot;&amp;scope=auth_user&amp;redirect_uri=&quot; + encode + &quot;&amp;state=&quot; + s);&#125; 回调函数部分代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * @Description 支付宝登录成功之后的回调函数，供支付宝调用 * @Author 刘俊重 */ @NoLogin @RequestMapping(&quot;/callBackLogin&quot;) @ResponseBody public R callBackLogin(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; String authCode = request.getParameter(&quot;auth_code&quot;); String state = request.getParameter(&quot;state&quot;); /***我们需要的参数，拿到之后以下划线分割*/ if(null==state || state==&quot;&quot;)&#123; return R.error(&quot;获取支付宝授权失败&quot;); &#125; AlipaySystemOauthTokenResponse authToken = getAuthToken(authCode); if (null == authToken) &#123; return R.error(&quot;获取支付宝授权失败&quot;); &#125; String userId = authToken.getUserId(); String accessToken = authToken.getAccessToken(); String[] split = state.split(&quot;_&quot;); String type = split[0]; if(DbEnum.CallBack.Type.LOGIN.equals(type))&#123; String coreId = split[1]; //登录 /***根据支付宝用户id查询供应商是否存在*/ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;alipayUserId&quot;, userId); SuppliersInfo suppliersInfo = suppliersInfoService.look(map); if (null == suppliersInfo) &#123; if(&quot;0&quot;.equals(coreId))&#123; //说明没有注册而且没有带核心企业id，跳转至错误提示页面 response.sendRedirect(SystemVar.WEBSITE + &quot;/#/error?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); return R.ok(); &#125; //根据上级id查询是否确实存在，避免乱注册 Map&lt;String, Object&gt; param = new HashMap&lt;String, Object&gt;(); param.put(&quot;finmallId&quot;, coreId); CoreCorpInfo coreCorpInfo = coreCorpInfoService.look(param); if (null == coreCorpInfo) &#123; response.sendRedirect(SystemVar.WEBSITE + &quot;/#/error?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); return R.ok(); &#125; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;完善信息地址&quot;+SystemVar.WEBSITE + &quot;/#/fillCompMess?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); //信息不存在，说明没有注册，去完善信息页 response.sendRedirect(SystemVar.WEBSITE + &quot;/#/fillCompMess?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); return R.ok(); &#125; String auditState = suppliersInfo.getAuditState(); if (SuppliersInfo.AuditState.WAIT.equals(auditState)) &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;待审核地址&quot;+SystemVar.WEBSITE + &quot;/#/waitExam?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); //待审核，进待审核提示页 response.sendRedirect(SystemVar.WEBSITE + &quot;/#/waitExam?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); return R.ok(); &#125; else if (SuppliersInfo.AuditState.UNPASSED.equals(auditState)) &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;审核拒绝地址&quot;+SystemVar.WEBSITE + &quot;/#/refuse?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); //审核拒绝，进审核拒绝提示页 response.sendRedirect(SystemVar.WEBSITE + &quot;/#/refuse?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); return R.ok(); &#125; else if (SuppliersInfo.AuditState.PASSED.equals(auditState)) &#123; //审核通过，把用户信息放session中 String token = TokenUtils.getToken(); cacheManager.getCache(SysCache.SESSION_CACHE_NAME).put(token, suppliersInfo); //往cookie中添加token CookieUtils.setCookie(request, response, CookieName.SCM_TOKEN, token); logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;审核通过地址&quot;+SystemVar.WEBSITE + &quot;/#/alipay?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId + &quot;&amp;token=&quot; + token); response.sendRedirect(SystemVar.WEBSITE + &quot;/#/alipay?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId + &quot;&amp;token=&quot; + token); return R.ok(); &#125; &#125; return null; &#125; 支付宝获取获取authToken方法如下（支付宝中也有示例）：123456789101112131415161718192021/** * @Description 获取支付宝authToken * @Author 刘俊重 * @Date 2017/11/27 */private AlipaySystemOauthTokenResponse getAuthToken(String authCode) &#123; AlipayClient alipayClient = new DefaultAlipayClient(SystemVar.ALIPAY_GATEWAY, SystemVar.APP_ID, SystemVar.PRIVATE_KEY, &quot;json&quot;, CHARSET_UTF8, SystemVar.ALIPAY_PUBLIC_KEY, &quot;RSA2&quot;); AlipaySystemOauthTokenRequest request = new AlipaySystemOauthTokenRequest(); request.setCode(authCode); request.setGrantType(&quot;authorization_code&quot;); AlipaySystemOauthTokenResponse oauthTokenResponse = null; try &#123; oauthTokenResponse = alipayClient.execute(request); System.out.println(oauthTokenResponse.getAccessToken()); &#125; catch (AlipayApiException e) &#123; //处理异常 e.printStackTrace(); &#125; return oauthTokenResponse;&#125; 到这里已经可以获取到alipay_user_id供我们使用了，如果还想获取其它信息，可以使用accessToken换取用户信息，文档中有，这里不再赘述。 3.如何配置支付宝沙箱测试支付宝的回调地址只能填写一个，如果项目已经上线了，那总不能一会把回调地址配置成生产的，一会配置成测试的吧，好在支付宝提供了一套供测试使用的沙箱环境，沙箱环境的文档地址如下：https://docs.open.alipay.com/200/105311 ，也可以看我下面说的这些：首先进入如下地址：https://openhome.alipay.com/platform/appDaily.htm?tab=info 配置沙箱环境，包括沙箱的网关，授权url，appid，公钥，密钥，均跟生产的都不同，需要重新配置，其中授权url如下：https://openauth.alipaydev.com/oauth2/publicAppAuthorize.htm 。沙箱环境使用正常的支付宝账号也无法登录，必须要使用沙箱环境分配的账号，可以在下面地址中找到沙箱测试账号：https://openhome.alipay.com/platform/appDaily.htm?tab=account ，以上便是支付宝授权登录网站的开发流程。]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>支付宝登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度统计数据导出服务踩的坑]]></title>
    <url>%2F2017%2F12%2F14%2F%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E6%9C%8D%E5%8A%A1%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[今天在项目中引入百度统计，我们是打算在我们的页面中引入百度提供的接口，而不仅仅是用百度统计里面的一些js，中途踩到一些坑，做下记录。 ###1. 开通百度统计导出服务这个导出服务算是高级功能吧，开通完之后百度统计会给你分配一个token，在后面会用到，开通的图如下： 2.通过代码调用百度统计的接口为避免看此篇文章的同学不看完就动手操作导致翻车，先说结论，直接在postman中测即可，不用登录，不清楚的继续往下看。在官网页面我首先看到最下面的示例代码和开发文档，把它们下载下来看，发现效果不好，一大坨一大坨的，直接用postman测https://api.baidu.com/json/tongji/v1/ReportService/getSiteList 这个接口，报如下错误：12345678910111213&#123; &quot;header&quot;: &#123; &quot;desc&quot;: &quot;system failure&quot;, &quot;failures&quot;: [ &#123; &quot;code&quot;: 8603, &quot;message&quot;: &quot;The request header you provided is invalid. sn:289933044807937&quot;, &quot;position&quot;: &quot;_sys&quot; &#125; ], &quot;status&quot;: 3 &#125;&#125; 难道姿势不对，我又回过头来仔细的看百度文档，终于翻到下面这篇文档，我如获至宝，以为可以把问题解决，但就是这篇文档把我一步步带到坑中。1http://tongji.baidu.com/open/api/more?p=tongjiapi_guide.tpl 它在使用流程中写到，首先要进行身份认证，就是根据账号，密码和token进行身份验证，之后进行站点选择，这让我坚信，我上面操作失败是因为少了一步登录操作，我开始去百度上搜索这个问题，回答着寥寥，大部分都是提问，其中有一两个回答把我引到了github上，网址如下：12https://github.com/nqdy666/BaiduTongjiClient和https://github.com/justlive1/baiduTongJi 一个是gradle项目一个是maven项目，费了老牛鼻子劲把这两个项目捡下来，下载依赖包，跑起来发现依旧不能运行，这就走了好大的弯路，现在又会过头在继续搜在postman中遇到的那个说请求头不可用的问题，发现下面一篇文档：1https://www.cnblogs.com/w1570631036/p/7096966.html?utm_source=debugrun&amp;utm_medium=referral 然后我把请求体进行了修改，直接就请求成功了，详见如下截图， 请求体代码如下：123456789101112131415&#123; &quot;header&quot;: &#123; &quot;account_type&quot;: 1, &quot;password&quot;: &quot;你的密码&quot;, &quot;token&quot;: &quot;你的token&quot;, &quot;username&quot;: &quot;你的用户名&quot; &#125;, &quot;body&quot;: &#123; &quot;siteId&quot;:&quot;你的siteId&quot;, &quot;method&quot;: &quot;visit/district/a&quot;, &quot;start_date&quot;: &quot;20170818&quot;, &quot;end_date&quot;: &quot;20171118&quot;, &quot;metrics&quot;: &quot;pv_count,visitor_count,avg_visit_time&quot; &#125;&#125; 如果postman能请求成功，那么我们使用java编写httpclient发送请求肯定也是可以的，我想纠正的就是百度统计的getSiteList和getData这两个接口只要你有用户名，密码，token（siteId在首页点击网站名称进去在浏览器地址栏中问号后面就可以获取到）组织好请求体就可以调用，完全不是某些网友回答的要费很大劲登录后才能调用，使用httpclient怎么调用就不说了，实在不会引入一个hutool工具包，里面有现成的工具类，最后希望大家少走弯路！！]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>百度统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven项目和gradle项目互相转化]]></title>
    <url>%2F2017%2F12%2F14%2Fmaven%E9%A1%B9%E7%9B%AE%E5%92%8Cgradle%E9%A1%B9%E7%9B%AE%E4%BA%92%E7%9B%B8%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.maven项目转gradle项目 cmd命令行进入maven项目的根目录（即pom.xml文件所在的路径），执行如下命令：1gradle init --type pom 执行完之后会生成build.gradle和setting.gradle等gradle项目的配置文件。 2.gradle项目转maven项目 在你要转化的项目的build.gradle中加入以下代码：123456apply plugin: &apos;java&apos;apply plugin: &apos;maven&apos;group = &apos;com.cachu&apos;version = &apos;1.0.0&apos;sourceCompatibility = 1.7 group和version可以自己随便命名，artifactId默认为目录名称，sourceCompatibility是编译的jdk的版本。 cmd命令行进入你要转化的项目的路径下（即步骤1中build.gradle所在的目录），执行gradle install 命令。完整命令如下： 12345678910111213141516171819202122C:\Users\CatchU&gt;d:D:\&gt;cd D:\gitLocalRepo\innerManage\fmInnerManageD:\gitLocalRepo\innerManage\fmInnerManage&gt;gradle installStarting a Gradle Daemon, 2 incompatible and 1 stopped Daemons could not be reused, use --status for details:compileJavaDownload https://jcenter.bintray.com/com/aliyun/aliyun-java-sdk-core/3.4.0/aliyun-java-sdk-core-3.4.0.pomDownload https://jcenter.bintray.com/org/json/json/20170516/json-20170516.pomDownload https://jcenter.bintray.com/javax/mail/mail/1.4/mail-1.4.jarDownload https://jcenter.bintray.com/com/aliyun/aliyun-java-sdk-core/3.4.0/aliyun-java-sdk-core-3.4.0.jarDownload https://jcenter.bintray.com/javax/activation/activation/1.1/activation-1.1.jarDownload https://jcenter.bintray.com/org/json/json/20170516/json-20170516.jar注: 某些输入文件使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。:processResources:classes:war:installBUILD SUCCESSFULTotal time: 1 mins 9.01 secsD:\gitLocalRepo\innerManage\fmInnerManage&gt; 上面命令执行完毕之后会在build——poms——pom-default.xml找到pom文件，将其复制到项目下改为pom.xml即可。到此gradle项目转maven项目就完成了。如果maven编译时出现如下警告： 1WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent! 在pom.xml中加入如下代码：123&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt;]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven将jar包安装到本地仓库]]></title>
    <url>%2F2017%2F12%2F14%2Fmaven%E5%B0%86jar%E5%8C%85%E5%AE%89%E8%A3%85%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[现在有一个问题，我用到阿里云发短信的服务时，在maven中央仓库没有aliyun-java-sdk-dysmsapi-1.0.0的jar包，只能把它下载到本地，然后打包到本地仓库。方法如下： 首先将jar复制到本地仓库并命令行进入。 12C:\Users\CatchU&gt;d:D:\&gt;cd D:\maven3.5\myRepo\com\aliyun 执行下面打包命令 1mvn install:install-file -Dfile=aliyun-java-sdk-dysmsapi-1.0.0.jar -DgroupId=com.aliyun -DartifactId=aliyun-java-sdk-dysmsapi -Dversion=1.0.0 -Dpackaging=jar pom.xml文件中使用： 12345&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取javaweb文件路径]]></title>
    <url>%2F2017%2F12%2F14%2F%E8%8E%B7%E5%8F%96javaweb%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.java工具类中获取resources下面的文件夹下面的文件路径。例如resources/img/logo.png。 1SendMailUtil.class.getClassLoader().getResource(&quot;img/logo.png&quot;).getPath() 输出结果：/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/resources/img/logo.png 2.获取java工具类中classpath（class文件的路径）。 123456System.out.println(Class.class.getClass().getResource(&quot;/img/logo.png&quot;).getPath());System.out.println(Thread.currentThread().getContextClassLoader().getResource(&quot;img/logo.png&quot;));System.out.println(SendMailUtil.class.getClassLoader().getResource(&quot;img/logo.png&quot;));System.out.println(ClassLoader.getSystemResource(&quot;&quot;));System.out.println(SendMailUtil.class.getResource(&quot;&quot;));System.out.println(SendMailUtil.class.getResource(&quot;/&quot;)); /D:/gitLocalRepo/innerManage/fmInnerManage/out/production/resources/img/logo.pngfile:/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/resources/img/logo.pngfile:/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/resources/img/logo.pngfile:/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/classes/file:/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/classes/com/ynet/finmall/innermanage/utils/file:/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/classes/]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一级缓存引发的问题]]></title>
    <url>%2F2017%2F12%2F14%2FMybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天出现一个很奇怪的问题，更新数据库之后查询并没有走数据库，没有打印sql语句，导致更新未生效，一开始以为是mybatis二级缓存，禁止之后还是有这样的问题，仔细检查代码，发现同事在Java代码方法中加了事务Transactional，当开始事务后，spring会使用同一个sqlsession做查询，一级缓存生效，导致没有跑库。]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker与Java框架整合]]></title>
    <url>%2F2017%2F12%2F14%2FFreeMarker%E4%B8%8EJava%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.FreeMarker与Servlet的整合FreeMarker与Servlet的整合有两种方式： 在Servlet中直接处理模版与数据模型，然后输出到响应中。示例代码：123456789101112131415161718192021222324252627282930313233@WebServlet(name=&quot;test&quot;,urlPatterns=&quot;/test&quot;)public class Test extends HttpServlet &#123; private Configuration cfg; /** * @Description 初始化Configuration * @Author 刘俊重 * @date 2017年11月19日 */ @Override public void init() throws ServletException &#123; cfg = new Configuration(Configuration.VERSION_2_3_22); cfg.setServletContextForTemplateLoading(getServletContext(), &quot;WEB-INF/ftl&quot;); &#125; /** * @Description 接收请求 * @Author 刘俊重 * @date 2017年11月19日 */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Map map = new HashMap(); map.put(&quot;name&quot;, &quot;Java开发日记&quot;); map.put(&quot;list&quot;, Arrays.asList(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;)); Template template = cfg.getTemplate(&quot;index.ftl&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); Writer writer = response.getWriter(); try &#123; template.process(map, writer); &#125; catch (TemplateException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Servlet接收到test的请求之后直接在doGet方法中处理完数据与模板的整合，把处理后的数据响应给用户。 配置web.xml文件：设置处理*.ftl的Servlet为 freemarker.ext.servlet.FreemarkerServlet。示例代码如下： 12345678910@WebServlet(name=&quot;test2&quot;,urlPatterns=&quot;/test2&quot;)public class Test2 extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute(&quot;name&quot;, &quot;Java开发日记&quot;); request.setAttribute(&quot;list&quot;, Arrays.asList(&quot;战三&quot;,&quot;李四&quot;,&quot;王五&quot;)); request.getRequestDispatcher(&quot;index.ftl&quot;).forward(request, response); &#125;&#125; web.xml中进行如下配置：123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;TemplatePath&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/ftl&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ContentType&lt;/param-name&gt; &lt;param-value&gt;text/html;charset=UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;default_encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 整段的意思是当请求test2时，将数据set进request中，并将请求转发至index.ftl页面，而又在web.xml中又进行了如下配置：所有请求以ftl结尾的文件时，都交给freemarker.ext.servlet.FreemarkerServlet处理，在这个类里面将数据和模板进行整合返回给用户。所以完整的顺序是请求先到达doGet方法，在这里面进行了请求转发至FreemarkerServlet类中完整数据和模板的组装响应给用户。 2.FreeMarker与Struts的整合Struts框架已经好久不用了，上次用还是在大学的时候，但是Struts2默认的模版技术就是FreeMarker，所以还是有必要说一下的。Struts中使用FreeMarker非常简单，只需要在结果类型中配置result的type=”freemarker”即可。测试类TestAction:123456789101112public class TestAction &#123; private String name; private List&lt;String&gt; nameList; public String execute()&#123; name=&quot;Java开发日记&quot;; nameList = Arrays.asList(&quot;战三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;); return &quot;success&quot;; &#125; //省略set/get方法 &#125; struts.xml的配置：1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;package name=&quot;testfreemarker&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;test&quot; class=&quot;com.catchu.me.TestAction&quot;&gt; &lt;result type=&quot;freemarker&quot; name=&quot;success&quot;&gt;/test.ftl&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; web.xml中的配置：1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 首先在web.xml中使用过滤器配置struts的核心过滤器StrutsPrepareAndExecuteFilter，再在struts.xml中配置请求项，当请求test时交给com.catchu.me.TestAction类进行处理，如果处理结果是“success”时，响应test.ftl文件，其中结果类型是freemarker。 3.FreeMarker与SpringMvc整合FreeMarker与SpringMvc的整合要点是配置FreeMarkerConfigurer和FreeMarkerViewResolver，即如下两个类：bean class=”org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer”bean class=”org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver”TestController代码：123456789@Controllerpublic class TestController &#123; @RequestMapping(&quot;/test&quot;) public String test(Model model)&#123; model.addAttribute(&quot;name&quot;, &quot;Java开发日记&quot;); model.addAttribute(&quot;nameList&quot;, Arrays.asList(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;)); return &quot;test&quot;; &#125;&#125; web.xml123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;3.0&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;withSpringMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;withSpringMvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; withSpringMvc-servlet.xml123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-3.0.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt; &lt;mvc:annotation-driven /&gt; &lt;mvc:default-servlet-handler /&gt; &lt;context:component-scan base-package=&quot;com.catchu.me&quot; /&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/&quot; /&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在withSpringMvc-servlet.xml中配置注解驱动，扫描包，模板路径，编码方式，后缀名等信息，当请求test时即返回一个test的model，又因为配置了后缀为ftl，即响应test.ftl文件]]></content>
      <categories>
        <category>后台—模板引擎</category>
      </categories>
      <tags>
        <tag>模板引擎</tag>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker基本语法]]></title>
    <url>%2F2017%2F12%2F14%2FFreeMarker%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.FreeMarker介绍FreeMarker是一种模板引擎，通过定义的模板和数据来生成文本（包括但不局限于html，js，java等文本格式），通俗的讲就是先定义一下模板，然后传入不同的数据，动态的生成不同的文本，但它不是面向用户的，而是面向程序员的，可以直接自动的生成代码，减少程序员重复的劳动。FreeMarker最重要的两部分是模板和数据：模板：FreeMarker Template Language，简称FTL，模板文件以ftl为后缀，组成： 文本，包括HTML标签与静态文本等静态内容，会原样输出； 插值：这部分的输出会被计算的数据来替换，使用${}这种语法； 标签：给FreeMarker的指示，可以简单与指令等同，不会打印在内容中； 注释：由&lt;#–和–&gt;表示，不会被freemarker处理数据结构：树状结构：HashMap，Scalar，Sequence 2.基本使用从http://freemarker.org/ 下载FreeMarker的压缩包，将其中的freemarker.jar加到项目的构建路径下从maven仓库中引入maven依赖的jar包，注意两个核心类： 12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.24-atlassian-2&lt;/version&gt;&lt;/dependency&gt; Configuration：读取模板文件 Template：模板1234567891011Configuration cfg = new Configuration(Configuration.VERSION_2_3_21);Map&lt;String,String&gt; root= new HashMap&lt;String,String&gt;();root.put(&quot;name&quot;, &quot;Java开发日记&quot;); try &#123; cfg.setDirectoryForTemplateLoading(new File(&quot;src/ftl&quot;)); Template template = cfg.getTemplate(&quot;helloworld.ftl&quot;); Writer writer = new FileWriter(new File(&quot;src/finish/helloworld.html&quot;)); template.process(root, writer); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 使用Configuration读取配置文件，使用Map填充数据，给配置文件配置模板文件夹路径，读取模板文件，设置输出文件路径helloworld.html，执行输出文件，执行完之后就会在src目录下的finish文件夹中生成一个helloworld的html文件。模板文件如下：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;$&#123;name&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是我的第一个程序,$&#123;name&#125;&lt;/body&gt;&lt;/html&gt; 3.模板3.1 数据类型与变量模板中的数据类型： 标量：字符串，数字，布尔值，日期； 容器：哈希表，序列； 子程序：方法和函数，用户自定义指令；模板中的变量：简单变量，局部变量，循环变量，使用赋值指令：assign示例：1234567891011121314&lt;#assign num=10&gt;$&#123;num&#125;&lt;#assign name=&quot;Java开发日记&quot;&gt;$&#123;name&#125;&lt;#assign b=true&gt;$&#123;b?c&#125;&lt;#assign map=&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:15&#125;&gt;$&#123;map.name&#125;&lt;#assign list = [1,3,5]&gt;$&#123;list[2]&#125; freemarker中使用指令时必须要在指令前面用#（如果是自定义指令用@,后面说），assign指令是用来声明变量的，注意：如果是布尔值，输出时一定要带?c，表示定义的变量是布尔值，不然会报错。 3.2运算符模板中支持运算符： 算术运算符 比较运算符 逻辑运算符 空值处理运算符12345&lt;#assign b=1==2&gt;$&#123;b?c&#125;&lt;#assign b=1 gt 2&gt;$&#123;b?c&#125; 均输出false，gt表示大于。 3.3 插值插值是用来给插入具体值然后转换为文本，说白了，插值就是使用${}在那占个坑。使用位置： 文本区（如Hello ${name}!） 字符串表达式（如&lt;#include “/footer/${company}.html”&gt;）语法：${表达式}注意：插值表达式的结果必须是字符串，数字或日期类型。3.4指令 条件指令12345678910111213141516171819202122232425&lt;#assign score=50&gt;&lt;#if score gt 90&gt;优秀&lt;#elseif score gt 70&gt;良好&lt;#elseif score gt 60&gt;及格&lt;#else&gt;渣渣&lt;/#if&gt;&lt;#assign level=&quot;B&quot;&gt;&lt;#switch level&gt; &lt;#case &quot;A&quot;&gt; 优秀 &lt;#break &gt; &lt;#case &quot;B&quot;&gt; 良好 &lt;#break &gt; &lt;#case &quot;C&quot;&gt; soso &lt;#break &gt; &lt;#default&gt; 渣渣&lt;/#switch&gt; 需要注意的是switch语句需要有break，不然一直往下执行。 循环指令12345678&lt;#assign nums=[1,2,3,4,5]&gt;&lt;#list nums as num&gt; $&#123;num_index&#125;,$&#123;num&#125;,$&#123;num_has_next?c&#125;&lt;/#list&gt;&lt;#list nums as num&gt; $&#123;num&#125;&lt;#if num_has_next&gt;,&lt;/#if&gt;&lt;/#list&gt; 定义一个集合nums，使用list指令遍历，${别名_index}获取遍历的索引值，${别名_has_next}判断后面是否还有值，根据这个特性，可以结合if指令拼接不同的值（自动生成mybatis的配置文件时，不同字段最后一个后面不要逗号，用这个特性很好用）。 包含指令12&lt;#include &quot;condition.ftl&quot;&gt;从这里开始是自己的内容 使用include引入指令可以引入其它的模板页面。如果页面路径写不好可以用通配符，&lt;#include “*/condition.ftl”&gt; 其它原样输出指令noparse：它里面的内容是原样输出的；压缩指令compress：压缩所有的空格；设置指令setting：设置影响FreeMarker的值。 12345678910111213&lt;#noparse&gt; &lt;#assign num=1&gt; $&#123;num&#125;&lt;/#noparse&gt;&lt;#assign s=&quot; test \n\n&quot;&gt;&lt;#compress&gt; $&#123;s&#125; Compress&lt;/#compress&gt;&lt;#setting locale=&quot;hu&quot;&gt;$&#123;1.2&#125; 自定义指令可以将模版中重复的内容进行复用定义：使用macro指令定义或者使用Java实现。参数的声明：直接跟在指令名后，可以指定默认值嵌套内容：使用nested指令调用：使用&lt;@指令&gt;来调用（调用freemarker自带的指令用#命令）。 1234&lt;#macro mydirect name age=20&gt; 你好，$&#123;name&#125;,你今年$&#123;age&#125;&lt;/#macro&gt;&lt;@mydirect name=&quot;Java开发日记&quot; age=1/&gt; 自定义一个指令名为mydirect，它有两个参数name和age，其中age有默认值20，使用自定义指令时用@+自定义指令，同时为参数赋值即可。注意自定义指令是闭口的，不要漏掉最后的斜杠。 3.5 空处理有时候对象是空的，不进行判断就贸然进行处理会报错，所以要提前进行判空处理。 null对象的处理方式:使用!，只会做最后一个属性的判断； 变量不存在的处理方式:使用!或??做判断。123456$&#123;user.name!&#125;&lt;#if user.name??&gt; 名称存在 &lt;#else&gt; 名称不存在&lt;/#if&gt; 我认为是在插值时使用!，在其它指令内使用??。 3.6名称空间在编写可重复使用的模板时为了避免命名冲突，使用import指令导入命名空间。命名空间有点类似于java的包，即使类名相同，只要位于不同的包下，也是可以的。1234567test.ftl模板：&lt;#macro mydirective name&gt; 你好，$&#123;name&#125;&lt;/#macro&gt;namespace.ftl模板&lt;#import &quot;test.ftl&quot; as ns&gt;&lt;@ns.mydirective name=&quot;Java开发日记&quot; /&gt; 在这里我定义两个模板，在namespace.ftl中使用import指令导入test.ftl模板并为它起一个名为ns的命名空间，调用时我使用命令空间调用，即使namespace.ftl模板中有其它同名的也不至于混淆。另外在test.ftl中使用的是自定义指令定义了名为mydirective的指令，并为其制定一个参数name。 3.7函数FreeMarker中函数有如下几种： 字符串函数； 数字，日期布尔类型的函数； 序列（list，set）与哈希的函数； 自定义函数而且FreeMarker中的函数与java中函数调用有个很大的区别，在java中调用函数使用点号(.),而在FreeMarker中使用问号(?),这一点一定要记清。下面分别说上面提到的几种函数：3.7.1字符串函数1234567891011121314151617181920$&#123;&quot;abcdef&quot;?substring(2)&#125; &lt;#--从角标是2的位置开始截取到字符串结束--&gt;$&#123;&quot;abcdef&quot;?substring(2,4)&#125; &lt;#--从角标是2的位置开始截取到角标是4的位置，包括2不包括4（包前不包后）--&gt;$&#123;&quot;abcd mn&quot;?cap_first&#125; &lt;#--将整个字符串的首字母转大写--&gt;$&#123;&quot;Abcd&quot;?uncap_first&#125; &lt;#--将整个字符串的首字母转小写--&gt;$&#123;&quot;fden eb&quot;?capitalize&#125; &lt;#--将字符串的每个单词首字母转大写--&gt;$&#123;&quot;abcd&quot;?ends_with(&quot;d&quot;)?c&#125; &lt;#--是否以字符d结尾，这个结果是布尔值，不能直接输出，不然会报错，用?c转化成字符串--&gt;$&#123;&quot;abcd&quot;?starts_with(&quot;d&quot;)?c&#125; &lt;#--是否以字符d开头--&gt;$&#123;&quot;abac&quot;?index_of(&quot;a&quot;)&#125; &lt;#--字符a首次出现的位置--&gt;$&#123;&quot;abac&quot;?last_index_of(&quot;a&quot;)&#125; &lt;#--字符a最后一次出现的位置--&gt;$&#123;&quot;ab&quot;?left_pad(15,&quot;xy&quot;)&#125; &lt;#--将字符串ab填充成15位，如果不够15位，则左边循环填充xy--&gt;$&#123;&quot;ab&quot;?right_pad(15,&quot;xy&quot;)&#125; &lt;#--将字符串ab填充成15位，如果不够15位，则右边循环填充xy--&gt;$&#123;&quot;abac&quot;?contains(&quot;ab&quot;)?c&#125; &lt;#--判断字符串abac是否包含ab--&gt;$&#123;&quot;abac&quot;?replace(&quot;ab&quot;,&quot;AB&quot;)&#125; &lt;#--将ab替换成AB--&gt;&lt;#list &quot;abcabcabc&quot;?split(&quot;c&quot;) as s&gt; $&#123;s&#125; &lt;#--将字符串以c字符进行分割，结果是个数组，进行遍历--&gt;&lt;/#list&gt;$&#123;&quot; abc &quot;?trim&#125; &lt;#--去掉字符串空格--&gt;&lt;#list &quot; Hello FreeMarker Yes&quot;?word_list as s&gt;$&#123;s&#125; &lt;#--将字符串分割成一个个的单词，存在多个空格时，这个跟上面的split分割有一点区别--&gt;&lt;/#list&gt; 3.7.2数字，日期布尔类型的函数123456789101112131415$&#123;4.2?c&#125; &lt;#--以字符串的形式输出，上面说的布尔类型不能直接输出只能转化成字符串这种--&gt;$&#123;4.2?string&#125; &lt;#--与?c一样--&gt;$&#123;0.42?string.percent&#125; &lt;#--以百分号输出42%--&gt;$&#123;4.2?string.currency&#125; &lt;#--以货币形式输出￥4.20--&gt;$&#123;4.7?round&#125; &lt;#--四舍五入 --&gt;$&#123;4.7?floor&#125; &lt;#--向下取整，floor地板 --&gt;$&#123;4.7?ceiling&#125; &lt;#--向上取整，ceiling天花板--&gt;$&#123;date?string(&quot;yyyy-MM-dd&quot;)&#125; &lt;#--传入日期date，以yyyy-MM-dd形式输出，2017-11-18--&gt;$&#123;date?date&#125; &lt;#--输出年月日2017-11-18--&gt;$&#123;date?time&#125; &lt;#-- 输出时分秒20:41:49--&gt;$&#123;date?datetime&#125; &lt;#--输出年月日时分秒--&gt;$&#123;false?string(&quot;yes&quot;,&quot;no&quot;)&#125; &lt;#--条件如果成功输出yes,否则输出no--&gt;$&#123;4.2355?string(&quot;0.##&quot;)&#125; &lt;#--保留小数点后两位--&gt; 3.7.3 序列（list，set）与哈希的函数123456789101112131415161718192021222324252627282930&lt;#assign seq=[1,2,3,4,5,3,10]&gt;$&#123;seq?first&#125; &lt;#-- 输出序列seq的第一个--&gt;$&#123;seq?last&#125; &lt;#-- 输出序列seq的最后一个--&gt;$&#123;seq?seq_contains(6)?c&#125; &lt;#--判断序列是否包含6--&gt;$&#123;seq?seq_index_of(3)&#125; &lt;#--3在序列中首次出现的位置--&gt;$&#123;seq?seq_last_index_of(3)&#125; &lt;#--3在序列中最后一次出现的位置--&gt;&lt;#list seq?reverse as num&gt; &lt;#--翻转序列seq，结果还是一个序列，进行遍历--&gt;$&#123;num&#125;&lt;/#list&gt;$&#123;seq?size&#125; &lt;#--序列seq的长度--&gt;&lt;#list seq?sort as num&gt; &lt;#--对序列进行排序--&gt;$&#123;num&#125;&lt;/#list&gt;&lt;#assign seq1=[&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:23&#125;,&#123;&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:22&#125;,&#123;&quot;name&quot;:&quot;Rose&quot;,&quot;age&quot;:21&#125;,&#123;&quot;name&quot;:&quot;Tim&quot;,&quot;age&quot;:24&#125;]&gt;&lt;#list seq1?sort_by(&quot;age&quot;) as u&gt; &lt;#--以age对哈希seq1进行排序并遍历--&gt;$&#123;u.name&#125;+&quot;,&quot;+$&#123;u.age&#125;&lt;/#list&gt;&lt;#assign users=&#123;&quot;name&quot;:&quot;Tim&quot;,&quot;age&quot;:24&#125;&gt;&lt;#list users?keys as key&gt; &lt;#--获取到哈希users所有的键--&gt;$&#123;key&#125;&lt;/#list&gt; 3.7.4 自定义函数123456789101112131415161718&lt;#function add num1 num2&gt; &lt;#return num1+num2&gt;&lt;/#function&gt;&lt;#function addAll nums...&gt; &lt;#local total=0&gt; &lt;#list nums as num&gt; &lt;#local total=total+num&gt; &lt;/#list&gt; &lt;#return total&gt;&lt;/#function&gt;&lt;#--使用function指令定义函数add，有两个参数num1和num2，使用return返回计算之后的结果，使用$&#123;add(1,3)&#125;调用函数 --&gt;$&#123;add(1,3)&#125;&lt;#--使用function指令定义函数addAll，参数个数不固定，定义局部变量total来存储临时计算的结果，遍历所有的参数并进行运算，使用return返回计算之后的结果，使用$&#123;addAll(1,2,3,4,5)&#125;调用函数 --&gt;$&#123;addAll(1,2,3,4,5)&#125; 4.数据模型4.1数据类型使用基本数据类型来派生数字类型使用java.lang.String来构建字符串。使用java.lang.Number来派生数字类型。使用java.lang.Boolean来构建布尔值。使用java.util.List，java.util.Set或Java数组来构建序列。使用java.util.Map来构建哈希表。123456789101112131415161718192021222324Map root=new HashMap();root.put(&quot;d1&quot;, 100);root.put(&quot;d2&quot;, 100.99);root.put(&quot;d3&quot;, &apos;a&apos;);root.put(&quot;d4&quot;, true);root.put(&quot;d5&quot;, new Integer(200));root.put(&quot;d6&quot;, new Boolean(false));List&lt;String&gt; names= Arrays.asList(&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;);root.put(&quot;d7&quot;, names);Set&lt;String&gt; names1=new HashSet&lt;&gt;();names1.add(&quot;ABC&quot;);names1.add(&quot;DEF&quot;);names1.add(&quot;GHI&quot;);root.put(&quot;d8&quot;, names1);root.put(&quot;d9&quot;, new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);Map map=new HashMap();map.put(&quot;name&quot;, &quot;Java开发日记&quot;);map.put(&quot;age&quot;, 18);root.put(&quot;map&quot;, map); 就是java中常见的整型，浮点型，布尔型，字符，数组，list，set，map，不再多说 4.2 加载模板使用Configuration的方法加载模版：1,void setDirectoryForTemplateLoading(File dir);2,void setClassForTemplateLoading(Class cl, String prefix);3,void setServletContextForTemplateLoading(Object servletContext, String path);加载多个位置的模版：1,FileTemplateLoader2,ClassTemplateLoader3,TemplateLoader4,MultiTemplateLoader5,setTemplateLoader(MultiTemplateLoader mtl);123456789101112Configuration cfg = new Configuration(Configuration.VERSION_2_3_22);//cfg.setClassForTemplateLoading(TemplateLoad.class, &quot;../../../ftl&quot;);FileTemplateLoader ftl1=new FileTemplateLoader(new File(&quot;src/ftl&quot;));FileTemplateLoader ftl2=new FileTemplateLoader(new File(&quot;src/ftl2&quot;));ClassTemplateLoader ctl=new ClassTemplateLoader(TemplateLoad.class, &quot;../../../ftl3&quot;);TemplateLoader[] loaders=&#123;ctl,ftl2&#125;;MultiTemplateLoader mtl=new MultiTemplateLoader(loaders);cfg.setTemplateLoader(mtl);Template template=cfg.getTemplate(&quot;ftl2.ftl&quot;);System.out.println(template); javase项目中使用setDirectoryForTemplateLoading来加载模板所在文件夹，javaee项目中使用setClassForTemplateLoading路径，servlet中可以使用setServletContextForTemplateLoading来加载模板路径。 4.3其它配置配置就是在对象中存储常用的设置和定义某些想在所有模板中可用的变量，配置对象是freemarker.template.Configuration的实例，可以通过构造方法来创建它。而且一个应用程序通常只使用一个共享的Configuration实例。 设置共享变量：setSharedVariable() 国家地区：setLocale(); 数字格式：setNumberFormat(“0.##”); 通用设置：setSetting(String name, String value)方法 缓存：设置缓存：setCacheStorage(new freemarker.cache.MruCacheStorage(20, 250))或setSetting(Configuration.CACHE_STORAGE_KEY, “strong:20, soft:250”); 清空缓存：clearTemplateCache 123456789101112Configuration cfg=new Configuration(Configuration.VERSION_2_3_22); cfg.setDirectoryForTemplateLoading(new File(&quot;src/ftl&quot;)); //设置共享便令 cfg.setSharedVariable(&quot;site&quot;, &quot;Java开发日记&quot;); //设置小数点后保留两位 cfg.setNumberFormat(&quot;0.##&quot;);、 //设置缓存，一级缓存20个，2级缓存250个 cfg. setCacheStorage(new freemarker.cache.MruCacheStorage(20, 250)); //cfg.setSetting(Configuration.CACHE_STORAGE_KEY, &quot;strong:20, soft:250&quot;); //cfg.clearTemplateCache(); //清楚缓存 Template template = cfg.getTemplate(&quot;config.ftl&quot;); Writer writer = new FileWriter(new File(&quot;src/finish/config.html&quot;)); 总结：上面这些就是FreeMarker模板引擎的基本操作，首先需要进入jar包，之后设置模板所在的路径并引入模板，然后组装数据（实际操作中通过jdbc连接数据库来操作），所以主要学的就两方面内容：模板和数据，而模板又与这许许多多的指令相关，所以必须要掌握这些指令。]]></content>
      <categories>
        <category>后台—模板引擎</category>
      </categories>
      <tags>
        <tag>模板引擎</tag>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5学习笔记]]></title>
    <url>%2F2017%2F12%2F14%2Fhtml5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.应用程序标签 DataList(数据列表) Progress(进度条) Meter(数值显示器)示例:1234567891011121314151617181920212223&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;应用程序标签&lt;/title&gt; &lt;style&gt; .my-progress&#123; -webkit-appearance: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--数据列表，呈现需要载体--&gt;&lt;input type=&quot;text&quot; list=&quot;data-list&quot;&gt;&lt;datalist id=&quot;data-list&quot;&gt; &lt;option value=&quot;张三&quot;&gt;&lt;/option&gt; &lt;option value=&quot;李四&quot;&gt;&lt;/option&gt;&lt;/datalist&gt;&lt;!--进度条--&gt;&lt;progress&gt;&lt;/progress&gt;&lt;!--progress默认最大值是1，可以设定自己想要的值--&gt;&lt;progress class=&quot;my-progress&quot; value=&quot;30&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;meter min=&quot;0&quot; max=&quot;100&quot; low=&quot;40&quot; high=&quot;90&quot; optimum=&quot;100&quot; value=&quot;91&quot;&gt;A+&lt;/meter&gt;&lt;/body&gt; 可以利用数据列表（data-list）做一个那种带下拉框的输入框，可以根据用户输入的内容匹配下拉框的内容（select2也可以实现这种需求，而且最低可以兼容到IE8，推荐用select2）,后面的progress和meter样式不好控制，用的不太多。 2.自定义属性（data-*）在html5中可以自定义数据，以data开头，利用这个自定义标签我们可以把属性暂时存储到页面中，在js中可以使用，例子如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;data属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; // 键是ID 值是信息 var data = &#123; 01: &#123; name: &quot;张三1&quot;, age: 18 &#125;, 02: &#123; name: &quot;张三2&quot;, age: 19 &#125;, 03: &#123; name: &quot;张三3&quot;, age: 20 &#125; &#125;; var list = document.getElementById(&quot;list&quot;); for(var id in data)&#123; var item = data[id]; var liem = document.createElement(&quot;li&quot;); liem.innerHTML = item.name; //自定义data-*属性 liem.setAttribute(&quot;data-name&quot;,item.name); liem.setAttribute(&quot;data-age&quot;,item.age); list.appendChild(liem); //点击获取dataset属性 liem.addEventListener(&quot;click&quot;,function()&#123; //下面这两种方式均可以，都不带data- alert(this.dataset[&apos;name&apos;]); alert(this.dataset.name); &#125;) &#125;&lt;/script&gt; 下面这篇文章总结的很好，可以参考：http://blog.csdn.net/qq_31851435/article/details/53100691 3.新的表单提交方式传统的一共有9中表单提交方式，html5新增了几种，目前只用在移动端，pc端兼容性有问题，而且在输入的时候并没有进行验证，比如类型是email的，并没有校验邮箱格式，还是需要我们自己手动写正则表达式验证的，只是在手机端当唤起输入法的时候会自动切换到英文输入法。12345678910111213141516171819202122232425&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;新的表单提交方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;传统的表单提交方式（9种）&lt;/h3&gt;用户名：&lt;input type=&quot;text&quot;&gt; &lt;br&gt;密码：&lt;input type=&quot;password&quot;&gt;&lt;br&gt;性别：&lt;input type=&quot;radio&quot;&gt;&lt;br&gt;课程:&lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt;隐藏：&lt;input type=&quot;hidden&quot;&gt;文件：&lt;input type=&quot;file&quot;&gt;&lt;br&gt;按钮：&lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt;&lt;br&gt;表单:&lt;input type=&quot;submit&quot;&gt;&lt;br&gt;重置：&lt;input type=&quot;reset&quot;&gt;&lt;br&gt;&lt;hr&gt;&lt;h3&gt;新的表单提交方式（目前只用在移动端）&lt;/h3&gt;颜色：&lt;input type=&quot;color&quot;&gt;&lt;br&gt;网址：&lt;input type=&quot;url&quot;&gt;&lt;br&gt;搜索：&lt;input type=&quot;search&quot; results=&quot;10&quot; placeholder=&quot;Search...&quot;&gt;&lt;br&gt;邮箱：&lt;input type=&quot;email&quot; pattern=&quot;^\*.com&quot;&gt;&lt;br&gt;日期：&lt;input type=&quot;date&quot; min=&quot;2015-09-01&quot; max=&quot;2018-09-01&quot;&gt;&lt;br&gt;图片：&lt;input type=&quot;image&quot;&gt;&lt;br&gt;范围：&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;50&quot; value=&quot;10&quot;&gt;&lt;br&gt;数字：&lt;input type=&quot;number&quot;&gt;&lt;/body&gt; 4.新的选择器html5提供新的选择器，querySelector选择单个的元素，返回满足条件的第一个元素，是一个dom元素，querySelectorAll选择全部的元素，返回满足条件的全部元素，是一个dom数组，里面可以是id，标签或class类。1234567891011121314151617181920212223242526272829303132333435&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;新选择器&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;新选择器&lt;/h3&gt;&lt;ul&gt; &lt;li class=&quot;item&quot;&gt;item1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item3&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item4&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item5&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item6&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item7&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item8&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item9&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item10&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;script&gt; //匿名函数，可以将作用域分隔开 (function()&#123; var liem = document.querySelector(&quot;.item&quot;); //只选择第一个 console.log(liem.innerHTML); var lis = document.querySelectorAll(&quot;ul&gt;li&quot;); //选择全部 for(var i=0;i&lt;lis.length;i++)&#123; console.log(lis[i]); lis[i].addEventListener(&quot;click&quot;,function()&#123; debugger; //可以调试代码。类似于浏览器打断点 console.log(this.innerHTML); &#125;) &#125; &#125;)()&lt;/script&gt; 5.元素类列表（Element.classList）新H5中DOM对象多了一个classList属性，是一个数组: add 添加一个新的类名 remove 删除一个类名 contains 判断是否包含一个指定的类名 toggle 切换一个类名。 element.toggle(‘class-name’,[add_or_remove])，第一个参数是类名，第二个参数是布尔值，如果是true，则添加类名，如果是false,则去掉类名。示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;元素类列表&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;collapse navbar-collapse&quot;&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; //匿名函数 (function()&#123; /** 点击时添加和删除类名**/ var lis = document.querySelectorAll(&quot;.nav li&quot;); for(var i=0;i&lt;lis.length;i++)&#123; lis[i].addEventListener(&quot;click&quot;,function(e)&#123; //去掉原先所有的样式 for(var j=0;j&lt;lis.length;j++)&#123; lis[j].classList.remove(&quot;active&quot;); &#125; //添加点击样式 this.classList.add(&quot;active&quot;); e.preventDefault(); //取消事件的默认操作 &#125;) &#125; /** 点击时存在类名则删除，不存在类名则添加**/ var elem = document.querySelector(&quot;.navbar-brand&quot;); //点击时如果存在active这个属性则去掉，如果不存在这个属性则加上 elem.addEventListener(&quot;click&quot;,function(e)&#123; //判断是否包含active这个类名 var isExist = elem.classList.contains(&quot;active&quot;); this.classList.toggle(&quot;active&quot;,!isExist); e.preventDefault(); &#125;) &#125;)()&lt;/script&gt;&lt;/body&gt; 6.访问历史Api在HTML5中可以通过window.history操作访问历史状态，让一个页面可以有多个历史状态 window.history.forward(); // 前进 window.history.back(); // 后退 window.history.go(); // 刷新 history.pushState(放入历史中的状态数据, 设置title(现在浏览器不支持)， 改变历史状态)，通过JS可以加入一个访问状态123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;历史记录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;测试历史记录&quot; onclick=&quot;addHistory()&quot;&gt;&lt;/body&gt;&lt;script&gt; //添加历史记录 function addHistory()&#123; //判断浏览器是否支持历史记录，毕竟是h5的新特性，低版本浏览器不支持 if(window.history &amp;&amp; history.pushState)&#123; //支持 history.pushState(new Date().toLocaleDateString(),&quot;设置历史记录的标签，但是目前浏览器还不支持&quot;,&quot;?demo=&quot;+new Date().toLocaleTimeString()); &#125;else&#123; console.log(&quot;抱歉，浏览器不支持历史记录&quot;) &#125; &#125; //下面这个事件是点击浏览器中的前进或后退时触发 window.addEventListener(&quot;popstate&quot;,function(e)&#123; console.log(&quot;点击了历史按钮&quot;+e.state); &#125;)&lt;/script&gt; 7.全屏ApiH5中可以用requestFullScreen()方法实现指定元素的全屏显示（类似于浏览器中按F11）。首先需要获取需要全屏显示的元素，然后判断浏览器是属于谷歌内核还是火狐内核或者其它浏览器，然后调用响应方法即可。(注意：目前这个特性浏览器兼容性还比较差，谷歌和火狐可以)12345678var elem = 需要全屏的元素;if (elem.webkitRequestFullScreen) &#123; elem.webkitRequestFullScreen();&#125; else if (elem.mozRequestFullScreen) &#123; elem.mozRequestFullScreen();&#125; else if (elem.requestFullScreen)&#123; elem.requestFullScreen();&#125; 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;全屏显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 style=&quot;cursor: pointer&quot;&gt;点我全屏显示&lt;/h3&gt;&lt;p&gt;测试全屏显示测试全屏显示测试全屏显示测试全屏显示测试全屏显示测试全屏显示 测试全屏显示测试全屏显示测试&lt;br&gt; 全屏显示测试全屏显示测试全屏显示测试全屏显示测试全屏显示&lt;/p&gt;&lt;script&gt; //匿名函数 (function () &#123; //获取事件源和要全屏显示的元素 var elem = document.querySelector(&quot;p&quot;); document.querySelector(&quot;h3&quot;).addEventListener(&quot;click&quot;,function(e)&#123; //判断浏览器是否支持全屏显示 if (elem.webkitRequestFullScreen) &#123; elem.webkitRequestFullScreen(); &#125; else if (elem.mozRequestFullScreen) &#123; elem.mozRequestFullScreen(); &#125; else if (elem.requestFullScreen)&#123; elem.requestFullScreen(); &#125;else&#123; console.log(&quot;浏览器不支持全屏显示&quot;) &#125; &#125;); &#125;)()&lt;/script&gt;&lt;/body&gt; 8.Application Cache离线访问技术在H5中可以利用Application Cache实现离线访问技术，测试时可以通过谷歌浏览器——NetWork——No throttling(Disable cache后面的那个下拉框)——下拉选择Offline(模拟未联网的情形)。示例如下：1234567891011121314151617181920212223242526272829303132html代码：&lt;html lang=&quot;en&quot; manifest=&quot;cache.manifest&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;离线访问&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是html页面中的内容&lt;/p&gt;&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;style.css文件代码body::before&#123; content: &quot;这是Css中引入的内容&quot;; font-size: 40px;&#125;script.js文件代码：document.write(&quot;这是js中引入的内容&quot;)cache.manifest文件代码：CACHE MANIFEST# version 1.0.1CACHE: 08离线访问.html script.js style.cssNETWORK: * 解释：在html代码中通过css的伪类和js的document.write函数分别输出两句话，模拟请求其它文件，然后在manifest（缓存清单）中定义了一个cache.manifest的缓存清单文件，文件里首先定义了当前软件的版本，下面的CACHE，代表断网情况下，从下面定义的文件中读取文件，NETWORK代表联网时候要读取的文件，星号代表全部。即断网时从我定义的文件中读取文件，联网时，读取全部文件，这样便可实现离线访问。 9.web网页存储h5中提供sessionStorage和localStorage两种数据存储方式，前者存储的内容只在本次会话中存储，浏览器关闭数据消失，后者是可以永久存储在浏览器中，除非手动或通过程序删除。这两种存储方式比cookie存储的数据量大，而且可以存储对象数据（cookie只能存储字符串数据）。12345678910111213141516171819202122232425262728293031323334&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;网页存储&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea rows=&quot;5&quot; cols=&quot;30&quot; id=&quot;txt-data&quot;&gt;&lt;/textarea&gt;&lt;input type=&quot;button&quot; value=&quot;设置数据&quot; id=&quot;set-data&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;获取数据&quot; id=&quot;get-data&quot;&gt;&lt;script&gt; (function()&#123; var txtValue = document.querySelector(&quot;#txt-data&quot;); console.log(txtValue.value); //设置数据 document.querySelector(&quot;#set-data&quot;).addEventListener(&quot;click&quot;,function (e) &#123; //判断是否支持存储 if(window.sessionStorage)&#123; sessionStorage.setItem(&quot;key&quot;,txtValue.value); &#125;else&#123; console.log(&quot;还在用渣渣IE吗？升级吧。。。&quot;) &#125; &#125;) //获取数据 document.querySelector(&quot;#get-data&quot;).addEventListener(&quot;click&quot;,function (e) &#123; //判断是否支持存储 if(window.sessionStorage)&#123; txtValue.value = sessionStorage.getItem(&quot;key&quot;); &#125;else&#123; console.log(&quot;还在用渣渣IE吗？升级吧。。。&quot;) &#125; &#125;) &#125;)()&lt;/script&gt;&lt;/body&gt; 10.操作文件Api通过file表单选择文件，之后利用h5提供的文件api可以获取文件名，大小，类型，最后修改时间等文件信息。123456789101112131415161718192021222324252627282930313233343536373839404142&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;操作文件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;form&gt; &lt;input type=&quot;file&quot; class=&quot;form-control hidden&quot; id=&quot;btn_file&quot; multiple&gt; &lt;input type=&quot;button&quot; value=&quot;选择文件&quot; class=&quot;btn btn-success&quot; id=&quot;btn_select&quot;&gt; &lt;div class=&quot;list-group&quot; id=&quot;ul_list&quot;&gt; &lt;!--待追加数据位置--&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; (function()&#123; var btn_file = document.querySelector(&quot;#btn_file&quot;); var btn_select = document.querySelector(&quot;#btn_select&quot;); var ul_list = document.querySelector(&quot;#ul_list&quot;); //利用“hidden”类将文件输入框隐藏，当点击“选择文件按钮时”，调用选择文件按钮，选择文件， // 因为input type=&quot;file&quot;这个无法修改样式，把它隐藏，点击其它按钮时，在其它按钮中调用点击上传文件 btn_select.addEventListener(&quot;click&quot;,function()&#123; btn_file.click(); &#125;) //选择文件完成后（即文件内容发生改变后） btn_file.addEventListener(&quot;change&quot;,function(e)&#123; var files = btn_file.files; //获取所有文件，并遍历 for(var i=0;i&lt;files.length;i++)&#123; console.log(files[i]); var liem = document.createElement(&quot;li&quot;); liem.setAttribute(&quot;class&quot;,&quot;list-group-item&quot;); liem.innerHTML = &apos; &lt;h4 class=&quot;list-group-item-heading&quot;&gt;&apos;+files[i].name+&apos;&lt;/h4&gt;&apos;+ &apos;&lt;p class=&quot;list-group-item-text&quot;&gt;&apos;+files[i].lastModifiedDate.toLocaleTimeString()+&apos; &apos;+(files[i].size/1024).toFixed(2)+&apos;kb&lt;/p&gt;&apos; ul_list.appendChild(liem); &#125; &#125;) &#125;)()&lt;/script&gt; 这里是用到了bootstrap的样式，因为file表单比较丑，而且无法改变样式，所以我们可以把文件表单隐藏（用hidden隐藏样式），提供一个按钮，当点击这个按钮时去雕砌选文件的弹框，multiple属性支持一次选择多个文件。 11.拖拽文件拖拽文件时需要依次注册以下事件： dragenter 注册拖拽进入事件 dragleave 注册拖拽离开事件 dragover 注册滑动事件（在这里面阻止默认事件） drop 注册松手落地事件。在拖动松手落地事件中判断拖进来的是文件还是图片地址还是文字，分别进行处理。e.dataTransfer获取拖动进来的信息。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;拖拽文件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.css&quot;&gt; &lt;style&gt; #target&#123; height: 200px; border: 5px dashed #c0c0c0; color: #505050; padding: 20px; font-size: 40px; cursor: pointer; text-align: center; -webkit-user-select: none; &#125; #target.actived&#123; border-color: #888; color: #080808; box-shadow: 0 0 80px #e0e0e0 inset; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h3&gt;拖拽文件&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;p&gt;我们这里测试拖拽文件&lt;/p&gt; &lt;img src=&quot;test.png&quot;&gt; &lt;/div&gt; &lt;div id=&quot;target&quot;&gt; 拖拽文件进来 &lt;ul id=&quot;result&quot; class=&quot;list-group&quot;&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; (function()&#123; var target = document.querySelector(&quot;#target&quot;); var fileList = document.querySelector(&apos;#result&apos;); //注册拖拽进入事件 target.addEventListener(&quot;dragenter&quot;,function()&#123; this.classList.add(&quot;actived&quot;); //添加样式 &#125;) //注册拖拽文件离开事件 target.addEventListener(&quot;dragleave&quot;,function()&#123; this.classList.remove(&quot;actived&quot;); //添加样式 &#125;) //注册落地事件之前必须要先阻止默认事件，这里在滑动里面阻止默认事件 target.addEventListener(&quot;dragover&quot;,function(e)&#123; e.preventDefault(); //阻止默认事件 e.stopPropagation(); &#125;) //注册松手落地事件 target.addEventListener(&quot;drop&quot;,function(e)&#123; //判断拖入进来的是文件，图片还是文字，分别处理 if(e.dataTransfer.files.length)&#123; //拖入的是文件 var files = e.dataTransfer.files; for (var i = 0; i &lt; files.length; i++) &#123; var li = document.createElement(&apos;li&apos;); li.setAttribute(&apos;class&apos;, &apos;list-group-item&apos;); // 创建信息的子节点 li.innerHTML = &apos;&lt;h5 class=&quot;list-group-item-heading&quot;&gt;&apos; + files[i].name + &apos;&lt;/h5&gt;&lt;p class=&quot;list-group-item-text&quot;&gt;&apos; + files[i].lastModifiedDate.toLocaleDateString() + &apos; &apos; + files[i].lastModifiedDate.toLocaleTimeString() + &apos; &apos; + (files[i].size / 1024).toFixed(2) + &apos;KB&lt;/p&gt;&apos;; fileList.appendChild(li); &#125; &#125;else&#123; //不是文件 var data = e.dataTransfer.getData(&apos;text/plain&apos;); //判断拖入的是文本还是图片 if(data)&#123; //拖入的是文本,直接置换 target.innerHTML = data; &#125;else&#123; //拖入的是图片 var imgElem = document.createElement(&quot;img&quot;); imgElem.src = data; target.appendChild(imgElem); &#125; &#125; &#125;) &#125;)()&lt;/script&gt; 12.访问设备信息h5提供了许多可以访问设备的Api，但是目前基本都应用在手机端，pc端使用非常有限。 获取网络状态。 12345678// × 所有PC浏览器现在都不支持 只有手机端的Firefoxvar connectionInfo = navigator.connection;或者下面这个方法：if (navigator.onLine)&#123; console.log(&apos;online&apos;);&#125;else&#123; console.log(&apos;offline&apos;);&#125; 获取重力感应方向 12345window.addEventListener(&apos;deviceorientation&apos;, function(event) &#123; var a = event.alpha; // Y轴 上下方向 var b = event.beta; // Z轴 东西方向 var g = event.gamma; // X轴 南北方向&#125;); 加速度计 1234window.addEventListener(&apos;devicemotion&apos;, function(e) &#123; // 获取加速计数据 &#123;x,y,z&#125; var acceleration = e.accelerationIncludingGravity;&#125;); 地理坐标 1234567navigator.geolocation.getCurrentPosition(function(e) &#123; // e.coords.longitude : 经度, e.coords.latitude : 纬度 document.querySelector(&apos;#result&apos;).innerHTML = JSON.stringify(e.coords);&#125;, function(e) &#123; document.querySelector(&apos;#result&apos;).innerHTML = JSON.stringify(e);&#125;);navigator.geolocation.watchPosition(success, error); H5还有其它的一些特性，包括语义化标签，ARIA无障碍互联网应用，多媒体（包括音频，视频）等等，真正使用的时候再详细研究。]]></content>
      <categories>
        <category>前端—html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门—js第五天]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E2%80%94js%E7%AC%AC%E4%BA%94%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[0.操作节点复习上一节的节点操作，append添加子节点，而且子节点在最后一个位置，cloneNode()，克隆节点，括号里面可以加参数，如果是true则是深克隆（克隆当前节点及其子节点），如果是false则是浅克隆，只可能当前选中的节点；parentNode父节点，给我的父节点增加子节点其实相当于给我增加了一个兄弟节。window.onload是入口函数,代表页面加载完毕之后执行（一个页面只能有一个window.onload，因为即使有多个，后面的也会覆盖前面的，导致前面的不生效）。需要注意的是添加元素时我们有时候使用append(),有时候使用appendChild()，他们两个是有点区别的，前者是jq里的写法，后者是js里的写法。1234567891011121314151617181920212223&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01节点操作&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; var demo = document.getElementById(&quot;demo&quot;); var btn = document.getElementsByTagName(&quot;button&quot;)[0]; btn.onclick = function()&#123; //创建标签 var newLi = document.createElement(&quot;li&quot;); newLi.innerHTML = &quot;测试创建节点&quot; demo.appendChild(newLi); demo.parentNode.appendChild(demo.cloneNode(true)); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;点击&lt;/button&gt;&lt;ul id=&quot;demo&quot;&gt;&lt;/ul&gt;&lt;/body&gt; 1.操作属性节点的属性操作中我们常用的是获取属性，设置属性，删除属性，分别使用以下方法： getAttribute(“属性名”) 根据属性名获取属性值 setAttribute(“属性名”,”属性值”) 给节点的某个属性设置属性值 removeAttribute(“属性名”) 删除节点的某个属性123456789&lt;body&gt;&lt;div id=&quot;demo&quot; class=&quot;test&quot; title=&quot;测试&quot;&gt;测试&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var demo = document.getElementById(&quot;demo&quot;); console.log(demo.getAttribute(&quot;class&quot;));//获取属性 demo.setAttribute(&quot;class&quot;,&quot;show&quot;); //设置节点 demo.removeAttribute(&quot;title&quot;); //删除节点&lt;/script&gt; 写的还有另外一个动态生成小圆点的示例，不再这里贴代码了，感兴趣的可以到文末代码地址中看。需要指出一点的是，我们好多时候写前端，都是先把基本的样式写好，某些需要动态生成，或通过后台取数据的再抽取出来，放在js里面，不要一上来就把想着全写出来，可能会有点吃力。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04发微博&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; ul&#123; list-style-type: none; &#125; .box&#123; width: 600px; margin: 100px auto; border:1px solid #ccc; padding: 20px; height: auto; &#125; textarea&#123; width: 450px; resize: none; /*固定使其不可拖拉*/ &#125; .box li&#123; line-height: 30px; border-bottom: 1px dashed #ccc; padding-left: 80px; width: 450px; &#125; .box ul a&#123; float: right; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var btn = document.getElementsByTagName(&quot;button&quot;)[0]; var txt = document.getElementsByTagName(&quot;textarea&quot;)[0]; //创建ul并追加 var ulEle = document.createElement(&quot;ul&quot;); btn.parentNode.appendChild(ulEle); btn.onclick = function()&#123; if(txt.value==&quot;&quot;)&#123; alert(&quot;内容不能为空&quot;); return; //停止代码执行 &#125; //创建li var liEle = document.createElement(&quot;li&quot;); liEle.innerHTML = txt.value+&quot;&lt;a href =&apos;javascript:;&apos;&gt;删除&lt;/a&gt;&quot;; txt.value=&quot;&quot;; //清空 //判断有无li，把新添加的li放在最前面 var lis = ulEle.children; if(lis.length==0)&#123; ulEle.appendChild(liEle) &#125;else&#123; ulEle.insertBefore(liEle,lis[0]); &#125; //点击删除按钮时进行删除 var as = document.getElementsByTagName(&quot;ul&quot;)[0].getElementsByTagName(&quot;a&quot;); for(var i=0;i&lt;as.length;i++)&#123; as[i].onclick = function()&#123; ulEle.removeChild(this.parentNode); //从ul中移除当前的li &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; 微博发布：&lt;textarea id=&quot;&quot; name=&quot;&quot; cols=&quot;40&quot; rows=&quot;10&quot; &gt;&lt;/textarea&gt;&lt;button&gt;发布&lt;/button&gt; &lt;!--&lt;ul&gt;--&gt; &lt;!--&lt;li&gt;合法你考虑到发交话费拉克丝发挥到了开始&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/li&gt;--&gt; &lt;!--&lt;/ul&gt;--&gt;&lt;/div&gt;&lt;/body&gt; resize: none可以设置textarea不可拖拉，textarea这里是双标签，有开始标签和结束标签，不能写成单标签，而且上面这个我就是先把样式写好，再把ul注释掉从js中动态生成的。 2.日期函数Date是js中的内置对象，使用它可以创建日期，获取当前的时间。var date = new Date(); 可以创建一个日期对象。12345678var date = new Date();console.log(date); //Wed Aug 30 2017 13:26:51 GMT+0800 (中国标准时间)console.log(date.getTime()); //1504070843457 从1970年至现在的毫秒数console.log(date.valueOf()); //1504070843457 跟上面的一样，但是没有上面的常用//直接使用的console.log(Date.now()); //1504070966613console.log(+new Date()); //1504070966613console.log(typeof (+&quot;123456&quot;)); //number js中，在某个值前使用”+”可以将这个变量转换成Number类型，如果转换失败，将得到NaN。所以上面的+new Date()跟其它值一样。 3.1日期函数常用方法日期函数中常用的方法如下： 方法 作用 getFullYear() 获取年（所有浏览器均支持） getYear() 获取年（从ECMAscriptv3开始停止使用了） 所以慎用！ getMonth() 获取月0-11 getDate() 获取日1-31 getDay() 获取星期0-6（跟上面获取日的要分清） getHours() 获取小时 （获取时分秒单词需要用复数） getMinutes() 获取分钟 getSeconds() 获取秒 getMilliseconds() 获取毫秒 getTime() 获取从1970年至今的累计毫秒数 12345678910111213&lt;script&gt; var date = new Date(); console.log(date.getFullYear()); //2017 console.log(date.getYear()); //117 console.log(date.getMonth()); //7 console.log(date.getDate()); //30 console.log(date.getDay()) //3 console.log(date.getHours()) //14 console.log(date.getMinutes()) //5 console.log(date.getSeconds()) //16 console.log(date.getMilliseconds()) //728&lt;/script&gt; 下面这一个是根据日历函数生成一个日历，其中定义一个数组来装星期的思路不错。123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06日历&lt;/title&gt; &lt;style&gt; .box&#123; width: 150px; height: 180px; margin: 100px auto; background-color: #336699; text-align: center; &#125; .box p&#123; line-height: 60px; color: #FFFFFF; font-size: 12px; &#125; .box span&#123; display: block; width: 75px; height: 75px; background-color:#9ACD32 ; margin: 0 auto; line-height: 75px; font-size: 50px; color: #000000; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var box = document.getElementById(&quot;box&quot;); var arr = [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;]; var childrens = box.children; var date = new Date(); childrens[0].innerHTML = date.getFullYear()+&quot;年&quot;+(date.getMonth()+1)+&quot;月&quot;+date.getDate()+&quot;日&quot;+ arr[date.getDay()]; childrens[1].innerHTML = date.getDate(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot; id=&quot;box&quot;&gt; &lt;p&gt;432431&lt;/p&gt; &lt;span&gt;3&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; 3.2自定义时间有时我们自己需要自己指定时间，那么在创建时间时传一个时间参数即可12var date = new Date(&quot;2016/09/11&quot;);console.log(date.getFullYear()); 所以new Date()里面如果有参数，生成指定日期，如果没有参数，生成当前日期。 4.定时器通过设定定时器可以让某个函数或动作持续的执行下去，定时器通过setInterval()函数来设定。window.setInterval(“函数名”,”时间间隔”)；每隔指定的时间间隔去执行函数。下面这几种写法都是可以的： window.setInterval(fun,1000); 其中fun是已经定义好的函数名 window.setInterval(function(){//函数体},1000);下面这两种会报错 window.setInterval(fun(),1000); window.setInterval(“fun()”,1000);网上有说这种方式也可以的，但是我试了试不行（不知道是不是姿势不对）1234567891011&lt;script&gt; window.onload = function ()&#123; var demo = document.getElementById(&quot;demo&quot;); var num=1; function myInterval()&#123; num++; demo.innerHTML = num; &#125; window.setInterval(myInterval,1000); &#125;&lt;/script&gt; 下面的例子是一个活动的倒计时，定时器每秒执行一次，根据截至时间和当前时间算出中间相隔的毫秒数(getTime()获取1970年到指定时间的毫秒数)，再利用毫秒数计算运算转换。12345678910111213141516171819202122232425262728293031323334353637 &lt;style&gt; span&#123; display: block; font-size: 30px; color: red; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var endTime = new Date(&quot;2017-08-31 24:00:00&quot;); var spanEle = document.getElementsByTagName(&quot;span&quot;)[0]; setInterval(clock,1000); //开启定时器，每秒执行一次 function clock()&#123; var startTime = new Date(); var minSecond = endTime.getTime()-startTime.getTime(); //得到距离截止时间还有多少毫秒 var second = parseInt(minSecond/1000); //得到秒数 var d = parseInt(second/24/3600); //得到天数 var h = parseInt(second/3600%24); //得到小时 var m = parseInt(second/60%60); //得到分钟 var s = parseInt(second%60); //得到秒数 d&lt;10?d=&quot;0&quot;+d:d; h&lt;10?h=&quot;0&quot;+h:h; m&lt;10?m=&quot;0&quot;+m:m; s&lt;10?s=&quot;0&quot;+s:s; spanEle.innerHTML = &quot;距离活动结束还有&quot;+d+&quot;天&quot;+h+&quot;小时&quot;+m+&quot;分钟&quot;+s+&quot;秒&quot;; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;span&gt; 5634298 &lt;/span&gt;&lt;/div&gt;&lt;/body&gt; 代码地址：https://git.oschina.net/catchu/web-study]]></content>
      <categories>
        <category>前端—javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门—js第四天]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E2%80%94js%E7%AC%AC%E5%9B%9B%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[0.升级tab栏切换在上一节中写了单一的一个容器里面tab切换的示例，在实际开发中往往都是多个容器里的多个tab互相切换，例如淘宝首页的几楼都是这样，本节先升级一下上节的示例，鼠标滑过时选中tab，如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01tab栏切换升级版&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box&#123; width: 300px; height: 300px; border:1px solid #ccc; margin: 50px auto; overflow: hidden; &#125; ul&#123; list-style-type: none; &#125; .top span&#123; display: inline-block; background-color: pink; width: 70px; height: 30px; line-height: 30px; text-align: center; cursor:pointer; &#125; .top span.current&#123; background-color: purple; &#125; .bottom li&#123; width: 100%; height: 270px; background-color: purple; display: none; &#125; .bottom li.show&#123; display: block; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; //获取所有的span和li(这里需要指出的是span和li必须是一一对应的，即个数必须得相等) var spans = document.getElementsByTagName(&quot;span&quot;); var lis = document.getElementsByTagName(&quot;li&quot;); for(var i=0;i&lt;spans.length;i++)&#123; spans[i].index = i; //给span设置index属性，先存下下标,关键 spans[i].onmouseover = function()&#123; //清除所有的li和span的属性（排他思想） for(var j=0;j&lt;spans.length;j++)&#123; spans[j].className=&quot;&quot;; lis[j].className=&quot;&quot;; &#125; //选中点击的span和它对应的li this.className=&quot;current&quot;; lis[this.index].className=&quot;show&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;top&quot;&gt; &lt;span class=&quot;current&quot;&gt;新闻&lt;/span&gt; &lt;span&gt;体育&lt;/span&gt; &lt;span&gt;娱乐&lt;/span&gt; &lt;span&gt;八卦&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt; &lt;ul&gt; &lt;li class=&quot;show&quot;&gt;新闻模块&lt;/li&gt; &lt;li&gt;体育模块&lt;/li&gt; &lt;li&gt;娱乐模块&lt;/li&gt; &lt;li&gt;八卦模块&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;top&quot;&gt; &lt;span class=&quot;current&quot;&gt;新闻&lt;/span&gt; &lt;span&gt;体育&lt;/span&gt; &lt;span&gt;娱乐&lt;/span&gt; &lt;span&gt;八卦&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt; &lt;ul&gt; &lt;li class=&quot;show&quot;&gt;新闻模块&lt;/li&gt; &lt;li&gt;体育模块&lt;/li&gt; &lt;li&gt;娱乐模块&lt;/li&gt; &lt;li&gt;八卦模块&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 1.循环语句js(以及大多数其它语言)都会有for循环，while循环，do while循环。 for循环：for(初始化;条件;增量){ //执行语句} while循环:while(条件){ //执行语句} do while循环:do{ //执行语句} while(条件);由以上可知，do while循环至少会执行一次语句（因为先执行才判断条件是否成立），三个循环不是太难，这里不再举例。2.switch分支语句switch是从多个条件中选择一个匹配的去执行，跟if elseif的作用是一样的，但是效率的话switch更高。1234567891011121314151617181920212223242526272829303132333435363738&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02switch语句&lt;/title&gt; &lt;style&gt; body&#123; background: url(images/chun1.jpg) no-repeat; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var sel = document.getElementById(&quot;sel&quot;); sel.onchange = function()&#123; switch(this.value)&#123; case &quot;1&quot;: document.body.style.backgroundImage = &quot;url(images/chun1.jpg)&quot;; break; case &quot;2&quot;: document.body.style.backgroundImage = &quot;url(images/xia1.jpg)&quot;; break; case &quot;3&quot;: document.body.style.backgroundImage = &quot;url(images/qiu1.jpg)&quot;; break; case &quot;4&quot;: document.body.style.backgroundImage = &quot;url(images/dong1.jpg)&quot;; break; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;select name=&quot;&quot; id=&quot;sel&quot;&gt; &lt;option value=&quot;1&quot;&gt;春意盎然&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;夏日炎炎&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;秋声瑟瑟&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;冬雪皑皑&lt;/option&gt;&lt;/select&gt;&lt;/body&gt; 这里根据不同的下拉选框，换不同的北京图片。onchange可以监听下拉改变事件，当当前选定的值匹配到1,2,3,4是执行对应的case语句，执行完毕之后需要break（字面意思打断）停止当前代码继续向下执行。可以使用backgroundImage属性来修改背景图片，如果是链接用url，路径不要加引号。 3.数组常用方法3.1添加数组元素 push() 从数组后面追加元素使用push()方法可向数组末尾添加一个或多个元素，并返回数组新的长度。例如：var arr = [“张三”,”李四”]; var length = arr.push(“王五”); 则执行结果是length=3，arr=[“张三”,”李四”,”王五”]; unshift() 从数组前面添加元素使用unshift()方法可在数组开头添加一个或多个元素，并返回数组新的长度。例如：var arr = [“张三”,”李四”]; var length = arr.push(“王五”); 则执行结果是length=3，arr=[“王五”,张三”,”李四”]; 3.2删除数组元素 pop() 删除数组最后一个元素，并返回最后一个元素的值如var arr=[1,3,5],var a = arr.pop(),执行完毕a=5,arr=[1,3]; shift() 删除数组第一个元素，并返回第一个元素的值如var arr=[1,3,5],var a = arr.shift(),执行完毕a=1,arr=[3,5];3.3连接数组元素 concat() 连接两个或多个数组使用concat()可以连接两个或多个数组，它不会修改当前的数组，只会返回一个连接后的新的数组var a=[1,2,3]; var b = [‘a’,’b’,’c’]; var c = a.concat(b);连接之后数组a,b都不会改变，c=[1,2,3,’a’,’b’,’c’];3.4把数组中的元素连接成字符串 join() 使用分隔符将数组中的元素连接成字符串使用join(‘分隔符’)函数可将数组中的元素通过分隔符连接成一个字符串，分隔符可以为空，为空时默认分隔符都逗号。如var arr = [1,2,3]; 则var str = arr.join(‘-‘); str的结果就是1-2-3.3.5把字符串分割成数组 split() 使用分隔符将字符串分割成数组。这个其实就是上面方法的逆运算使用split(‘分隔符’,’数组长度’)函数可以将字符串按照分隔符分割成数组，其中分隔符和数组长度都可以省略，分隔符省略时默认是逗号。如：var str = aa-bb-cc; var arr = str.split(“-“); 则arr数组的值为[aa,bb,cc].4.DOM操作js是由ECMAScript(欧洲计算机协会，负责描述了js的基本语法和对象)，DOM(Document Object Model文档对象模型，负责处理网页内容)对象和BOM(Borwser Object Model浏览器对象模型，负责处理与浏览器交互)对象组成。在这里我们主要介绍DOM，DOM为文档提供了结构化的描述，其实就是定义了如何通过脚本来访问文档结构（说白了就是怎么使用js操作html元素）。4.1节点整个html文档是个文档节点；每个html标签是个元素节点；标签中的文字是文字节点；标签的属性是属性节点；在html中一切皆是节点。4.2访问节点getElementById(); 根据id访问节点；getElementsByTagName(); 根据标签名访问节点；getElementsByClassName((); 根据类名访问节点，但是这个方法存在兼容问题，对于IE6/7/8不支持，我们可以封装自己的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03封装class类&lt;/title&gt; &lt;style&gt; div&#123; width: 50px; height: 50px; margin: 10px; background: pink; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; //封装我们自己的根据类名获取元素的方法 function getByClass(classname)&#123; //判断是否支持js原生方法（即区分IE678和其它浏览器） if(document.getElementsByClassName)&#123; return document.getElementsByClassName(classname); &#125; //程序走到这里，说明不支持document.getElementsByClassName方法，获取全部节点，遍历判断 var arr = []; //定义返回数组 var elems = document.getElementsByTagName(&quot;*&quot;); //获取页面所有节点 for(var i=0;i&lt;elems.length;i++)&#123; //获取这个元素的class类，并使用空格分割（比如demo test，不分割单纯的判断会有问题） var classes = elems[i].className.split(&quot; &quot;); for(var j=0;j&lt;classes.length;j++)&#123; if(classes[j]==classname)&#123; //存在此类名，将元素放入数组中 arr.push(elems[i]); &#125; &#125; &#125; return arr; &#125; //调用 var tests = getByClass(&quot;test&quot;); for(var k=0;k&lt;tests.length;k++)&#123; tests[k].style.backgroundColor=&quot;red&quot;; //结果就是两个变红，IE678测试没有问题 &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;demo test&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;test one&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 思路：根据getElementsByClassName判断是高级浏览器还是IE6/7/8,如果是高级浏览器则直接根据此方法返回，如果是IE6/7/8则遍历所有节点，再根据节点，获取节点里面的类，因为一个节点可能有多个类属性，中间是空格（比如demo test），所以再用空格分割，看是否包含这个类名，如果有则把当前节点（不是类名）放入数组中，最后返回。 4.3创建节点使用creatElement()方法可以创建节点。如：var div = document.creatElement(“div”);就生成了一个div标签。 4.4插入节点 appendChild(); 添加子节点（ 字面意思添加孩子），放到盒子最后面。 insertBefore(插入的节点，参照节点) 在参照节点之前插入节点，如果第二个参数不写则在盒子最后添加节点。如：demo.insertBefore(test,childrens[0]); 在第一个孩子元素之前添加节点test。 demo.insertBefore(test,null);在盒子最后添加节点test。4.5删除节点removeChild() 删除孩子节点demo.removeChild(aa); 从demo节点移除孩子节点aa。4.6克隆（复制）节点cloneNode() 复制节点括号里面可以跟参数，如果里面是true，则是深复制，除了复制盒子本身，还复制盒子子节点 ；如果是false则是浅复制，只复制该节点，不复制子节点。12345678910111213141516171819202122&lt;body&gt;&lt;div id=&quot;demo&quot;&gt; &lt;div id=&quot;one&quot;&gt;&lt;/div&gt; &lt;div id=&quot;two&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var demo = document.getElementById(&quot;demo&quot;); var one = document.getElementById(&quot;one&quot;); //创建节点 var three = document.createElement(&quot;div&quot;); //在后面添加节点 demo.appendChild(three); //在前面插入节点 demo.insertBefore(three,null); //删除节点 demo.removeChild(one); //深克隆节点 var cloneNode = demo.cloneNode(true); //克隆完要追加才能看到 demo.parentNode.appendChild(cloneNode);&lt;/script&gt;&lt;/body&gt; 5.布尔类型的真假 数据类型 真假 数字类型 除0之外所有数字均为真，0是假 字符串 所有字符串都是真，’’是假 对象 所有对象均为真，null是假 undefined Undefined类型只有undefined，是假 6.访问关系（重点）js中的访问关系有四种 父节点parentNode 兄弟节点nextSibling、nextElementSlibling、previousSibling、previousElementSibling 子节点firstChild、firstElementChild、lastChild、lastElementChild 所有子节点childNodes、children6.1父节点parentNode获取到的是元素的直接父节点（不包括爷爷），只有一个。1234567891011121314151617181920212223242526272829303132333435363738&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06二维码&lt;/title&gt; &lt;style&gt; .box&#123; width:107px; margin: 100px auto; position: relative; border: 1px solid #cccccc; &#125; #close&#123; width: 14px; height: 14px; font-size: 14px; position: absolute; line-height: 14px; top:0; left:-15px; border: 1px; cursor:pointer; display: block; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var close = document.getElementById(&quot;close&quot;); close.onclick = function()&#123; this.parentNode.style.display = &quot;none&quot;; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;images/taobao.jpg&quot;&gt; &lt;span id=&quot;close&quot;&gt;x&lt;/span&gt;&lt;/div&gt;&lt;/body&gt; 这个例子中当点击叉号时关闭页面，用到了parentNode,布局采用”子绝父相“，点击按钮时，根据当前节点，让它的父节点的display属性改为none即为隐藏。 6.2兄弟节点 nextSibling 下一个兄弟节点(不是所有的兄弟节点，只是当前节点的下一个兄弟)，IE6/7/8使用 nextElementSibling 跟上面意思一样，供高版本浏览器使用的。 previousSibling下一个兄弟节点(不是所有的兄弟节点，只是当前节点的下一个兄弟)，IE6/7/8使用 previousElementSibling 跟上面意思一样，供高版本浏览器使用的。基于以上的特点，我们在平时开发中一般用或(||)连接在一块使用，保证在IE6/7/8和高版本浏览器都是可用的。如：var div = one.nextElementSibling || one.nextSibling; 而且必须是高版本浏览器的在前，IE6/7/8的在后。6.3子节点 firstChild 第一个孩子节点，IE6/7/8使用 firstElementChild 第一个孩子节点，供高版本浏览器使用的。 lastChild 最后一个孩子节点，IE6/7/8使用（IE6/7/8大坑！！） previousElementSibling 最后一个孩子节点，供高版本浏览器使用的。为保证兼容可以这样使用：var div = one.firstElementChild || one.firstChild; 6.4孩子节点 childNodes 选出全部的孩子节点（亲的）。这个是js官方的，但是不太好用，因为在高版本浏览器中，会把换行也当做节点，还需要再根据nodeType判断一次（nodeType =1是元素节点）。 children 选出所有的孩子节点（只有元素）。这个是民间大神弄的，但是更好用，一般使用这个。需要注意一点的是，在IE678中会把注释也当做节点，计算节点个数的时候往往比正常浏览器多，避免的方法就是在要使用的元素代码里面不要写注释（第一次推荐不写注释）。1234567891011121314151617181920212223242526&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;孩子节点&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; var father = document.getElementsByTagName(&quot;ul&quot;)[0]; //如果使用第二种就不用判断了，方便alert(father.children.length); var cs = father.childNodes; for(var i=0;i&lt;cs.length;i++)&#123; if(cs[i].nodeType==1)&#123; //不加nodeType判断，在高版本浏览器会报错 cs[i].style.backgroundColor = &quot;pink&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;123&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; 代码地址：https://git.oschina.net/catchu/web-study]]></content>
      <categories>
        <category>前端—javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门—js第三天]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E2%80%94js%E7%AC%AC%E4%B8%89%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1.输入事件对于正常的浏览器oninput即可监听输入事件，但是对于IE6、7、8则需要使用onpropertychange来监听。之前我做过一个简单的@事件，就是这样使用的，当监听到输入框中输入@时，就弹出我关注人的列表。下面举例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01监听输入事件&lt;/title&gt; &lt;style&gt; .search&#123; width: 300px; height: 30px; margin: 30px auto; position: relative; &#125; .search input&#123; width: 250px; height: 26px; &#125; .search label&#123; position: absolute; left: 10px; top: 8px; font-size: 12px; cursor: text; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; //定义id函数（共用） function $(id)&#123; return document.getElementById(id); &#125; //oninput 支持大部分浏览器 检测用户表单输入内容 //onpropertychange 支持IE678 检测用户表单输入内容 $(&quot;txt&quot;).oninput = $(&quot;txt&quot;).onpropertychange = function()&#123; if(this.value == &quot;&quot;)&#123; $(&quot;message&quot;).style.display = &quot;block&quot;; &#125;else&#123; $(&quot;message&quot;).style.display = &quot;none&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;search&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;label for=&quot;txt&quot; id=&quot;message&quot;&gt;七夕礼物&lt;/label&gt;&lt;/div&gt;&lt;/body&gt; 在这里因为同一事件源的事件用的同一事件处理程序，中间可以使用连等来兼容不同的浏览器，label的for属性值值等于input的id属性值，可以在点击label的使用把鼠标定位到input中，之后采用定位（字绝父相）将label定位到输入框中（h5中使用placeholder可以更方便实现），cursor: text;可以在获取焦点后将光标变为输入样式。1&lt;input type=&quot;text&quot; placeholder=&quot;七夕礼物&quot;/&gt; 2.数组2.1声明数组 使用[]; 如：var arr1 = [1,2,3,4,5]; 使用Array关键字；如：var arr2 = new Array(1,3,5,7,9);2.2使用数组使用数组的方法是：数组名[索引值]。但是需要注意的是索引值是从0开始算的。如：arr1[1] = 2;2.3数组长度计算数组长度的方法是：数组名.length。例如：arr1.length = 5.2.4数组遍历数组的遍历使用for循环。123456789for(var i = 0; i&lt;arr1.length;i++) // 遍历数组&#123; console.log(arr1[i]);&#125;或for(var i= 0, len = arr1.length; i&lt;len;i++) // 遍历数组&#123; console.log(arr1[i]);&#125; 其中下面这种效率更高，因为它只计算了一次len长度，但是我经常采用上面的那种，习惯了。下面看一个隔行变色的例子，就是使用到了数组的相关知识123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02隔行变色&lt;/title&gt; &lt;style&gt; .box&#123; width: 360px; &#125; .box ul&#123; line-height: 30px; list-style-type: none; &#125; .box li span&#123; margin: 8px; &#125; .now&#123; background-color: #aaa!important; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; //获取所有li并遍历，隔行换颜色。 var lis = document.getElementsByTagName(&quot;li&quot;); for(var i=0;i&lt;lis.length;i++)&#123; if(i%2==0)&#123; lis[i].style.backgroundColor = &quot;#eee&quot;; &#125;else&#123; lis[i].style.backgroundColor = &quot;#ddd&quot;; &#125; lis[i].onmouseover = function()&#123; //鼠标经过变颜色,this代表事件的调用者lis[i] this.className = &quot;now&quot;; &#125; lis[i].onmouseout = function () &#123; //鼠标划出变原来的样式 this.className = &quot;&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; 使用this.className,this代表事件的调用者。className后面如果有值则给这个元素添加样式，如果没有值则将元素的样式清空。这里当鼠标经过时给元素添加now样式，鼠标划出移除样式，而在now样式中通过important来提高权重，使这个颜色生效。 3.input输入表单所有通过input输入取过来的值均是String类型，即使输入的是Number类型也不行，这点在类型转换时或相加时需要注意。1234567891011121314151617&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03input输入类型&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; var txt = document.getElementById(&quot;txt&quot;); document.getElementsByTagName(&quot;button&quot;)[0].onclick = function()&#123; alert(typeof txt.value); //string alert(typeof Number(txt.value)); //number &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt;&lt;button&gt;点击&lt;/button&gt;&lt;/body&gt; getElementsByTagName获取到的是标签的数组列表，要想使用某一个记得不要忘记后面的索引号，设置获取input输入框的值js中用value，jq中用val()。 4.三目运算表达式?结果1:结果2;意思是如果表达式的结果成立，则执行结果1，不成立则执行结果2。等价于if else语句。看下面的全选，反选，取消示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04全选和反选&lt;/title&gt; &lt;style&gt; #box ul&#123; list-style-type: none; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var btns = document.getElementsByTagName(&quot;button&quot;); //获取id是box的元素下面的所有input元素。 var inputs = document.getElementById(&quot;box&quot;).getElementsByTagName(&quot;input&quot;); //封装公共的全选或取消按钮 function all(flag)&#123; for(var i=0;i&lt;inputs.length;i++)&#123; inputs[i].checked = flag; &#125; &#125; btns[0].onclick = function()&#123; all(true); //全选 &#125; btns[1].onclick = function()&#123; all(false); //取消 &#125; //反选 btns[2].onclick = function()&#123; for(var i=0;i&lt;inputs.length;i++) &#123; inputs[i].checked == true ? inputs[i].checked = false : inputs[i].checked = true; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;top&quot;&gt; &lt;button&gt;全选&lt;/button&gt; &lt;button&gt;取消&lt;/button&gt; &lt;button&gt;反选&lt;/button&gt;&lt;/div&gt;&lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; 5.排他思想排他思想的指的是先干掉所有人（包括自己），然后再选中自己。123456789101112131415161718192021222324252627282930313233&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05排他思想&lt;/title&gt; &lt;style&gt; .me&#123; background-color: pink; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var btns = document.getElementsByTagName(&quot;button&quot;); for(var i=0;i&lt;btns.length;i++)&#123; btns[i].index = i; //给每个button都定义一个index属性,这里用不到，但之后用索引号的话就需要 btns[i].onclick = function()&#123; //点击时清除掉所有样式，包括自己的 for(var j=0;j&lt;btns.length;j++)&#123; btns[j].className=&quot;&quot;; &#125; //清除完之后再选定自己 this.className=&quot;me&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;排他思想&lt;/button&gt;&lt;button&gt;排他思想&lt;/button&gt;&lt;button&gt;排他思想&lt;/button&gt;&lt;button&gt;排他思想&lt;/button&gt;&lt;button&gt;排他思想&lt;/button&gt;&lt;/body&gt; 6.变量和属性js中变量是自由的，独立存在的；而属性和方法是属于对象的。如：1234var index = 10; //变量 独立存在的，谁都可以使用var arr = []; // 数组，是一个对象arr.index = 20; // 自定义属性 他是arr的属性，只能在arr 中能使用alert(arr.index); 再如我们在上面排他思想中定义的，btns[i].index = i;。这个index就是btns的属性，只能btns有权利使用。下面是一个tabs栏切换的示例，就用到了自定义属性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06tab栏切换&lt;/title&gt; &lt;style&gt; .box&#123; width: 400px; margin: 100px auto; border: 1px solid #ccc; &#125; #bottom div&#123; width: 100%; height: 300px; background-color: pink; display: none; &#125; .green&#123; background-color: green; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var btns = document.getElementsByTagName(&quot;button&quot;); var divs = document.getElementById(&quot;bottom&quot;).getElementsByTagName(&quot;div&quot;); for(var i=0;i&lt;btns.length;i++)&#123; btns[i].index = i; // 给button设置index属性，下面可以用，这是本例的难点 btns[i].onclick = function()&#123; //alert(this.index); //把所有按钮和所有div的样式去掉 for(var j=0;j&lt;btns.length;j++)&#123; btns[j].className=&quot;&quot;; &#125; for(var k=0;k&lt;btns.length;k++)&#123; divs[k].style.display = &quot;none&quot;; &#125; //给当前按钮添加样式 this.className=&quot;green&quot;; //获取当前点击的那个按钮的索引号，把对应索引号的div的样式显示。 divs[this.index].style.display = &quot;block&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;div id=&quot;top&quot;&gt; &lt;button&gt;第一个&lt;/button&gt; &lt;button&gt;第二个&lt;/button&gt; &lt;button&gt;第三个&lt;/button&gt; &lt;button&gt;第四个&lt;/button&gt; &lt;button&gt;第五个&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;bottom&quot;&gt; &lt;div style=&quot;display: block&quot;&gt;1号盒子&lt;/div&gt; &lt;div&gt;2号盒子&lt;/div&gt; &lt;div&gt;3号盒子&lt;/div&gt; &lt;div&gt;4号盒子&lt;/div&gt; &lt;div&gt;5号盒子&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 友情提示，如果控制台报这样的错（Uncaught TypeError: Cannot read property ‘getElementsByTagName’ of null），十有八九是因为没有写入口函数window.onload，导致页面还没加载完毕就开始执行了。代码地址：https://git.oschina.net/catchu/web-study]]></content>
      <categories>
        <category>前端—javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门—js第二天]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E2%80%94js%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1.函数1.1函数声明js中可以通过以下三种方法定义函数： 自定义函数 直接量声明（函数表达式声明） 使用Function函数构造法（参数必须加引号）。区别：自定义函数和直接量声明是有区别的，自定义函数调用函数在定义之前之后都是可以了；而直接量声明只能在声明函数之后调用，否则会报错（像我下面的fun2就会报错）。1234567891011121314//1.自定义函数function fun1()&#123;alert(&quot;我是自定义函数&quot;);&#125;//函数声明之后需要调用，不然不会自动执行，执行函数可以在声明之前也可以在声明之后//fun1();//2.直接量声明//fun2() //调用函数var fun2 = function()&#123;alert(&quot;我是直接量声明&quot;);&#125;//3.使用Function关键字var fun3 = new Function(&quot;var a=10,b=20;alert(a+b);&quot;);fun3() 1.2变量提升变量提升指的是在函数体内会把变量的声明提升到函数体的最前面，只声明但是并不给变量赋值。例如1234567891011function fun()&#123; console.log(num); var num = 20;&#125;相当于function fun()&#123; var num; console.log(num); num = 20;&#125;所以结果可想而知，在这里会报undefined的异常。 下面的输出结果是undefined和20,就是执行了变量提升，尽管前面声明了num，但是在函数里面先声明num，而且没有给赋值。1234567var num=10;function fun1()&#123; alert(num); var num = 20; alert(num);&#125;fun1(); //调用函数 1.3函数参数js在创建函数的同时会创建一个arguments对象用来存储函数调用时传过来的实参，arguments对象的长度由传入实参的个数决定。函数名.length可以获取函数形参的个数。根据这一方法可以判断实参和形参个数是否相同。函数实参个数多于形参个数可以调用，小于则会报错（相当于一个形参undefined）123456function fun(a,b)&#123; console.log(a+b);&#125;fun(1,2); //3fun(5); //NaNfun(4,5,6); //9 下面判断形参和实参个数123456789function fun(a,b)&#123; if(fun.length == arguments.length)&#123; console.log(a+b);&#125;else&#123; console.error(&quot;传递参数不匹配&quot;)&#125;&#125;fun(1,2); //3fun(1,2,3); //传递参数不匹配 1.4两种定义变量的区别var a=1,b=1和var a=b=1。前者相当于var a=1;var b=1;两个变量均是局部变量。而后一个a是局部变量，b则是全局变量（隐式的全局变量）var a=1和a=1前者如果是在函数内声明属于局部变量，如果在函数外声明属于全局变量。后者跟上面说的一样，属于隐式的全局变量。 2.returnreturn有两个作用：一是设置返回值，另一个是终止代码的执行。在函数内部使用return来设置返回值，一个函数只能有一个返回值，自定义的函数默认没有返回值。同时return后跟逗号可以终止代码的执行（比如提交表单之前的校验）。12345678function fun(a,b)&#123; if(a&gt;b)&#123; //return 不仅返回函数运行的结果，如果直接用return后跟分号，是终止当前函数的执行。 return; &#125;return a+b;&#125;console.log(fun(2,1)); 3.++运算i++:先使用i，执行完再运算i=i+1;++i:先运算i=i+1,然后在执行运算。123456var a=10, b=20 , c=30;++a;a++;e=++a+(++b)+(c++)+a++;alert(e);弹出结果是：77 4.thisthis自己的，主要指事件的调用者。innerHTML更换盒子的内容value获取和设置表单的值下面说一个小技巧，页面加载完毕之后自动获取焦点（例如百度搜索），鼠标滑过之后自动选中文本内容，便于用户删除搜索框的内容dom.focus()获取dom焦点，onfocus()获取焦点触发事件,dom.select()选中dom。1234567891011121314151617181920&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;09两个表单小方法&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; //页面加载完毕自动获取焦点 var focus = document.getElementById(&quot;focus&quot;); focus.focus(); //鼠标经过自动选中文本内容，方便用户删除 var sel = document.getElementById(&quot;sel&quot;); sel.onmouseover = function()&#123; this.select(); //this指事件的调用者 &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;focus&quot;&gt;&lt;br&gt;&lt;input type=&quot;text&quot; id=&quot;sel&quot;&gt;&lt;/body&gt; 4.1输入框表单校验（基本的表单校验）123456789101112131415161718192021222324252627282930 &lt;script&gt; window.onload = function () &#123; var txt = document.getElementById(&quot;name&quot;); txt.onfocus = function()&#123; //清空 this.value = &quot;&quot;; &#125; //失去焦点判断输入内容 txt.onblur = function()&#123; if(this.value==&quot;&quot;)&#123; this.value=&quot;请输入...&quot;; &#125; &#125; document.getElementsByTagName(&quot;button&quot;)[0].onclick = function()&#123; if(txt.value==&quot;&quot; || txt.value==&quot;请输入...&quot;)&#123; txt.value=&quot;请输入...&quot;; alert(&quot;请输入内容&quot;); return; //终止代码继续向下执行 &#125; alert(&quot;正在搜索，请稍后&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;search&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;请输入...&quot; id=&quot;name&quot;&gt; &lt;button&gt;&lt;/button&gt;&lt;/div&gt;&lt;/body&gt; 4.2金字塔在页面输出一个金字塔的形状，可以使用for循环，使用百分比来控制hr的宽度。1234567&lt;script&gt;for(i=1;i&lt;=100;i+=3)&#123; document.write(&quot;&lt;hr width=&quot;+i+&quot;%&gt;&quot;);&#125;&lt;/script&gt;&lt;body&gt;&lt;/body&gt; 代码地址：https://git.oschina.net/catchu/web-study]]></content>
      <categories>
        <category>前端—javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门—js第一天]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E2%80%94js%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[0.写在前面因为上周五临时走的急，没有带电脑，周末两天在家没有更新笔记，今天继续。js是连接前后端的桥梁，在项目开发中至关重要，从今天开始写一些js的入门笔记。 1.体验js1.1Alert弹框window.alert(“我是弹框”)；window窗口对象，一般是可以省略的。alert弹框可以在调试js代码时使用。 1.2console控制台输出console.log(“输出”)控制台输出，普通输出语句。console.info(“输出”)控制台输出信息。console.warn() 控制台警示。console.error();错误提示。一般常用console.info()输出到控制台来调试js代码。 1.3document.write()文档打印输出document文档对象，不可以省略，document.write()可以直接输出信息到页面。比如可以用它来做倒计时，每隔一秒输出新的时间一次。 2.变量2.1变量的命名 变量命名必须以字母或是下标符号”_”或者”$”为开头。 变量名长度不能超过255个字符。 变量名中不允许使用空格。 不用使用脚本语言中保留的关键字及保留符号作为变量名。 变量名区分大小写。 2.2作用域变量分为局部变量和全局变量。全局变量：1.在方法外声明的变量；2.在方法内没有使用var声明，直接使用的变量（这种属于隐式全局变量）。局部变量：在方法内声明的变量（作用域是方法内）。例如： 123456789101112var a = 10;function fun()&#123; a = &quot;global&quot;;&#125;console.log(a); //输出 ？var a;function fun()&#123; a = &quot;global&quot;; &#125;fun();console.log(a); 则上面的输出：10，下面的输出global。原因是上面输出的时候并没有调用fun函数，输出的10，下面调用了fun函数，a被覆盖成了global（函数不调用不会执行）。看下面一个例子： 12345678 var a = 1function func() &#123; a = b = 2 &#125; func() alert(a) alert(b) 输出的a.b都是2，而不是a是2，b报错，因为这里a开始等于1后来调用func函数，a被覆盖为2，而2没有用var声明，属于隐式的全局变量，出了func函数照样可以用的，所以不会报错。 3.Js事件Js事件三要素：事件源，事件，事件处理程序 3.1事件源事件源是事件的发起者（一般是个名词），谁触发了某次事件，那么谁就是事件源。 3.2事件事件指触发的操作（一般是个动词）。常见的事件如下：| 事件名 | 说明 || ———– | —————– || onclick | 鼠标单击 || ondblclick | 鼠标双击 || onkeyup | 按下并释放键盘上的一个键时触发 || onchange | 文本内容或下拉菜单中的选项发生改变 || onfocus | 获得焦点，表示文本框等获得鼠标光标 || onblur | 失去焦点，表示文本框等失去鼠标光标 || onmouseover | 鼠标经过，即鼠标划过图片等的上方 || onmouseout | 鼠标移出，即离开图片等所在的区域 || onload | 网页文档加载事件 || onunload | 关闭网页时触发 || onsubmit | 表单提交事件 || onreset | 重置表单事件 | 3.3事件处理程序事件触发之后的处理操作，一般是函数。结构如下：事件源.事件 = function(){ //事件处理程序}例子：1234567891011121314151617181920212223&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #demo&#123; width: 200px; height: 200px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;改变宽度&lt;/button&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var demo = document.getElementById(&quot;demo&quot;); var btn = document.getElementById(&quot;btn&quot;); btn.onclick = function()&#123; demo.style.width = &quot;400px&quot;; &#125;&lt;/script&gt;目的：点击btn按钮时让demo盒子的宽度变成400px。注意：宽度是通过style标签控制的，如果要改变它也是通过style标签,改变demo.style.width。如果修改背景图片可以用：demo.style.backgroundImage = &quot;url(images/1.jpg)&quot; 4.隐藏显示1234567display:none 隐藏display:block 显示visibility:hidden 隐藏visibility:visible 显示overflow:hidden 溢出隐藏注意：display跟visibility的隐藏有区别，dispaly:none隐藏不占位置；visibility:hidden隐藏占有位置（占茅坑不拉屎） 5.入口函数（window.onload）123window.onload = function()&#123; //需要执行的js&#125; 把script标签放在head中时可能会导致页面没有加载完毕就去执行js代码了，结果导致报错，这时就可以使用window.onload函数了，它会等到我们页面加载完毕（页面的结构，样式，节点）之后才去执行function里面的代码。注意：一个页面中只能有一个window.onload入口函数，如果写多个，则最后一个会覆盖前面的，导致前面的不生效。这点跟jquery里面的$(function(){})是有区别的，后者在一个页面可以写多个。 6.模态框现在有个需求：当我们浏览京东，淘宝这些网站的时候，细心点就会发现，当点击登录时整个窗口都会变灰色，而且弹出一个模态框让我们输入用户名密码，怎么实现这个效果呢。实现原理：做一个大的遮罩和一个弹出的模态框，大遮罩定位使用fixed（好处：不会随着滚动条滚动），颜色灰色，不点击登录时隐藏，z-index：999保证它可以覆盖着当前窗口。而弹出这个模态框z-index：1000大于刚才的那个遮罩（会覆盖到遮罩上面）；而关闭按钮使用绝对定位定位在由上角（”字绝父相”）。当点击登录按钮时让这两个弹框显示即可。效果如图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354html部分：&lt;!--遮罩--&gt;&lt;div id=&quot;mask&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box&quot;&gt; &lt;span id=&quot;close_all&quot;&gt;×&lt;/span&gt;&lt;/div&gt;css部分：/*******遮罩*******/#mask&#123; width: 100%; height: 100%; position: fixed; top: 0; left: 0; background:rgba(0,0,0,.5); display: none; z-index: 999;&#125;#box&#123; width: 400px; height: 250px; position: fixed; top: 50%; left: 50%; margin: -125px 0 0 -200px; background-color: #fff; z-index: 1000; display: none;&#125;#close_all&#123; position: absolute; width: 20px; height: 20px; font-size: 20px; top: 10px; right:10px; cursor: pointer;&#125;js部分：window.onload = function()&#123; var login = document.getElementById(&quot;login&quot;) var mask = document.getElementById(&quot;mask&quot;); var box = document.getElementById(&quot;box&quot;); var closeAll = document.getElementById(&quot;close_all&quot;); login.onclick = function()&#123; mask.style.display = &quot;block&quot;; box.style.display = &quot;block&quot;; &#125; closeAll.onclick = function()&#123; mask.style.display = &quot;none&quot;; box.style.display = &quot;none&quot;; &#125;&#125; 7.数据类型js中有五种基本数据类型（String，Number,Boolean,NUll,Undefined）和混合数据类型（Object）,使用typeof可以检测变量的数据类型（输出的是一个关于数据类型的字符串），返回如下字符串：string,number,boolean,object,undefined,function。12345678910111213141516171819var x = 1;console.log(typeof x);//numbervar a = undefined;console.log(typeof a);//undefinedvar b = null;console.log(typeof b);//object，（其实这是js最初的错误，后来被ECMAscript沿用了下来，我们可以理解null是空对象引用）。var c = new Object();console.log(typeof c);//objectvar e = [1,2,3];console.log(typeof e);//object var d = function()&#123; // ... 语句块&#125;console.log(typeof d);//function 7.1字符型（String）转换为字符型： 变量后加双引号或单引号（js中字符型双引号和单引号效果一样，java中不一样）。 使用函数String()，即使是null和undefined也可以使用，转换后是null和undefined 使用函数toString(),只能是非空的才能用，null和undefined使用会报错。12345678910var bc = &quot;zhangsan&quot;;var bd = null;var be = undefined;console.log(bc.toString());//console.log(bd.toString());//error 报错//console.log(be.toString());//error 报错console.log(&quot;------&quot;);console.log(String(bc));console.log(String(bd));console.log(String(be)); 7.2数值型（Number）Number类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值。浮点数将会自动转换为整数。12var num = 1.00;console.log(num);//1，自动转换为整数 浮点数的最高精度是17位，看下面的例子，结果不是0.3，其他编程语言，有的也会遇到这种情况（浮点数计算会产生舍入误差问题）。这里也警示我们，如果涉及到金额计算不要用浮点数，同时尽量在后台处理，所有的金额乘以100，即以分为单位进行计算入库，浮点数无法进行金额精确计算，风险极高。123456789101112console.log(0.1+0.2); //0.30000000000000004 解释：js做小数运算会出现错误，一般推荐转为整数在进行计算，比如这里输出就错了console.log((0.1*10+0.2*10)/10); 0.3var num=020;console.log(num); //16 解释：0开头的是八进制，这里输出八进制20，是十进制的16var result = &quot;20&quot;;var aa = result-10;console.log(aa); //10 解释：js字符串和数值相减时先将字符串转为数值型，在运行减法，结果为number型console.log(typeof aa);//numbervar bb = result+10;console.log(bb); //2010console.log(typeof bb); //string 解释：js字符串与数值相加值，返回结果为字符串行拼接 NaN:非数字类型（not a num字面意思：不是一个数字）。特点：① 涉及到的 任何关于NaN的操作，都会返回NaN ② NaN不等于自身。123var ab = &quot;a1&quot;;console.log(ab/10);// NaNconsole.log(NaN == NaN);// false; isNaN()函数，用于判断是否是一个非数字类型。如果传入的参数是一个非数字类型，那么返回true；否则返回false;isNaN()函数，传入一个参数，函数会先将参数转换为数值。如果参数类型为对象类型，会先调用对象的valueOf()方法， 再确定该方法返回的值是否可以转换为数值类型。如果不能，再调用对象的toString()方法，再确定返回值。其它类型转化为数值型的方法： 利用 - * / 都可以转换 (+不行，字符串跟数字相加结果是字符串拼接) 利用Number( ) parseInt()，将值转换为整型 parseFloat()；将值转换为浮点型。看下面列子：1234567console.log(parseInt(19.11)); //19console.log(parseInt(19.99)); //19console.log(parseInt(&quot;25px&quot;)); //25 解释：只转化数字的那部分console.log(parseInt(&quot;px25px&quot;)); //NaN 解释：parseInt只能将以数字开头的字符串转化为数字console.log(parseInt(110,2)); //6 解释：把二进制的110转化为十进制var a=&quot;15.15abc&quot; , b=&apos;10.15&apos; , c=&apos;10.0abc&apos;;console.log(parseInt(a)+Number(b)+parseFloat(c)); //15+10.15+10.0=35.15 7.3布尔型（Boolean）有两个值：true和false转换为布尔型的方法： 利用 !! 利用 Boolean() 123var num =10;console.log(typeof !!num); //booleanconsole.log(!!num); //true false、undefined 、null、0、”” 为 falsetrue、1、”somestring”、[Object] 为 true 7.4NUllnull类型被看做空对象指针，前文说到null类型也是空的对象引用。只有一个值，即null值，所以，在你 用typeof 操作符去检测null类型的值时，结果是object类型。如果你定义了一个变量，但是想在以后把这个变量当做一个对象来用，那么最好将该对象初始化为null值。实际上，undefined值是派生自null值的，因此ECMA-262规定对他们的相等测试要返回true。1alert(null == undefined) //true 7.5UndefinedUndefined类型只有一个值undefined,表示“缺少值”，就是此处应该有值，但是未给。用法如下： 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。1234567var a;var b = null;console.log(a); //undefinedconsole.log(a==b); //trueconsole.log(a===b); //falseconsole.log(b+10); //10console.log(a+10); //NaN 7.6Object类型Object是对象类型（也叫引用类型），创建方法： 使用new操作符后跟Object构造函数 123var person = new Object(); //创建Object引用类型的一个新实例，并且把该实例保存在变量person中。person.name = &quot;CC&quot;;person.age = 23; 使用对象字面量表达式:对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。 1234var person = &#123; name : &quot;CC&quot;, age : 23&#125;; 代码地址：https://git.oschina.net/catchu/web-study]]></content>
      <categories>
        <category>前端—javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring.xm中配置文件使用占位符]]></title>
    <url>%2F2017%2F12%2F14%2Fspring-xml%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[在spring中，可以使用PropertyPlaceholderConfigurer引入以properties的配置文件，在配置文件中定义key，value形式的键值对，之后在xml中读取${key}的值，可以灵活的配置常用参数。 1.定义.properties的配置文件这里定义一个mysql数据库连接的配置文件做测试。1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://192.168.49.127\:3306/test?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;useSSL=truejdbc.username=rootjdbc.password=root 2.在.xml中引入.properties配置文件12345678&lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath*:jdbc.properties&lt;/value&gt; &lt;value&gt;/WEB-INF/mail.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 注意上面一种classpath是引用src目录下的文件写法，下面一种是引入在WEB-INF下面的文件。如果引入单个文件，还可以不用list。1234567&lt;bean id=&quot;propertyConfigurerForProject1&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;location&quot;&gt; &lt;value&gt;classpath:/com/catchu/me/jdbc.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 3.使用配置文件123456&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/bean&gt; 使用时直接使用${}就可以了，类似于EL表达式。]]></content>
      <categories>
        <category>后台—spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro进阶—与项目整合]]></title>
    <url>%2F2017%2F12%2F14%2Fshiro%E8%BF%9B%E9%98%B6%E2%80%94%E4%B8%8E%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[0.数据库原型数据库原型如下图所示： 1.引入jar 除在入门中引入的jar包之外，在web项目中如果用到shiro，还需要引入以下jar：shiro-web-1.2.3.jarshiro-spring-1.2.3.jarshiro-quartz-1.2.3.jarquartz-1.6.1.jarehcache-core-2.5.0.jarshiro-ehcache-1.2.3.jar 2.在web.xml中配置shiro的filter 在web项目中也通过filter(过滤器)拦截shiro，filter拦截后将操作权交给在spring.xml中配置的过滤器链（fliterchain）处理，shiro中提供许多过滤器。在web.xml中配置shiro过滤器的web.xml完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;permission1110&lt;/display-name&gt; &lt;!-- 配置spring容器监听器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springmvc配置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 配置文件的地址 如果不配置contextConfigLocation， 默认查找的配置文件名称classpath下的：servlet名称+&quot;-serlvet.xml&quot;即：springmvc-serlvet.xml --&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 可以配置/ ，此工程 所有请求全部由springmvc解析，此种方式可以实现 RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析 可以配置*.do或*.action，所有请求的url扩展名为.do或.action由springmvc解析，此种方法常用 不可以/*，如果配置/*，返回jsp也由springmvc解析，这是不对的。 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--这里就是配置的shiro过滤器--&gt; &lt;!-- shiro的filter --&gt; &lt;!-- shiro过虑器，DelegatingFilterProxy通过代理模式将spring容器中的bean和filter关联起来 --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;!-- 设置true由servlet容器控制filter的生命周期 --&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 设置spring容器filter的bean id，如果不设置则找与filter-name一致的bean--&gt; &lt;init-param&gt; &lt;param-name&gt;targetBeanName&lt;/param-name&gt; &lt;param-value&gt;shiroFilter&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- post乱码处理 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 3. 在spring-shiro.xml中配置web.xml中过滤器对应spring容器中的bean. 配置代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt; &lt;!-- web.xml中shiro的filter对应的bean --&gt; &lt;!-- Shiro 的Web过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由formAuthenticationFilter进行表单认证 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.action&quot; /&gt; &lt;!-- 认证成功统一跳转到first.action，建议不配置，shiro会自动在认证成功后跳转到到上一个请求路径 --&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/first.action&quot;/&gt; &lt;!-- 通过unauthorizedUrl指定没有权限操作时跳转页面--&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/refuse.jsp&quot; /&gt; &lt;!-- 过滤器链定义，从上向下顺序执行，一般将/**放在最下边 --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &lt;!-- 对静态资源设置匿名访问 --&gt; /images/** = anon /js/** = anon /styles/** = anon &lt;!-- 验证码，可匿名访问 --&gt; /validatecode.jsp = anon &lt;!-- 请求 logout.action地址，shiro去清除session--&gt; /logout.action = logout &lt;!-- 配置记住我或认证通过可以访问的地址 --&gt; /index.jsp = user /first.action = user /welcome.jsp = user &lt;!-- /** = authc 所有url都必须认证通过才可以访问--&gt; /** = authc &lt;!-- /** = anon所有url都可以匿名访问 --&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- securityManager安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;customRealm&quot; /&gt; &lt;/bean&gt;&lt;!-- 自定义realm --&gt;&lt;bean id=&quot;customRealm&quot; class=&quot;com.catchu.ssm.shiro.CustomRealm&quot;&gt; &lt;!-- 将凭证匹配器设置到realm中，realm按照凭证匹配器的要求进行散列 --&gt; &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt;&lt;/bean&gt;&lt;!-- 凭证匹配器 --&gt; &lt;bean id=&quot;credentialsMatcher&quot; class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot; /&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;1&quot; /&gt;&lt;/bean&gt;&lt;/beans&gt; 我把自定义realm也放在了这一步进行配置 4.自定义realm进行认证 我们在上一步spring-shiro.xml中配置了loginUrl，当用户没有登录时将会请求此地址进行登录，FormAuthenticationFilter会拦截到用户的请求，获取到username,password(默认，可以进行配置)，之后调用我们自定义的Realm进行认证。自定义realm代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @Description 用于认证 * @Author 刘俊重 * @date 2017年8月1日 */@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //从token获取principal（身份信息）,token中存的是用户名和密码 String userCode = (String) token.getPrincipal(); //根据用户名查询用户信息 SysUser sysUser = null; try &#123; sysUser = sysService.findSysUserByUserCode(userCode); &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; //用户不存在返回null if(null== sysUser)&#123; return null; &#125; //用户存在，获取用户散列后的密码，盐 String password = sysUser.getPassword(); String salt = sysUser.getSalt(); //activeUser就是用户的身份信息 ActiveUser activeUser = new ActiveUser(); activeUser.setUserid(&quot;zhangsan&quot;); activeUser.setUsercode(&quot;zhangsan&quot;); activeUser.setUsername(&quot;zhangsan&quot;); //根据用户id查询菜单 List&lt;SysPermission&gt; menuList = null; try &#123; menuList = sysService.findMenuListByUserId(&quot;zhangsan&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; activeUser.setMenus(menuList); //将用户身份信息activeUser设置到SimpleAuthenticationInfo中 SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(activeUser, password,ByteSource.Util.bytes(salt),getName()); return simpleAuthenticationInfo;&#125; 在这里要注意的是：我们从token中获取到的是用户输入请求过来的用户名和密码，然后根据用户名查询数据库获得的用户信息并封装成ActiveUser，放在SimpleAuthenticationInfo中，之后ActiveUser就是主体的身份信息而不是username(你在SimpleAuthenticationInfo把谁放进去了，谁就是主体的身份信息)。 5.自定义Realm进行授权 直接入正题，我们这里采用注解进行springmvc的授权操作，注解中填权限标识符。首先需要在spring-mvc.xml中配置对shiro注解的支持。在原有spring-mvc.xml的代码中加入以下配置：1234567&lt;!-- 开启aop，对类代理 --&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt;&lt;/aop:config&gt;&lt;!-- 开启shiro注解支持 --&gt;&lt;bean class=&quot; org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt;&lt;/bean&gt; 在请求的Controller方法中配置@RequiresPermissions注解（里面填权限标识符），示例代码如下：12345678910111213//商品信息方法@RequestMapping(&quot;/queryItem&quot;)@RequiresPermissions(&quot;item:query&quot;) //表明请求这个queryItem时需要item:query权限，会调用自定义realm（调用数据库）查询主体拥有的权限，判断是否有访问本请求的权限public ModelAndView queryItems(HttpServletRequest request) throws Exception &#123; System.out.println(request.getParameter(&quot;id&quot;)); //调用service查询商品列表 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;itemsList&quot;, itemsList); // 指定逻辑视图名 modelAndView.setViewName(&quot;itemsList&quot;); return modelAndView;&#125; 比如当请求/queryItem过来时，看到有RequiresPermissions注解，表明本请求需要要权限才能访问，就会调用自定义的realm查询本主体（subject）所有的权限，看这个权限标识符是否在该主体拥有的权限标识符中，自定义realm进行授权代码如下：12345678910111213141516171819202122232425262728/** * @Description 用于授权 * @Author 刘俊重 * @date 2017年8月1日 */@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; //从principals中获取主身份信息。在上一步认证中把身份信息activeUser放进了SimpleAuthenticationInfo，这里再取出来。 ActiveUser activeUser = (ActiveUser) principals.getPrimaryPrincipal(); //从数据库中根据身份信息查询到的权限信息 List&lt;SysPermission&gt; permissionList = null; try &#123; permissionList = sysService.findPermissionListByUserId(activeUser.getUserid()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; List&lt;String&gt; permissions = new ArrayList&lt;String&gt;(); if(permissionList!=null &amp;&amp; permissionList.size()&gt;0)&#123; for(SysPermission permission:permissionList)&#123; //将用户权限标识符放在list之后填充到SimpleAuthorizationInfo并返回 permissions.add(permission.getPercode()); &#125; &#125; //构建授权信息，并返回 SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); simpleAuthorizationInfo.addStringPermissions(permissions); return simpleAuthorizationInfo;&#125; 6.常用的shiro过滤器 常用的shiro过滤器如下，可以关联源码，在shiro-web包下查看源代码：| 过滤器简称 | 对应的java类 || ———- | —————————————- || anon | org.apache.shiro.web.filter.authc.AnonymousFilter || authc | org.apache.shiro.web.filter.authc.FormAuthenticationFilter || authcBasic | org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter || perms | org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter || port | org.apache.shiro.web.filter.authz.PortFilter || rest | org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter || roles | org.apache.shiro.web.filter.authz.RolesAuthorizationFilter || ssl | org.apache.shiro.web.filter.authz.SslFilter || user | org.apache.shiro.web.filter.authc.UserFilter || logout | org.apache.shiro.web.filter.authc.LogoutFilter | anon:例子/admins/=anon 没有参数，表示可以匿名使用。 authc:例如/admins/user/=authc表示需要认证(登录)才能使用，FormAuthenticationFilter是表单认证，没有参数 perms：例子/admins/user/*=perms[user:add:],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，例如/admins/user/=perms[“user:add:,user:modify:“]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。 user:例如/admins/user/**=user没有参数表示必须存在用户, 身份认证通过或通过记住我认证通过的可以访问，当登入操作时不做检查 7.Jsp标签授权 在jsp或者html页面中，如果开发者想对项目控制的粒度更加精细，可以在页面中使用标签授权（类似于ifelse的判断形式），Jsp页面添加：1&lt;%@ tagliburi=&quot;http://shiro.apache.org/tags&quot; prefix=&quot;shiro&quot; %&gt; 标签名称 标签条件（均是显示标签内容） shiro:authenticated(左右两边的尖括号省略) 登录之后 shiro:notAuthenticated 不在登录状态时 shiro:guest 用户在没有RememberMe时 shiro:user 用户在RememberMe时 shiro:hasAnyRoles name=”abc,123” 在有abc或者123角色时 shiro:hasRole name=”abc” 拥有角色abc shiro:lacksRole name=”abc” 没有角色abc shiro:hasPermission name=”abc” 拥有权限资源abc shiro:lacksPermission name=”abc” 没有abc权限资源 shiro:principal 显示用户身份()名称 到这里其实shiro跟web项目的整合已经配置完成了，正常使用是没有问题的，下面涉及到的都是优化的操作 8.shiro缓存 通过上一步打断点我们会看出，只要用户发请求了，而且controller中有RequiresPermissions注解了，都会重复调用自定义realm的授权方法，重复的查询数据库，我们就想到了用缓存来提高速度。 shiro中提供了对认证信息和授权信息的缓存。shiro默认是关闭认证信息缓存的，对于授权信息的缓存shiro默认开启的。主要研究授权信息缓存，因为授权的数据量大。 用户认证通过。 该用户第一次授权：调用realm查询数据库 该用户第二次授权：不调用realm查询数据库，直接从缓存中取出授权信息（权限标识符）。 添加ehcache的jar，并且配置shiro-ehcache.xml,代码如下： 12345678910111213141516&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!--diskStore：缓存数据持久化的目录 地址 --&gt; &lt;diskStore path=&quot;F:\develop\ehcache&quot; /&gt; &lt;defaultCache maxElementsInMemory=&quot;1000&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 在spring-shiro.xml配置文件中，配置安全管理器（securityManger）中引入shiro-ehcache.xml: 1234567891011 &lt;!-- securityManager安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;customRealm&quot; /&gt; &lt;!-- 注入缓存管理器 --&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;/bean&gt; &lt;!-- 缓存管理器 --&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:shiro-ehcache.xml&quot;/&gt;&lt;/bean&gt; 清空缓存：如果用户正常退出，缓存自动清空。如果用户非正常退出，缓存自动清空。如果修改了用户的权限，而用户不退出系统，修改的权限无法立即生效。需要手动进行编程实现：在权限修改后调用自定义realm的clearCache方法清除缓存。在自定义Realm定义的清空缓存的方法如下： 12345//清除缓存public void clearCached() &#123; PrincipalCollection principals = SecurityUtils.getSubject().getPrincipals(); super.clearCache(principals);&#125; 在修改完用户的权限之后的serviceImpl层中可以直接调用清除缓存：12345678910//注入realm@Autowiredprivate CustomRealm customRealm;@RequestMapping(&quot;/clearShiroCache&quot;)public String clearShiroCache()&#123; //清除缓存，将来正常开发要在service调用customRealm.clearCached() customRealm.clearCached(); return &quot;success&quot;;&#125; 9.自定义表单认证过滤器 现在有一个需求，就是用户登录时不止提交有用户名，密码，还有验证码。那么原有的表单验证拦截器只验证用户名和密码就不行了。我们继承FormAuthenticationFilter拦截器实现自己的拦截器即可。代码如下：123456789101112131415161718192021222324252627282930313233343536package com.catchu.ssm.shiro;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;/** * @author 刘俊重 * @Description 自定义FormAuthenticationFilter，认证之前实现 验证码校验 * @date 2017年8月4日 */public class CustomFormAuthenticationFilter extends FormAuthenticationFilter &#123; //原FormAuthenticationFilter的认证方法 @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; //在这里进行验证码的校验 //从session获取正确验证码 HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpSession session =httpServletRequest.getSession(); //取出session的验证码（正确的验证码） String validateCode = (String) session.getAttribute(&quot;validateCode&quot;); //取出页面的验证码 //输入的验证和session中的验证进行对比 String randomcode = httpServletRequest.getParameter(&quot;randomcode&quot;); if(randomcode!=null &amp;&amp; validateCode!=null &amp;&amp; !randomcode.equals(validateCode))&#123; //如果校验失败，将验证码错误失败信息，通过shiroLoginFailure设置到request中 httpServletRequest.setAttribute(&quot;shiroLoginFailure&quot;, &quot;randomCodeError&quot;); //拒绝访问，不再校验账号和密码 return true; &#125; return super.onAccessDenied(request, response); &#125; &#125; 在spring-shiro.xml中配置代码如下：1234567891011&lt;!-- 自定义form认证过虑器 --&gt;&lt;!-- 基于Form表单的身份验证过滤器，不配置将也会注册此过虑器，表单中的用户账号、密码及loginurl将采用默认值，建议配置 --&gt;&lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;com.catchu.ssm.shiro.CustomFormAuthenticationFilter &quot;&gt; &lt;!-- 表单中账号的input名称 --&gt; &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot; /&gt; &lt;!-- 表单中密码的input名称 --&gt; &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot; /&gt; &lt;!-- 记住我input的名称 --&gt; &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt; &lt;/bean&gt; 注入到安全管理器（securitymanager）1234567&lt;!-- 自定义filter配置 --&gt;&lt;property name=&quot;filters&quot;&gt; &lt;map&gt; &lt;!-- 将自定义 的FormAuthenticationFilter注入shiroFilter中 --&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot; /&gt; &lt;/map&gt;&lt;/property&gt; 10.配置rememberMe有时用户登录之后需要记住用户名和密码，保存在cookie中，下次登录可以直接访问。 jsp中页面代码如下： 1234&lt;tr&gt;&lt;TD&gt;&lt;/TD&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; /&gt;自动登陆&lt;/td&gt;&lt;/tr&gt; ActiveUser类要实现序列化（用户身份信息，存入session 由于tomcat将session会序列化在本地硬盘上，所以使用Serializable接口）： 12345public class ActiveUser implements java.io.Serializable &#123; private String userid;//用户id（主键） private String usercode;// 用户账号 private String username;// 用户名称 &#125; spring-shiro.xml中配置rememberMeManager管理器 1234567891011&lt;!-- rememberMeManager管理器，写cookie，取出cookie生成用户信息 --&gt; &lt;bean id=&quot;rememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt; &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot; /&gt; &lt;/bean&gt; &lt;!-- 记住我cookie --&gt; &lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;!-- rememberMe是cookie的名字 --&gt; &lt;constructor-arg value=&quot;rememberMe&quot; /&gt; &lt;!-- 记住我cookie生效时间30天 --&gt; &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot; /&gt; &lt;/bean&gt; 使用UserFilter如果设置记住我，下次访问某些url时可以不用登陆。将记住我即可访问的地址配置让UserFilter拦截。在spring-shiro.xml中配置如下： 1234&lt;!-- 配置记住我或认证通过可以访问的地址 --&gt; /index.jsp = user /first.action = user /welcome.jsp = user 都配置完成之后，在浏览器的cookie中查看即可看到cookie信息。附：spring-shiro.xml中所有配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt; &lt;!-- web.xml中shiro的filter对应的bean --&gt; &lt;!-- Shiro 的Web过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由formAuthenticationFilter进行表单认证 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.action&quot; /&gt; &lt;!-- 认证成功统一跳转到first.action，建议不配置，shiro会自动在认证成功后跳转到到上一个请求路径 --&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/first.action&quot;/&gt; &lt;!-- 通过unauthorizedUrl指定没有权限操作时跳转页面--&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/refuse.jsp&quot; /&gt; &lt;!-- 自定义filter配置 --&gt; &lt;property name=&quot;filters&quot;&gt; &lt;map&gt; &lt;!-- 将自定义 的FormAuthenticationFilter注入shiroFilter中 --&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 过滤器链定义，从上向下顺序执行，一般将/**放在最下边 --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &lt;!-- 对静态资源设置匿名访问 --&gt; /images/** = anon /js/** = anon /styles/** = anon &lt;!-- 验证码，可匿名访问 --&gt; /validatecode.jsp = anon &lt;!-- 请求 logout.action地址，shiro去清除session--&gt; /logout.action = logout &lt;!--商品查询需要商品查询权限 ，取消url拦截配置，使用注解授权方式 --&gt; &lt;!-- /item/queryItem.action = perms[item:query] /items/editItems.action = perms[item:edit] --&gt; &lt;!-- 配置记住我或认证通过可以访问的地址 --&gt; /index.jsp = user /first.action = user /welcome.jsp = user &lt;!-- /** = authc 所有url都必须认证通过才可以访问--&gt; /** = authc &lt;!-- /** = anon所有url都可以匿名访问 --&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- securityManager安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;customRealm&quot; /&gt; &lt;!-- 注入缓存管理器 --&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;!-- 注入session管理器 --&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot; /&gt; &lt;!-- 记住我 --&gt; &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt; &lt;/bean&gt;&lt;!-- 自定义realm --&gt;&lt;bean id=&quot;customRealm&quot; class=&quot;com.catchu.ssm.shiro.CustomRealm&quot;&gt; &lt;!-- 将凭证匹配器设置到realm中，realm按照凭证匹配器的要求进行散列 --&gt; &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt;&lt;/bean&gt;&lt;!-- 凭证匹配器 --&gt; &lt;bean id=&quot;credentialsMatcher&quot; class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot; /&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;1&quot; /&gt;&lt;/bean&gt;&lt;!-- 缓存管理器 --&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:shiro-ehcache.xml&quot;/&gt;&lt;/bean&gt;&lt;!-- 会话管理器 --&gt;&lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;!-- session的失效时长，单位毫秒 --&gt; &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;5000&quot;/&gt; &lt;!-- 删除失效的session --&gt; &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt;&lt;!-- 自定义form认证过虑器 --&gt;&lt;!-- 基于Form表单的身份验证过滤器，不配置将也会注册此过虑器，表单中的用户账号、密码及loginurl将采用默认值，建议配置 --&gt;&lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;com.catchu.ssm.shiro.CustomFormAuthenticationFilter &quot;&gt; &lt;!-- 表单中账号的input名称 --&gt; &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot; /&gt; &lt;!-- 表单中密码的input名称 --&gt; &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot; /&gt; &lt;!-- 记住我input的名称 --&gt; &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt; &lt;/bean&gt;&lt;!-- rememberMeManager管理器，写cookie，取出cookie生成用户信息 --&gt; &lt;bean id=&quot;rememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt; &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot; /&gt; &lt;/bean&gt; &lt;!-- 记住我cookie --&gt; &lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;!-- rememberMe是cookie的名字 --&gt; &lt;constructor-arg value=&quot;rememberMe&quot; /&gt; &lt;!-- 记住我cookie生效时间30天 --&gt; &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 代码地址：http://git.oschina.net/catchu/permission-shiro]]></content>
      <categories>
        <category>后台—shiro</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro入门—授权]]></title>
    <url>%2F2017%2F12%2F14%2FShiro%E5%85%A5%E9%97%A8%E2%80%94%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[授权流程 三种授权方式 Shiro 支持三种方式的授权： 编程式：通过写if/else 授权代码块完成： 123456Subject subject = SecurityUtils.getSubject();if(subject.hasRole(“admin”)) &#123; //有权限&#125; else &#123; //无权限&#125; 注解式：通过在执行的Java方法上放置相应的注解完成： 1234@RequiresRoles(&quot;admin&quot;)public void hello() &#123; //有权限&#125; JSP/GSP 标签：在JSP/GSP 页面通过相应的标签完成： 123&lt;shiro:hasRole name=&quot;admin&quot;&gt; &lt;!— 有权限—&gt;&lt;/shiro:hasRole&gt; ​ 授权入门程序 进行授权之前首先要进行上一节学习的认证操作，认证通过之后才能进行授权。授权的单元测试代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @Description 测试角色授权，资源授权 * @Author 刘俊重 * @date 2017年8月3日 * @return void */ @Test public void testAuthorization()&#123; //授权之前需要先进行认证 //创建SecurityManager工厂 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-permission.ini&quot;); //创建SecurityManager SecurityManager securityManager = factory.getInstance(); //将SecurityManager设置到当前页面中 SecurityUtils.setSecurityManager(securityManager); //从SecurityUtils中构建subject（主体） Subject subject = SecurityUtils.getSubject(); //构建token UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;123456&quot;); //提交认证 try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //认证结果 System.out.println(&quot;认证结果：&quot;+subject.isAuthenticated()); //认证通过后执行授权 //基于角色的授权，括号内放的是角色 boolean hasRole = subject.hasRole(&quot;role1&quot;); System.out.println(&quot;单一角色授权：&quot;+hasRole); //如果没有拥有该角色会抛出异常 //subject.checkRole(&quot;role3&quot;); boolean hasAllRoles = subject.hasAllRoles(Arrays.asList(&quot;role1&quot;,&quot;role2&quot;)); System.out.println(&quot;多个角色授权：&quot;+hasAllRoles); //==========分隔符============ //基于资源的授权，括号内放的是权限标识符 boolean permitted = subject.isPermitted(&quot;user:create&quot;); System.out.println(&quot;单个资源的授权：&quot;+permitted); //使用check方法进行授权，如果授权不通过会抛出异常 subject.checkPermission(&quot;user:update&quot;); boolean permittedAll = subject.isPermittedAll(&quot;user:create&quot;,&quot;user:update&quot;); System.out.println(&quot;多个资源的授权：&quot;+permittedAll); &#125; shiro-permission.ini的配置文件如下： 1234567891011121314#用户[users]#用户zhang的密码是123456，此用户具有role1和role2两个角色zhangsan=123456,role1,role2wang=123,role2#权限[roles]#角色role1对资源user拥有create、update权限role1=user:create,user:update#角色role2对资源user拥有create、delete权限role2=user:create,user:delete#角色role3对资源user拥有create权限role3=user:create 权限标识符号规则：资源:操作:实例(中间使用半角冒号分隔) user:create:01 表示对用户资源的01实例进行create操作。 user:create 表示对用户资源进行create操作，相当于user:create:*，对所有用户资源实例进行create操作。 user:*:01 表示对用户资源实例01进行所有操作。 自定义Realm进行授权 在上边的程序中我们通过shiro-permission.ini配置对权限信息进行了静态配置，但是在实际开发中往往需要从数据库中获取权限信息，这时就需要自定义realm，由realm从数据库查询权限数据。realm根据用户身份查询权限数据，将权限数据返回给authorizer（授权器）。 自定义Realm如下（认证信息跟上一节的一样，这里改动的只是授权信息）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.catchu.realm;import java.util.ArrayList;import java.util.List;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * @author 刘俊重 * @Description 自定义Realm * @date 2017年8月1日 */public class CustomRealm extends AuthorizingRealm &#123; /** * @Description 用于授权 * @Author 刘俊重 * @date 2017年8月1日 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; //从principals中获取主身份信息 //将getPrimaryPrincipal方法值强转为真实的身份信息，即在上面认证时填充到SimpleAuthenticationInfo的身份信息 String usercode = (String) principals.getPrimaryPrincipal(); //模拟从数据库中根据身份信息查询到的权限信息（实际开发中这一步是根据身份信息从数据库中查询出来的） List&lt;String&gt; permissions = new ArrayList&lt;String&gt;(); permissions.add(&quot;user:create&quot;);//用户的创建 permissions.add(&quot;items:add&quot;);//商品添加权限 //构建授权信息，并返回 SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); simpleAuthorizationInfo.addStringPermissions(permissions); return simpleAuthorizationInfo; &#125; /** * @Description 用于认证 * @Author 刘俊重 * @date 2017年8月1日 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //从token获取principal（身份信息） String principal = (String) token.getPrincipal(); //模拟从数据库中获取到了credentials（授权信息） String credentials = &quot;111111&quot;; SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(principal, credentials, getName()); return simpleAuthenticationInfo; &#125;&#125; 单元测试代码如下： 12345678910111213141516171819202122232425262728293031323334// 自定义realm进行资源授权测试 @Test public void testAuthorizationCustomRealm() &#123; // 创建SecurityManager工厂 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory( &quot;classpath:shiro-realm.ini&quot;); // 创建SecurityManager SecurityManager securityManager = factory.getInstance(); // 将SecurityManager设置到系统运行环境，和spring后将SecurityManager配置spring容器中，一般单例管理 SecurityUtils.setSecurityManager(securityManager); // 创建subject Subject subject = SecurityUtils.getSubject(); // 创建token令牌 UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;111111&quot;); // 执行认证 try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;认证状态：&quot; + subject.isAuthenticated()); // 认证通过后执行授权 // 基于资源的授权，调用isPermitted方法会调用CustomRealm从数据库查询正确权限数据 // isPermitted传入权限标识符，判断user:create:1是否在CustomRealm查询到权限数据之内 boolean isPermitted = subject.isPermitted(&quot;user:create:1&quot;); System.out.println(&quot;单个权限判断&quot; + isPermitted); boolean isPermittedAll = subject.isPermittedAll(&quot;user:create:1&quot;, &quot;user:create&quot;); System.out.println(&quot;多个权限判断&quot; + isPermittedAll); // 使用check方法进行授权，如果授权不通过会抛出异常 //subject.checkPermission(&quot;items:add:1&quot;); &#125; shiro-realm.ini的配置文件如下： 12345[main]#自定义 realmcustomRealm=com.catchu.realm.CustomRealm#将realm设置到securityManager，相当 于spring中注入securityManager.realms=$customRealm 授权流程文字描述： 对subject进行授权，调用方法isPermitted（”权限标识符”） SecurityManager执行授权，通过ModularRealmAuthorizer执行授权 ModularRealmAuthorizer执行realm（自定义的CustomRealm）从数据库查询权限数据，调用realm的授权方法：doGetAuthorizationInfo realm从数据库查询权限数据，返回ModularRealmAuthorizer ModularRealmAuthorizer调用PermissionResolver进行权限串比对 如果比对后，isPermitted中”权限标识符”在realm查询到权限数据中，说明用户访问permission串有权限，否则没有权限，抛出异常。 ​]]></content>
      <categories>
        <category>后台—shiro</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro入门—认证]]></title>
    <url>%2F2017%2F12%2F14%2FShiro%E5%85%A5%E9%97%A8%E2%80%94%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[什么是shiroshiro是apache的一个开源权限管理框架，实现用户认证、用户授权。spring中有spring security (原名Acegi)，是一个权限框架，它和spring依赖过于紧密，没有shiro使用简单。shiro不依赖于spring，shiro不仅可以实现 web应用的权限管理，还可以实现c/s系统，分布式系统权限管理，shiro属于轻量框架，使用shiro实现系统权限管理，可以有效提高开发效率，降低开发成本。先看一下认证和授权时的关键对象：subject：主体。理解为用户,可能是程序，要去访问系统的资源，系统需要对subject进行身份认证。principal：身份信息。通常是唯一的，一个主体还有多个身份信息，但是都有一个主身份信息（primary principal）credential：凭证信息。可以是密码 、证书、指纹。主体在进行身份认证时需要提供身份信息和凭证信息。 shiro架构subject：主体。可以是用户也可以是程序，主体访问系统，系统对主体进行认证、授权。securityManager：安全管理器。主体进行认证和授权都 是通过securityManager进行。authenticator：认证器。主体进行认证最终通过authenticator进行的。authorizer：授权器。主体进行授权最终通过authorizer进行的。sessionManager：web应用中一般是用web容器（如Tomcat）对session进行管理，shiro也提供了一套session管理的方式。SessionDao： 通过SessionDao管理session数据，针对个性化的session数据存储需要使用sessionDao。cache Manager：缓存管理器。主要对session和授权数据进行缓存，比如将授权数据通过cacheManager进行缓存管理，和ehcache整合对缓存数据进行管理。realm：域，领域。相当于数据源，通过realm存取认证、授权相关数据。注意：在realm中存储授权和认证的逻辑。cryptography：密码管理。提供了一套加密/解密的组件。比如提供常用的散列、加/解密等功能（如Md5）。 shiro认证流程 shiro认证入门程序 123456789101112131415161718192021222324252627282930313233/** * @Description 测试登录登出 * @Author 刘俊重 * @date 2017年8月1日 * @return void */@Testpublic void testLoginAndLogout()&#123; //通过ini配置文件创建SecurityManager工厂 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-first.ini&quot;); //使用SecurityManagerFactory获取SecurityManager对象 SecurityManager securityManager = factory.getInstance(); //将SecurityManager设置在当前运行环境中 SecurityUtils.setSecurityManager(securityManager); //从SecurityUtils中创建一个subject(主体) Subject subject = SecurityUtils.getSubject(); //在认证提交前准备token UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;,&quot;111111&quot;); //提交主体认证 try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //获取认证结果 boolean result = subject.isAuthenticated(); System.out.println(&quot;是否认证通过&quot;+result); //退出操作 subject.logout(); //再次获取认证结果 boolean againResult = subject.isAuthenticated(); System.out.println(&quot;第二次认证结果&quot;+againResult);&#125; 通过shiro-first.ini配置文件创建SecurityManager工厂，配置文件代码如下： 12345#对用户信息进行配置[users]#用户账号和密码 zhangsan=111111lisi=22222 上面程序的执行流程如下：1通过ini配置文件创建securityManager2调用subject.login方法主体提交认证，提交的token3securityManager进行认证，securityManager最终由ModularRealmAuthenticator进行认证。4ModularRealmAuthenticator调用IniRealm(给realm传入token) 去ini配置文件中查询用户信息5IniRealm根据输入的token（UsernamePasswordToken）从 shiro-first.ini查询用户信息，根据账号查询用户信息（账号和密码） 如果查询到用户信息，就给ModularRealmAuthenticator返回用户信息（账号和密码） 如果查询不到，就给ModularRealmAuthenticator返回null6ModularRealmAuthenticator接收IniRealm返回Authentication认证信息 如果返回的认证信息是null，ModularRealmAuthenticator抛出异常（org.apache.shiro.authc.UnknownAccountException） 如果返回的认证信息不是null（说明inirealm找到了用户），对IniRealm返回用户密码 （在ini文件中存在）和 token中的密码 进行对比，如果不一致抛出异常（org.apache.shiro.authc.IncorrectCredentialsException） 自定义Realm实际开发需要realm从数据库中查询用户信息。所以需要自定义Realm。1234567891011121314151617181920212223242526272829303132333435363738package com.catchu.realm;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * @author 刘俊重 * @Description 自定义Realm * @date 2017年8月1日 */public class CustomRealm extends AuthorizingRealm &#123; /** * @Description 用于授权 * @Author 刘俊重 * @date 2017年8月1日 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; return null; &#125; /** * @Description 用于认证 * @Author 刘俊重 * @date 2017年8月1日 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //从token获取principal（身份信息） String principal = (String) token.getPrincipal(); //模拟从数据库中获取到了credentials（授权信息） String credentials = &quot;111111&quot;; SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(principal, credentials, getName()); return simpleAuthenticationInfo; &#125;&#125; 单元测试代码如下：12345678910111213141516171819202122232425262728/** * @Description 测试自定义realm * @Author 刘俊重 * @date 2017年8月1日 * @return void */ @Test public void testCustomRealm()&#123; //生成SecurityManager工厂 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm.ini&quot;); //使用SecurityManager工厂获取SecurityManager SecurityManager securityManager = factory.getInstance(); //将Securitymanager设置在当前运行环境中 SecurityUtils.setSecurityManager(securityManager); //从SecurityUtils中生成subject(主体) Subject subject = SecurityUtils.getSubject(); //在认证前准备token，将来由用户输入 UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;,&quot;111111&quot;); //提交认证 try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //获取授权结果 boolean result = subject.isAuthenticated(); System.out.println(&quot;认证结果：&quot;+result); &#125; shiro-realm.ini配置文件如下：12345[main]#自定义 realmcustomRealm=com.catchu.realm.CustomRealm#将realm设置到securityManager，相当 于spring中注入securityManager.realms=$customRealm 6.md5散列算法和盐实际开发中通常需要对密码进行散列，常用的有md5、sha。建议对md5进行散列时加salt（盐），进行加密相当于对原始密码+盐进行散列。正常使用时散列方法：在程序中对原始密码+盐进行散列，将散列值和盐存储到数据库中。在进行密码对比时，使用相同方法，将输入密码+盐进行散列，与数据库存储的散列值进行比对。1234567891011121314151617181920import org.apache.shiro.crypto.hash.Md5Hash;/** * @author 刘俊重 * @Description md5散列测试 * @date 2017年8月2日 */public class Md5Test &#123; public static void main(String[] args) &#123; //原始密码 String source = &quot;111111&quot;; //盐 String salt = &quot;qwerty&quot;; //散列次数（就是进行了几次md5加密） int hashIterations = 1; //散列一次的值：f3694f162729b7d0254c6e40260bf15c //散列两次的值：36f2dfa24d0a9fa97276abbe13e596fc Md5Hash md5Hash = new Md5Hash(source, salt, hashIterations); System.out.println(&quot;md5散列后的值：&quot;+md5Hash.toString()); &#125;&#125; 7.自定义Realm支持Md5散列自定义Realm如下：12345678910111213141516171819202122232425262728293031323334353637383940414243package com.catchu.realm;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;/** * @author 刘俊重 * @Description 自定义Ream实现md5散列加密 * @date 2017年8月2日 */public class CustomRealmMd5 extends AuthorizingRealm &#123; /** * @Description 用于授权 * @Author 刘俊重 * @date 2017年8月2日 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; // TODO Auto-generated method stub return null; &#125; /** * @Description 用于认证 * @Author 刘俊重 * @date 2017年8月2日 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //从token中获取principal(身份信息)，在这里指的就是用户名 String principal = (String) token.getPrincipal(); //模拟从数据库中获取到了credentials(授权信息)，在这里值的是密码在数据库中的散列值 String credentials = &quot;f3694f162729b7d0254c6e40260bf15c&quot;; //从数据库中获取salt(盐) String salt = &quot;qwerty&quot;; SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(principal, credentials, ByteSource.Util.bytes(salt),getName()); return simpleAuthenticationInfo; &#125;&#125; 单元测试代码如下：12345678910111213141516171819202122232425262728/** * @Description 测试自定义realm，Md5版 * @Author 刘俊重 * @date 2017年8月2日 * @return void */ @Test public void testCustomRealmMd5()&#123; //根据ini配置文件生成SecurityManager工厂类 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm-md5.ini&quot;); //生成SecurityManager（安全管理器） SecurityManager securityManager = factory.getInstance(); //将安全管理器设置在当前运行环境中 SecurityUtils.setSecurityManager(securityManager); //从SecurityUtils中生成subject(主体) Subject subject = SecurityUtils.getSubject(); //在认证前准备token(令牌)，正式环境中由用户输入 UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;,&quot;111111&quot;); //提交认证 try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //是否认证通过 boolean isAuthenticated = subject.isAuthenticated(); System.out.println(&quot;是否认证通过&quot;+isAuthenticated); &#125; 其中生成SecurityManager工厂类的配置文件shiro-realm-md5.ini如下：1234567891011[main]#定义凭证匹配器credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher#散列算法credentialsMatcher.hashAlgorithmName=md5#散列次数credentialsMatcher.hashIterations=1#将凭证匹配器设置到realmcustomRealm=com.catchu.realm.CustomRealmMd5customRealm.credentialsMatcher=$credentialsMatchersecurityManager.realms=$customRealm 8.引入jar上面忘记说了，与其它java开源框架类似，将shiro的jar包加入项目就可以使用shiro提供的功能了。shiro-core是核心包必须选用，还提供了与web整合的shiro-web、与spring整合的shiro-spring、与任务调度quartz整合的shiro-quartz等，下边是shiro各jar包的maven坐标。12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; 也可以通过引入shiro-all包括shiro所有的包：12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; 参考代码：http://download.csdn.net/detail/u014532775/9920343]]></content>
      <categories>
        <category>后台—shiro</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
</search>

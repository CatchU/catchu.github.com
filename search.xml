<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二维数组中查找]]></title>
    <url>%2F2018%2F07%2F02%2F003-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二维数组中查找题目描述 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解决思路 二维数组中最右边的数是一行中最大的数，是一列中最小的数。根据这个规律，如果要查找的数跟最右边的数相等，则查找成功；如果要查找的数比最右边的数小，那么剔除最右边数所在的列；如果要查找的数比最右边的数大，那么剔除最右边数所在的行。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @Author 刘俊重 * @Date 2018/7/1 * 思路：二维数组中最右边的数是一行中最大的数，是一列中最小的数。 * 根据这个规律，如果要查找的数跟最右边的数相等，则查找成功； * 如果要查找的数比最右边的数小，那么剔除最右边数所在的列； * 如果要查找的数比最右边的数大，那么剔除最右边数所在的行。 */public class Main &#123; /** * @param matrix 输入的二维数组 * @param num 要查找的目标数字 * @return 返回是否查找到，true为找到，false为未找到 */ public static boolean find(int[][] matrix,int num)&#123; //数组为空 if(matrix==null || matrix.length==0 || matrix[0].length==0)&#123; return false; &#125; //数组的行号 int rows = matrix.length; //数组的列号 int cols = matrix[0].length; //初始的行号和列号（即第一行最右边的数字） int row = 0; int col = cols-1; //确保在二维数组范围内循环 while(row&gt;=0 &amp;&amp; row&lt;rows &amp;&amp; col&gt;=0 &amp;&amp; col&lt;cols)&#123; if(matrix[row][col] == num)&#123; return true; &#125;else if(matrix[row][col]&gt;num)&#123; col--; &#125;else if(matrix[row][col]&lt;num)&#123; row++; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; int[][] matrix = &#123; &#123;1, 2, 8, 9&#125;, &#123;2, 4, 9, 12&#125;, &#123;4, 7, 10, 13&#125;, &#123;6, 8, 11, 15&#125; &#125;; System.out.println(find(matrix, 7)); // 要查找的数在数组中 System.out.println(find(matrix, 5)); // 要查找的数不在数组中 System.out.println(find(matrix, 1)); // 要查找的数是数组中最小的数字 System.out.println(find(matrix, 15)); // 要查找的数是数组中最大的数字 System.out.println(find(matrix, 0)); // 要查找的数比数组中最小的数字还小 System.out.println(find(matrix, 16)); // 要查找的数比数组中最大的数字还大 System.out.println(find(null, 16)); // 健壮性测试，输入空指针 &#125;&#125; 测试结果1234567truefalsetruetruefalsefalsefalse 补充java中获取二维数组的行数和列数二维数组其实是由一维数组组成，比如12345int[][] arr = &#123; &#123;2,3,4&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125; &#125;; int rows = arr.length;//行数int columns = arr[0].length;//列数这就像从数据库中查出来的数据，都是二维数组，length就是行数，列数是具体到其中的一维里面在求length。]]></content>
      <categories>
        <category>算法—剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F07%2F02%2F002-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式题目描述 设计一个类，我们只能生成该类的一个实例 解决思路 使用单例模式，私有化构造函数，保证只有当前类可调用，对外提供一个public方法，让外部访问生成的实例，使用双检锁保证并发情况下的线程安全。 代码实现1234567891011121314151617181920212223242526272829/** * Author: 刘俊重 * Time: 2018-06-30 */public class Main &#123; /** * 使用双检锁创建线程安全的单例模式 */ public static class Singleton1&#123; private static volatile Singleton1 single = null; private Singleton1()&#123;&#125; public static Singleton1 getSingle()&#123; if(single==null)&#123; synchronized (Singleton1.class)&#123; if(single==null)&#123; single = new Singleton1(); &#125; &#125; &#125; return single; &#125; &#125; public static void main(String[] args) &#123; System.out.println(Singleton1.getSingle()==Singleton1.getSingle()); &#125;&#125; 测试结果1true]]></content>
      <categories>
        <category>算法—剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死磕java底层（二）—消息服务]]></title>
    <url>%2F2017%2F12%2F24%2F%E6%AD%BB%E7%A3%95java%E5%BA%95%E5%B1%82%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[这一节作为上一节多线程的延续，先说一下java原生的阻塞队列（Blocking Queue），之后再说一下JMS（Java Messaging Service，java消息服务）以及它的实现之一ActiveMQ消息队列，所以都归并到消息服务中讨论。 1.阻塞队列（Blocking Queue）BlockingQueue也是java.util.concurrent下的接口，它解决了多线程中如何高效传输数据的问题，通过这些高效并且线程安全的类，我们可以搭建高质量的多线程程序。 主要用来控制线程同步的工具。BlockingQueue是一个接口，里面的方法如下：12345678910111213public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123; boolean add(E e); boolean offer(E e); void put(E e) throws InterruptedException; boolean offer(E e, long timeout, TimeUnit unit); E take() throws InterruptedException; E poll(long timeout, TimeUnit unit) int remainingCapacity(); boolean remove(Object o); public boolean contains(Object o); int drainTo(Collection&lt;? super E&gt; c); int drainTo(Collection&lt;? super E&gt; c, int maxElements);&#125; 插入: add(anObject):把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则抛出异常,不好 offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false. put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续, 有阻塞, 放不进去就等待 读取： poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null; 取不到返回null take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止; 阻塞, 取不到就一直等 其他 int remainingCapacity();返回队列剩余的容量，在队列插入和获取的时候使用，数据可能不准。 boolean remove(Object o); 从队列移除元素，如果存在，即移除一个或者更多，队列改变了返回true public boolean contains(Object o); 查看队列是否存在这个元素，存在返回true int drainTo(Collection&lt;? super E&gt; c); 移除此队列中所有可用的元素,并将它们添加到给定 collection 中。（即取出放到集合中） int drainTo(Collection&lt;? super E&gt; c, int maxElements); 和上面方法的区别在于，指定了移动的数量; （取出指定个数放到集合）主要的方法是：put、take一对阻塞存取；add、poll一对非阻塞存取。上面说了BlockingQueue是一个接口，它有四个具体的实现类,常用的有两个: ArrayBlockingQueue：一个由数组支持的有界阻塞队列，规定大小的BlockingQueue,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的。 LinkedBlockingQueue：大小不定的BlockingQueue，其构造函数中可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE,其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。LinkedBlockingQueue和ArrayBlockingQueue区别：LinkedBlockingQueue和ArrayBlockingQueue比较起来,它们背后所用的数据结构不一样,导致LinkedBlockingQueue的数据吞吐量要大于ArrayBlockingQueue,但在线程数量很大时其性能的可预见性低于ArrayBlockingQueue.下面是是用BlockingQueue实现的生产者和消费者的示例：生产者Product：12345678910111213141516171819public class Product implements Runnable&#123; BlockingQueue&lt;String&gt; queue; public Product(BlockingQueue&lt;String&gt; queue) &#123; //创建对象时就传入一个阻塞队列 this.queue = queue; &#125; @Override public void run()&#123; try &#123; System.out.println(Thread.currentThread().getName()+&quot;开始生产&quot;); String temp = Thread.currentThread().getName()+&quot;：生产线程&quot;; queue.put(temp);//向队列中放数据，如果队列是满的话，会阻塞当前线程 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 消费者Consumer：123456789101112131415161718192021public class Consumer implements Runnable&#123; BlockingQueue&lt;String&gt; queue; public Consumer(BlockingQueue&lt;String&gt; queue) &#123; //使用有参构造函数的目的是我在创建这个消费者对象的时候就可以传进来一个队列 this.queue = queue; &#125; @Override public void run() &#123; Random random = new Random(); try &#123; while(true)&#123; Thread.sleep(random.nextInt(10)); System.out.println(Thread.currentThread().getName()+ &quot;准备消费...&quot;); String temp = queue.take();//从队列中取任务消费，如果队列为空，会阻塞当前线程 System.out.println(Thread.currentThread().getName() + &quot; 获取到工作任务==== &quot; +temp); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 测试类TestQueue：1234567891011121314151617public class TestQueue &#123; public static void main(String[] args) &#123; //新建一个阻塞队列，队列长度是5 BlockingQueue&lt;String&gt; queue = new LinkedBlockingDeque&lt;String&gt;(5); //BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(5); Consumer consumer = new Consumer(queue); Product product = new Product(queue); for(int i = 0;i&lt;3;i++)&#123; new Thread(product,&quot;product&quot;+i).start(); &#125; //for (int i = 0;i&lt;5;i++)&#123; new Thread(consumer,&quot;consumer&quot;).start(); //&#125; &#125;&#125; 整套代码的意思就是初始化一个消息队列，里面放String类型，队列长度是5，使用生产者线程来模拟三个用户发出请求，把用户的请求数据暂时放在BlockingQueue队列里面，随后消费者线程不断的从队列里面取任务进行业务逻辑处理，直到队列里面消费的什么都不剩了。由此可以看出消息队列有两大特点：解耦和削峰填谷。生产者和消费者毛关系没有，生产者往队列里放数据，消费者从队列里取数据，它们都跟队列建立关系，解耦；生产者如果并发量很高也只不过是把数据先放到队列里，消费者可以慢慢吃，实际中不会立马拖垮服务端。参考地址：http://blog.csdn.net/ghsau/article/details/8108292 2.Java消息服务2.1JMS简介JMS即Java消息服务（Java Message Service）用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。JMS是一种与厂商（或者说是平台）无关的 API。类似于JDBC(Java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ等等。 JMS 可以让你通过消息收发服务从一个 JMS 客户机向另一个 JMS客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成；消息主体则携带着应用程序的数据或有效负载。根据有效负载的类型来划分，可以将消息分为几种类型，它们分别携带：简单文本(TextMessage)、可序列化的对象 (ObjectMessage)、属性集合 (MapMessage)、字节流 (BytesMessage)、原始值流 (StreamMessage)，还有无有效负载的消息 (Message)。 2.2JMS的组成JMS由以下元素组成：JMS提供者provider：面向消息中间件的，JMS规范的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。JMS客户：生产或消费基于消息的Java应用程序或对象（即生产者和消费者都统称JMS客户）。JMS生产者：创建并发送消息的JMS客户。JMS消费者：接收消息的JMS客户。JMS消息：可以在JMS客户之间传递数据的对象JMS队列：一个容纳被发送的正在等待阅读的消息的区域。一个消息如果被阅读，它将被从队列中移走。JMS主题：一种支持发送消息给多个订阅者的机制。 2.3Java消息服务模型 点对点模型在点对点队列模型下，一个生产者向一个特定的队列发布消息，一个消费者从该队列中读取消息。这里，生产者知道消费者的队列，并直接将消息发送到消费者的队列。这种模式有如下特点：只有一个消费者将获得消息；生产者不需要消费者在消费该消息期间处于运行状态，消费者也同样不需要在生产者在发送消息时处于运行状态；每一个成功处理的消息都由消费者者签收。 发布者/订阅者模型发布者/订阅者模型支持向一个特定的消息主题发布消息。在这种模型下，发布者和订阅者彼此不知道对方，类似于匿名公告板。这种模式有如下特点：多个消费者可以获得消息；在发布者和订阅者之间存在时间依赖性。发布者需要建立一个订阅（subscription），以便消费者能够订阅。订阅者必须保持持续的活动状态以接收消息，除非订阅者建立了持久的订阅。2.4消息队列（ActiveMQ）ActiveMQ是JMS规范的一种实现，下面说如何使用 下载ActiveMQ去官方网站下载：http://activemq.apache.org/ 运行ActiveMQ解压apache-activemq-5.5.1-bin.zip（类似于Tomcat，解压即可用），我在网上搜的有的人修改了配置文件activeMQ.xml中连接的地址和协议，我在测试时没有修改也可以测试成功，如果你测试不成功可以修改如下：1234567&lt;transportConnectors&gt; &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://localhost:61616&quot;/&gt; &lt;transportConnector name=&quot;ssl&quot; uri=&quot;ssl://localhost:61617&quot;/&gt; &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://localhost:61613&quot;/&gt; &lt;transportConnector uri=&quot;http://localhost:8081&quot;/&gt; &lt;transportConnector uri=&quot;udp://localhost:61618&quot;/&gt;&lt;/transportConnectors&gt; 测试代码如下：生产者Product：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Product &#123; private String username = ActiveMQConnectionFactory.DEFAULT_USER; private String password = ActiveMQConnectionFactory.DEFAULT_PASSWORD; private String url = ActiveMQConnectionFactory.DEFAULT_BROKER_URL; private Connection connection = null; private Session session = null; private String subject = &quot;myQueue&quot;; private Destination destination = null; private MessageProducer producer = null; /** * @Description 初始化方法 * @Author 刘俊重 * @Date 2017/12/20 */ private void init() throws JMSException &#123; ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(username,password,url); connection = connectionFactory.createConnection(); session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(subject); producer = session.createProducer(destination); producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); &#125; public void productMessage(String message) throws JMSException &#123; this.init(); TextMessage textMessage = session.createTextMessage(message); connection.start(); System.out.println(&quot;生产者准备发送消息：&quot;+textMessage); producer.send(textMessage); System.out.println(&quot;生产者已发送完毕消息。。。&quot;); &#125; public void close() throws JMSException &#123; System.out.println(&quot;生产者开始关闭连接&quot;); if(null!=producer)&#123; producer.close(); &#125; if(null!=session)&#123; session.close(); &#125; if(null!=connection)&#123; connection.close(); &#125; &#125;&#125; 消费者Consumer：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Consumer implements MessageListener,ExceptionListener&#123; private String name = ActiveMQConnectionFactory.DEFAULT_USER; private String password = ActiveMQConnectionFactory.DEFAULT_PASSWORD; private String url = ActiveMQConnectionFactory.DEFAULT_BROKER_URL; private ActiveMQConnectionFactory connectionFactory = null; private Connection connection = null; private Session session = null; private String subject = &quot;myQueue&quot;; private Destination destination = null; private MessageConsumer consumer = null; public static Boolean isconnection=false; /** * @Description 连接ActiveMQ * @Author 刘俊重 * @Date 2017/12/20 */ private void init() throws JMSException &#123; connectionFactory = new ActiveMQConnectionFactory(name,password,url); connection = connectionFactory.createConnection(); session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(subject); consumer = session.createConsumer(destination); &#125; public void consumerMessage() throws JMSException &#123; this.init(); connection.start(); //设置消息监听和异常监听 consumer.setMessageListener(this); connection.setExceptionListener(this); System.out.println(&quot;消费者开始监听....&quot;); isconnection = true; //Message receive = consumer.receive(); &#125; public void close() throws JMSException &#123; if(null!=consumer)&#123; consumer.close(); &#125; if(null!=session)&#123; session.close(); &#125; if(null!=connection)&#123; connection.close(); &#125; &#125; /** * 异常处理函数 */ @Override public void onException(JMSException exception) &#123; //发生异常关闭连接 isconnection = false; &#125; /** * 消息处理函数 */ @Override public void onMessage(Message message) &#123; try &#123; if(message instanceof TextMessage)&#123; TextMessage textMsg = (TextMessage) message; String text = textMsg.getText(); System.out.println(&quot;消费者接收到的消息=======&quot;+text); &#125;else &#123; System.out.println(&quot;接收的消息不符合&quot;); &#125; &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意：消费者需要实现MessageListener和ExceptionListener来监听收到消息和出错时的处理。生产者测试类TestProduct：123456789public class TestProduct &#123; public static void main(String[] args) throws JMSException &#123; for(int i=0;i&lt;100;i++)&#123; Product product = new Product(); product.productMessage(&quot;Hello World!&quot;+i); product.close(); &#125; &#125;&#125; TestProduct是用来模拟生成100条消息，写入到ActiveMQ队列中。消费者测试类TestConsumer：123456789101112131415161718192021222324252627282930public class TestConsumer implements Runnable &#123; static Thread thread = null; public static void main(String[] args) throws InterruptedException &#123; thread = new Thread(new TestConsumer()); thread.start(); while (true)&#123; //时刻监听消息队列，如果线程死了，则新建一个线程 boolean alive = thread.isAlive(); System.out.println(&quot;当前线程状态：&quot;+alive); if(!alive)&#123; thread = new Thread(new TestConsumer()); thread.start(); System.out.println(&quot;线程重启完成&quot;); &#125; Thread.sleep(1000); &#125; &#125; @Override public void run() &#123; try &#123; Consumer consumer = new Consumer(); consumer.consumerMessage(); while (Consumer.isconnection) &#123; //System.out.println(123); &#125; &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; TestConsumer这里用了多线程，保证时刻有个线程活着等着接收ActiveMQ的消息队列并调用消费者处理。总结：我的理解是线程间通信使用queue，如BlockingQueue，进程间通信使用JMS，如ActiveMQ。另附上一篇将58架构师沈剑老师写的消息队列的文章，可以作为参考：http://dwz.cn/78yLxL需要强调的是任何一项技术的引用都要为解决业务问题服务，而不能是单纯的炫技。举个例子，就拿消息服务来说，比如用户注册某个网站，注册完了之后我要调用邮件和短信服务给他发通知，我可能还要通过他填的信息，给他推荐一下可能认识的用户，那么这里核心业务是注册，其它的发通知和推荐用户就可以放在消息队列里处理，先响应注册信息，随后调用其它服务来处理发通知和推荐用户这两个业务。但是网站前期可能用户量比较少，不用消息队列就能满足我的需求了，引用消息队列反而会增加项目的复杂性，所以新技术的使用一定是需要解决业务的问题，而不是单纯的炫技。参考文档：http://blog.csdn.net/fanzhigang0/article/details/43764121http://blog.csdn.net/u010702229/article/details/18085263]]></content>
      <categories>
        <category>后台—java基础</category>
      </categories>
      <tags>
        <tag>消息服务</tag>
        <tag>BlockingQueue</tag>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死磕java底层（一）—多线程]]></title>
    <url>%2F2017%2F12%2F20%2F%E6%AD%BB%E7%A3%95java%E5%BA%95%E5%B1%82%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.线程和进程1.1线程和进程的区别 进程它是内存中的一段独立的空间，可以负责当前应用程序的运行。当前这个进程负责调度当前程序中的所有运行细节（操作系统为进程分配一块独立的运行空间）； 线程它是位于进程中，负责当前进程中的某个具备独立运行资格的空间（进程为线程分配一块独立运行的空间）；进程是负责某个程序的执行，线程是负责进程中某个独立功能的运行，一个进程至少要包含一个线程。 多线程在一个进程中可以开启多个线程，让多个线程同时去完成某项任务。使用多线程的目的是为了提高程序的执行效率。1.2线程运行状态 通过Thread类或Runnable接口创建线程对象之后进入初始状态；调用start方法进入可运行状态（就绪状态），此时并不是真正的运行，只是代表已经做好了运行前的各项装备；如果此线程获取到cpu的时间片，则进入到真正的可运行状态，执行run方法里面的业务逻辑；如果run方法执行完毕或调用stop方法则线程运行结束，进入死亡状态；在运行状态时调用不同方法也会进入其他不同状态，如果调用强制运行方法join或休眠方法将进入等待状态，时间到后自动进入就绪状态，随时准备获取cpu时间片；如果看到synchronized则进入同步队列等待状态，或者如果调用了wait方法则进入等待状态，等待状态的线程必须要通过notify唤醒才可进入等待状态，如果其它线程执行完毕，本线程拿到同步锁则进入就绪状态，等待获取cpu时间片。某个线程是否会执行只能看它能否争抢到cpu时间片，但是通过调高优先级来让线程更大概率的被优先执行。参考文档：https://mp.weixin.qq.com/s?src=11&amp;timestamp=1513562547&amp;ver=581&amp;signature=30FEkCCQvF3E1tt67vYVym5tRNsSk3d8HGe0v9TAonJmhLh4-53fDEBbgwNF*Olgp5rAlGFAJQXYnviaFRwiQ9NmbtIWnZGpot*GcuV0Ok*3WzWxg4X6e2mxU0JrgbRb&amp;new=1 2.多线程多线程运行的原理是：cpu在线程中做时间片的切换。cpu负责程序的执行，在每个时间点它其实只能运行一个程序而不是多个程序，不停的在多个程序之间高速切换，而一个程序其实就是一个进程即多个线程，说到底其实就是cpu在多个线程之间不停的做高速切换，而开多个线程就是不让cpu歇着，最大程度的压榨它来为程序服务。实现多线程有三种方式：继承Thread类；实现Runnable接口；使用线程池。 2.1继承Thread类1234567891011121314151617181920212223242526272829303132public class MyExtendsThread extends Thread &#123; String flag; public MyExtendsThread(String flag)&#123; this.flag = flag; &#125; @Override public void run()&#123; String name = Thread.currentThread().getName(); System.out.println(&quot;线程&quot;+name+&quot;开始工作了...&quot;); Random random = new Random(); for (int i = 0;i &lt; 20;i++)&#123; try &#123; Thread.sleep(random.nextInt(10)*100); System.out.println(name+&quot;=============&quot;+flag); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread t0 = new MyExtendsThread(&quot;t0&quot;); Thread t1 = new MyExtendsThread(&quot;t1&quot;); t0.start(); t1.start();// t0.run();// t1.run(); &#125;&#125; 调用线程要用start方法，而不是run方法，使用run方法只是调用方法，实际执行的还是Main线程，而调用start方法可以明显的看到线程争抢。 2.2实现Runnable接口12345678910111213141516171819202122232425262728293031public class MyThreadImplementRunnable implements Runnable &#123; int x; public MyThreadImplementRunnable(int x) &#123; this.x = x; &#125; @Override public void run() &#123; String name = Thread.currentThread().getName(); System.out.println(&quot;线程&quot;+name+&quot;开始执行&quot;); Random random = new Random(); for(int i = 0;i&lt;20;i++)&#123; try &#123; Thread.sleep(random.nextInt(10)*100); System.out.println(name+&quot;=============&quot;+x); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(new MyThreadImplementRunnable(1),&quot;线程1&quot;); Thread t2 = new Thread(new MyThreadImplementRunnable(2),&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; 2.3实现Callable接口 创建实现Callable接口的类MyThreadImplementCallable； 创建一个类对象：MyThreadImplementCallable callable = new MyThreadImplementCallable(“测试”); 由Callable创建一个FutureTask对象：FutureTask futureTask = new FutureTask(callable);注意：FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了Future和Runnable接口。 由FutureTask创建一个Thread对象：Thread thread = new Thread(futureTask); 启动线程：thread.start(); 获取任务线程执行结果futureTask.get()；注意：实现Callable接口的线程可以获得任务线程的执行结果；实现Runnable接口的线程无法获取任务线程执行的结果。1234567891011121314151617181920212223242526public class MyThreadImplementCallable implements Callable&lt;String&gt; &#123; String name; public MyThreadImplementCallable(String name) &#123; this.name = name; &#125; @Override public String call() throws Exception &#123; Thread thread = Thread.currentThread(); System.out.println(thread.getName()+&quot;开始工作==============&quot;); Random random = new Random(); Thread.sleep(random.nextInt(5)*100); //模拟执行业务 return name+&quot;:执行完成&quot;; &#125; public static void main(String[] args) throws Exception&#123; MyThreadImplementCallable callable = new MyThreadImplementCallable(&quot;测试&quot;); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(callable); Thread thread = new Thread(futureTask); thread.start(); String result = futureTask.get(); //获取任务线程执行结果 System.out.println(&quot;线程的执行结果：&quot;+result); &#125;&#125; 2.4使用线程池见下面的线程池专讲。参考文档：https://www.cnblogs.com/langtianya/archive/2013/03/14/2959713.html 3.同步3.1synchronized关键字1234567891011121314151617181920212223242526272829303132public class MySynchronized &#123; public static void main(String[] args)&#123; final MySynchronized synchronized1 = new MySynchronized(); final MySynchronized synchronized2 = new MySynchronized(); new Thread(&quot;thread1&quot;)&#123; @Override public void run()&#123; synchronized (synchronized1)&#123; try &#123; System.out.println(this.getName()+&quot;:start&quot;); Thread.sleep(1000); System.out.println(this.getName()+&quot;:wake up&quot;); System.out.println(this.getName()+&quot;:end&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); new Thread(&quot;thread2&quot;)&#123; @Override public void run() &#123; synchronized (synchronized1)&#123; //争抢同一把锁时，线程1没释放之前，线程2只能等待// synchronized (synchronized2)&#123; //如果不是一把锁，可以看到两句话交叉打印，发生争抢 System.out.println(this.getName()+&quot;:start&quot;); System.out.println(this.getName()+&quot;:end&quot;); &#125; &#125; &#125;.start(); &#125;&#125; synchronized是java中的关键字，属于java语言的内置特性。如果一个代码块使用synchronized修饰，则这块代码是同步的，当一个线程获取到这个锁并且开始执行时，其它线程只能一直眼睁睁的等着这个线程执行然后释放锁，其中释放锁只有两种原因：1.线程正常执行完毕；2.线程执行时发生异常，jvm自动将锁释放。可以看到使用synchronized关键字之后每个时刻只会有一个线程执行代码块里面的共享代码，线程安全；缺点也很明显，其它线程只能等锁释放，资源浪费严重。 3.2Lock接口 lock和synchronized的区别：Lock不是Java语言内置的，它是一个接口，通过这个接口可以实现同步访问，synchronized是Java语言的关键字，是内置特性；Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。Lock是一个接口，它里面有如下方法：1234567public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock();&#125; lock()、tryLock()、tryLock(long time, TimeUnit unit)、lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。 lock就是用来获取锁的，前面说到如果采用Lock，必须主动去释放锁。即使发生异常，程序也不会自动释放锁，因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyLock &#123; private static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); private static Lock lock = new ReentrantLock(); public static &lt;E&gt; void main(String[] args) &#123; new Thread() &#123; @Override public void run() &#123; Thread thread = Thread.currentThread(); lock.lock(); //获取锁 try &#123; System.out.println(thread.getName() + &quot;得到了锁&quot;); for (int i = 0; i &lt; 5; i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; System.out.println(thread.getName() + &quot;释放了锁&quot;); lock.unlock(); //释放锁 &#125; &#125;; &#125;.start(); new Thread() &#123; @Override public void run() &#123; Thread thread = Thread.currentThread(); lock.lock(); try &#123; System.out.println(thread.getName() + &quot;得到了锁&quot;); for (int i = 0; i &lt; 5; i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; System.out.println(thread.getName() + &quot;释放了锁&quot;); lock.unlock(); &#125; &#125;; &#125;.start(); &#125;&#125; tryLock()表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回，在拿不到锁时不会一直等待。 tryLock(long time, TimeUnit unit)方法和tryLock()方法类似，区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果一开始就拿到锁或者在等待期间内拿到了锁，则返回true。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//观察现象：一个线程获得锁后，另一个线程取不到锁，不会一直等待public class MyTryLock &#123; private static List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); private static Lock lock = new ReentrantLock(); public static void main(String[] args) &#123; new Thread(&quot;线程1&quot;) &#123; @Override public void run() &#123; Thread thread = Thread.currentThread(); boolean tryLock = lock.tryLock(); System.out.println(thread.getName()+&quot;=======&quot;+tryLock); if(tryLock)&#123; try &#123; System.out.println(thread.getName() + &quot;得到了锁&quot;); for(int i = 0;i &lt; 20;i++)&#123; arrayList.add(i); &#125; Thread.sleep(1000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); System.out.println(thread.getName() + &quot;释放了锁&quot;); &#125; &#125; &#125; &#125;.start(); new Thread(&quot;线程2&quot;) &#123; @Override public void run() &#123; Thread thread = Thread.currentThread(); boolean tryLock = lock.tryLock(); System.out.println(thread.getName()+&quot;=======&quot;+tryLock); if(tryLock)&#123; try &#123; System.out.println(thread.getName() + &quot;得到了锁&quot;); for(int i = 0;i &lt; 20;i++)&#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); System.out.println(thread.getName() + &quot;释放了锁&quot;); &#125; &#125; &#125; &#125;.start(); &#125;&#125; 线程1和线程2共享成员变量arrayList，当线程1获取锁的时候，线程2就获取不到锁，没办法执行它的业务逻辑，只有等线程1执行完毕，释放了锁，线程2才能获取锁，执行它的代码，进而保证了线程安全。 lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以中断的。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。 Lock接口的实现类——ReentrantLock直接使用lock接口的话，我们需要实现很多方法，不方便，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，ReentrantLock，意思是“可重入锁”，使用它可以创建Lock对象。 ReadWriteLock也是一个接口，在它里面只定义了两个方法：1234public interface ReadWriteLock &#123; Lock readLock(); Lock writeLock();&#125; 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。 ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁，使用这个读写锁操作的结果就是：要么执行的全是读操作，结束完之后全执行写操作，中间不会交叉读写。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @author 刘俊重 * 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。 * 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 */public class MyReentrantReadWriteLock &#123; ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock(); public static void main(String[] args) &#123; final MyReentrantReadWriteLock myTest = new MyReentrantReadWriteLock(); new Thread(&quot;线程1&quot;)&#123; @Override public void run()&#123; myTest.read(Thread.currentThread()); myTest.writer(Thread.currentThread()); &#125; &#125;.start(); new Thread(&quot;线程2&quot;)&#123; @Override public void run()&#123; myTest.read(Thread.currentThread()); myTest.writer(Thread.currentThread()); &#125; &#125;.start(); &#125; /** * @Description 读方法 * @Author 刘俊重 * @Date 2017/12/18 */ private void read(Thread thread)&#123; readWriteLock.readLock().lock(); try &#123; long start = System.currentTimeMillis(); while (System.currentTimeMillis()-start&lt;=1)&#123; System.out.println(thread.getName()+&quot;===正在执行读操作&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.readLock().unlock(); System.out.println(thread.getName()+&quot;==释放读锁&quot;); &#125; &#125; /** * @Description 写方法 * @Author 刘俊重 * @Date 2017/12/18 */ private void writer(Thread thread)&#123; readWriteLock.writeLock().lock(); try &#123; long start = System.currentTimeMillis(); while (System.currentTimeMillis()-start&lt;=1)&#123; System.out.println(thread.getName()+&quot;===正在执行写操作&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.writeLock().unlock(); System.out.println(thread.getName()+&quot;==释放写锁&quot;); &#125; &#125;&#125; Lock和Synchronized的选择： Lock是一个接口，而sysnchrinized是java关键字，属于内置的语言实现； synchronized关键字程序运行完成之后或出现异常时会释放锁，使用lock不会自动释放锁，只能自己使用unlock释放，否则会引起死锁，最好在finally中释放； 使用lock可以使用trylock方法判断有没有获得锁，使用synchronized无法判断； 使用lock可以让等待锁的线程中断，使用synchronized无法让线程中断，只能一直等待下去； 使用lock可以提高多线程读操作的效率。结论：如果竞争的资源不激烈，则使用synchronized和lock效率差不多；如果有大量线程同时竞争，则lock要远远优于synchronized。4.volatile关键字程序执行时有主内存，每个线程工作时也有自己的工作内存。当一个线程开始工作时会从主内存中拷贝一个变量的副本到工作内存中，在工作内存中操作完副本时再更新回主内存。当存在多线程时，如果工作内存A处理完还没来得及更新回主内存之前，工作内存B就从主内存中拉取了这个变量，那么很明显这个变量并不是最新的数据，会出现问题。怎么解决呢？可以使用volatile,volatile有个最显著的特性就是对它所修饰变量具有可见性，什么意思呢，就是当一个线程修改了变量的值，新的值会立刻（马上）同步到主内存中，其它线程使用时拉取到的就是最新的变量值。尽管volatile能保证变量的可见性，但并不能保证线程安全，因为它不能保证原子性。要想线程安全还是要用同步或者锁。有一篇文档写volatile写的很好，贴一下：http://dwz.cn/76TMGW5.线程池JDK1.5之后引入了高级并发特性，在java.util.concurrent包中，是专门用于多线程并发编程的，充分利用了现代计算机多处理器和多核心的功能以编写大规模并发应用程序。主要包含原子量、并发集合、同步器、可重入锁，并对线程池的创建提供了强力的支持。5.1线程池的5种创建方式 Single Thread Executor : 只有一个线程的线程池，所有提交的任务都是顺序执行；代码： Executors.newSingleThreadExecutor() Cached Thread Pool : 线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，如果线程超过60秒内没执行，那么将被终止并从池中删除；代码：Executors.newCachedThreadPool() Fixed Thread Pool : 拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，代码： Executors.newFixedThreadPool(4)在构造函数中的参数4是线程池的大小，你可以随意设置，最好设置成和cpu的核数量保持一致，获取cpu的核数量int cpuNums = Runtime.getRuntime().availableProcessors(); Scheduled Thread Pool : 用来调度即将执行的任务的线程池，可能不是直接执行, 每隔多久执行一次，属于策略型的。代码：Executors.newScheduledThreadPool() Single Thread Scheduled Pool : 只有一个线程，用来调度任务在指定时间执行，代码：Executors.newSingleThreadScheduledExecutor()示例代码如下：123456789public static void main(String[] args) &#123; ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor(); ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); //获取cpu核心数 int num = Runtime.getRuntime().availableProcessors(); ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(num); ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(8); ScheduledExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();&#125; 5.2线程池的使用说到线程池使用之前再强调一下Runnable的孪生兄弟——Callable，他们两个很像，只是Runnable的run方法不会有任何返回结果，主线程无法获得任务线程的返回值；但是Callable的call方法可以返回结果，但是主线程在获取时是被阻塞，需要等待任务线程返回才能拿到结果，所以Callable比Runnable更强大，那么怎么获取到这个执行结果呢？答案是Future，使用Future可以获取到Callable执行的结果。现在开始说线程池怎么使用，也有两种方式，一种Runnable的，一种Callable的: 提交 Runnable ，任务完成后 Future 对象返回 null，调用excute,提交任务, 匿名Runable重写run方法, run方法里是业务逻辑。示例代码： 123456789101112131415public class TestPoolWithRunnable &#123; public static void main(String[] args) throws Exception&#123; ExecutorService pool = Executors.newFixedThreadPool(4); for (int i=0;i&lt;10;i++)&#123; Future&lt;?&gt; submit = pool.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;开始执行&quot;); &#125; &#125;); System.out.println(&quot;执行结果：&quot;+submit.get()); //所有的执行结果全是null &#125; pool.shutdown(); //关闭线程池 &#125;&#125; 提交 Callable，该方法返回一个 Future 实例表示任务的状态，调用submit提交任务, 匿名Callable,重写call方法, 有返回值, 获取返回值会阻塞,一直要等到线程任务返回结果。 12345678910111213141516171819202122232425/** * @author 刘俊重 * Callable 跟Runnable的区别： * Runnable的run方法不会有任何返回结果，所以主线程无法获得任务线程的返回值 * Callable的call方法可以返回结果，但是主线程在获取时是被阻塞，需要等待任务线程返回才能拿到结果 */public class TestPoolWithCallable &#123; public static void main(String[] args) throws Exception&#123; ExecutorService pool = Executors.newFixedThreadPool(4); for(int i=0;i&lt;10;i++)&#123; Future&lt;String&gt; future = pool.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; Thread.sleep(500); return &quot;====&quot;+Thread.currentThread().getName(); &#125; &#125;); //从Future中get结果，这个方法是会被阻塞的，一直要等到线程任务返回结果 System.out.println(&quot;执行结果：&quot;+future.get()); &#125; pool.shutdown(); &#125;&#125; 如何解决获取执行结果阻塞的问题？在使用future.get()方法获取结果时，这个方法是阻塞的，怎么提高效率呢？如果在不要求立马拿到执行结果的情况下，可以先将执行结果放在队列里面，待程序执行完毕之后在获取每个线程的执行结果，示例代码如下：123456789101112131415161718192021222324252627public class TestThreadPool &#123; public static void main(String[] args) throws Exception&#123; Future&lt;?&gt; submit = null; //创建缓存线程池 ExecutorService cachePool = Executors.newCachedThreadPool(); //用来存在Callable执行结果 List&lt;Future&lt;?&gt;&gt; futureList = new ArrayList&lt;Future&lt;?&gt;&gt;(); for(int i = 0;i&lt;10;i++)&#123; //cachePool提交线程，Callable，Runnable无返回值 //submit = cachePool.submit(new TaskCallable(i)); submit = cachePool.submit(new TaskRunnable(i)); //把这些执行结果放到list中，后面再取可以避免阻塞 futureList.add(submit); &#125; cachePool.shutdown(); //打印执行结果 for(Future f : futureList)&#123; boolean done = f.isDone(); System.out.println(done?&quot;已完成&quot;:&quot;未完成&quot;); System.out.println(&quot;线程返回结果：&quot;+f.get()); &#125; &#125;&#125; 把submit放在list集合中，线程直线完毕之后再取。 6.java并发编程总结6.1不使用线程池的缺点直接使用new Thread().start()的方式，对于一般场景是没问题的，但如果是在并发请求很高的情况下，就会有隐患： 新建线程的开销。线程虽然比进程要轻量许多，但对于JVM来说，新建一个线程的代价还是很大的，决不同于新建一个对象。 资源消耗量。没有一个池来限制线程的数量，会导致线程的数量直接取决于应用的并发量。 稳定性。当线程数量超过系统资源所能承受的程度，稳定性就会成问题。6.2线程池的类型不管是通过Executors创建线程池，还是通过Spring来管理，都得知道有哪几种线程池： FixedThreadPool：定长线程池，提交任务时创建线程，直到池的最大容量，如果有线程非预期结束，会补充新线程； CachedThreadPool：可变线程池，它犹如一个弹簧，如果没有任务需求时，它回收空闲线程，如果需求增加，则按需增加线程，不对池的大小做限制； SingleThreadExecutor：单线程。处理不过来的任务会进入FIFO队列等待执行； SecheduledThreadPool：周期性线程池。支持执行周期性线程任务其实，这些不同类型的线程池都是通过构建一个ThreadPoolExecutor来完成的，所不同的是corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory这么几个参数。6.3线程池饱和策略由以上线程池类型可知，除了CachedThreadPool其他线程池都有饱和的可能，当饱和以后就需要相应的策略处理请求线程的任务，比如，达到上限时通过ThreadPoolExecutor.setRejectedExecutionHandler方法设置一个拒绝任务的策略，JDK提供了AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy几种策略。]]></content>
      <categories>
        <category>后台—java基础</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
        <tag>锁</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式协调服务zookeeper总结]]></title>
    <url>%2F2017%2F12%2F15%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.zookeeper简介1.1简介Zookeeper是一个分布式协调服务，换言之，就是为用户的分布式应用程序提供协调服务 zookeeper是为别的分布式程序服务的 Zookeeper本身就是一个分布式程序（只要有半数以上节点存活，zk就能正常服务） Zookeeper所提供的服务涵盖：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统一名称服务 虽然说可以提供各种服务，但是zookeeper在底层其实只提供了两个功能（管理数据和监听数据）：管理(存储，读取)用户程序提交的数据；并为用户程序提供数据节点监听服务；1.2 Zookeeper集群的角色： Leader 和 followerZookeeper在配置文件中并没有指定master和slave，启动之后通过内部的选举机制选举出leader和follower，而且只有一个leader，其他则为follower。zookeeper集群中只要有半数以上节点存活，集群就能提供服务。2.zookeeper集群机制半数机制：集群中半数以上机器存活，集群可用。zookeeper适合装在奇数台机器上！！！2.zookeeper安装与配置2.1zookeeper安装 安装到3台虚拟机上（需要提前安装好JDK）将zookeeper压缩包上传至/apps/package目录并解压 1tar -zxvf zookeeper-3.4.5.tar.gz 重命名 1mv zookeeper-3.4.5 zookeeper（重命名文件夹zookeeper-3.4.5为zookeeper） 修改环境变量 1234vi /etc/profile添加内容：export ZOOKEEPER_HOME=/apps/package/zookeeperexport PATH=$PATH:$JAVA_HOME/bin:$ZOOKEEPER_HOME/bin 重新编译文件：source /etc/profile三台机器都需要修改 2.2 修改配置文件 先复制一份cd zookeeper/confcp zoo_sample.cfg zoo.cfg 编辑vi zoo.cfg 123456添加内容：dataDir=/apps/package/zookeeper/datadataLogDir=/apps/package/zookeeper/logserver.1=mini1:2888:3888server.2=mini2:2888:3888server.3=mini3:2888:3888 创建文件夹： 123cd /apps/package/zookeepermkdir -m 755 datamkdir -m 755 log 在data文件夹下新建myid文件，myid的文件内容为： 1234cd datavi myid添加内容：1 mini2和mini3服务器的请修改成2,3，将来会按这个myid选中出leader和follow。 将集群复制到其他机器上12scp -r /apps/package/zookeeper root@mini2:/apps/package/scp -r /apps/package/zookeeper root@mini3:/apps/package/ 如果在mini1中ping不通mini2和mini3,需要在hosts文件中配置mini2和mini3的ip地址 修改其他机器的配置文件到mini2上：修改myid为：2到mini3上：修改myid为：3而且/etc/profile的路径也不要忘了修改 启动（每台机器） 12zkServer.sh startzkServer.sh start-foreground(可以看到启动日志) 查看集群状态 12jps（查看进程）zkServer.sh status（查看集群状态，主从信息） 如果报端口占用，参考下面链接解决：http://blog.csdn.net/u014686180/article/details/51767863 3.zookeeper数据结构和常用操作3.1zookeeper特性 Zookeeper：一个leader，多个follower组成的集群 全局数据一致：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的 分布式读写，更新请求转发，由leader实施 更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行 数据更新原子性，一次数据更新要么成功，要么失败 实时性，在一定时间范围内，client能读到最新数据3.2zookeeper数据结构 层次化的目录结构; 每个节点在zookeeper中叫做znode,并且其有一个唯一的路径标识; 节点Znode可以包含数据和子节点（但是EPHEMERAL类型的节点不能有子节点）; 客户端应用可以在节点上设置监视器。3.3节点类型 Znode有两种类型：短暂（ephemeral）（断开连接自己删除）持久（persistent）（断开连接不删除） Znode有四种形式的目录节点（默认是persistent ）PERSISTENTPERSISTENT_SEQUENTIAL（持久序列/test0000000019 ）EPHEMERALEPHEMERAL_SEQUENTIAL 创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护 在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序3.4使用客户端操作节点 使用命令连接zookeeper服务端： 12zkCli.sh -主机名(ip):2181如：zkCli.sh -mini2:2181 使用 ls 命令来查看当前 ZooKeeper 中所包含的内容： 1 ls / 创建一个新的 znode ，使用 create /zk myData 。这个命令创建了一个新的 znode 节点“ zk ”以及与它关联的字符串： 1create /zk &quot;myData“ 我们运行 get 命令来确认 znode 是否包含我们所创建的字符串： 1get /zk -监听这个节点的变化,当另外一个客户端改变/zk时,输出监听到的变化1get /zk watch 使用set 命令来对 zk 所关联的字符串进行设置： 1set /zk &quot;zsl“ 使用delete删除 znode 节点： 1delete /zk 删除节点(与上面的区别是这个可以删除目录)：rmr 1rmr /zk 参考文档：http://www.cnblogs.com/likehua/tag/zookeeper/ 4.使用java操作zookeeper的api 首先需要引入zookeeper的jar包，这个jar包需要依赖其它的jar，可以直接到maven仓库下载。 123456&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.10&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 常用的增删查改api操作如下：create 在目录树中创建一个节点delete 删除一个节点exists 测试是否存在目标节点get/set data 从目标节点上读取 / 更新数据get/set ACL 获取 / 设置目标节点访问控制列表信息get children 检索一个子节点上的列表sync 等待要被传送的数据使用java操作代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class SimpleZkClient &#123; private static final String CONNECT_URL = &quot;mini1:2181,mini2:2181,mini3:2181&quot;; private static final int SESSION_TIME_OUT = 2000; ZooKeeper zkCli = null; @Before public void init() throws Exception&#123; zkCli = new ZooKeeper(CONNECT_URL, SESSION_TIME_OUT, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; System.out.println(event.getType()+&quot;-----------&quot;+event.getPath()); try&#123; zkCli.getChildren(&quot;/&quot;, true); &#125;catch (Exception e)&#123; &#125; &#125; &#125;); &#125; /** * @Description 添加节点数据 * @Author 刘俊重 */ @Test public void create() throws Exception&#123; // 参数1：要创建的节点的路径 参数2：节点大数据 参数3：节点的权限 参数4：节点的类型。上传的数据可以是任何类型，但都要转成byte[] String s = zkCli.create(&quot;/zk&quot;, &quot;test&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); &#125; /** * @Description 判断节点是否存在 * @Author 刘俊重 */ @Test public void isExist() throws Exception&#123; Stat exists = zkCli.exists(&quot;/zk&quot;, false); System.out.println(null==exists?&quot;不存在&quot;:&quot;存在&quot;); &#125; /** * @Description 获取节点数据 * @Author 刘俊重 */ @Test public void getData() throws Exception&#123; byte[] data = zkCli.getData(&quot;/zk&quot;, false, null); System.out.println(&quot;节点数据：&quot;+new String(data)); &#125; /** * @Description 遍历节点数据 * @Author 刘俊重 */ @Test public void getChildren() throws Exception&#123; List&lt;String&gt; children = zkCli.getChildren(&quot;/&quot;, false); for(String s : children)&#123; System.out.println(&quot;节点名称：&quot;+s); &#125; Thread.sleep(Long.MAX_VALUE); &#125; /** * @Description 删除节点数据 * @Author 刘俊重 */ @Test public void delete() throws Exception&#123; //参数2：指定要删除的版本，-1表示删除所有版本 zkCli.delete(&quot;/zk&quot;,-1); this.isExist(); &#125; /** * @Description 更新节点数据 * @Author 刘俊重 */ @Test public void update() throws Exception&#123; Stat stat = zkCli.setData(&quot;/zk&quot;, &quot;newtest&quot;.getBytes(), -1); this.getData(); &#125;&#125; Thread.sleep(Long.MAX_VALUE);是为了不让程序执行完之后立马结束，让它睡一会，测试监听是否实现，同时在process回调函数中写了收到通知的操作， zkCli.getChildren(“/“, true);这时如果我们通过linux命令行操作了zookeeper操作节点就会触发这里的监听事件。 5.zookeeper的使用场景5.1场景一：客户端动态感知服务端节点变化，实现高可用现在假设有这样一种需求：服务端节点有多个，可以动态的上下线；需要让任意一台客户端都能实时感知服务端节点的变化，进而连接目前可提供服务的节点。实现思路：我们可以借助于zookeeper这个第三方中间件，在每台服务器启动时都向zookeeper注册服务器的节点信息（比如：/servers/server01;/servers/server02）；客户端每次调用之前都通过getChildren方法获取最新的服务器节点信息，同时客户端在zookeeper注册监听，监听服务器节点的变化；如果某刻服务器server01下线了，zookeeper就会发出节点变化通知客户端，回调process方法拉取最新的服务器节点信息。服务端代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class DistributeServer &#123; private static final String CONNECT_URL = &quot;mini1:2181,mini2:2181,mini3:2181&quot;; private static final int SESSION_TIME_OUT = 2000; private static final String PARENT_NODE = &quot;/servers&quot;; private ZooKeeper zkCli = null; /** * @Description 获取连接 * @Author 刘俊重 * @Date 2017/12/13 */ public void getConnect() throws Exception&#123; zkCli = new ZooKeeper(CONNECT_URL, SESSION_TIME_OUT, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; System.out.println(event.getType()+&quot;-----------&quot;+event.getPath()); try&#123; zkCli.getChildren(&quot;/&quot;, true); &#125;catch (Exception e)&#123; &#125; &#125; &#125;); &#125; /** * @Description 服务器启动时向zookeeper注册服务信息 * @Author 刘俊重 * @Date 2017/12/13 */ public void registerServer(String hostName) throws Exception &#123; String s = zkCli.create(PARENT_NODE + &quot;/&quot;, hostName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); System.out.println(&quot;服务器：&quot;+hostName+&quot;已经注册完毕&quot;); &#125; /** * @Description 模拟实际的业务操作 * @Author 刘俊重 * @Date 2017/12/13 */ public void handelBusiness(String hostname) throws Exception &#123; System.out.println(&quot;服务器：&quot;+hostname+&quot;正在处理业务。。。&quot;); Thread.sleep(Long.MAX_VALUE); &#125; public static void main(String[] args) throws Exception &#123; DistributeServer server = new DistributeServer(); server.getConnect(); server.registerServer(args[0]); server.handelBusiness(args[0]); &#125;&#125; 客户端代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @author 刘俊重 * @Description 模拟客户端，拉取最新服务器节点列表并向zookeeper设置监听 */public class DistributeClient &#123; private static final String CONNECT_URL = &quot;mini1:2181,mini2:2181,mini3:2181&quot;; private static final int SESSION_TIME_OUT = 2000; private static final String PARENT_NODE = &quot;/servers&quot;; private ZooKeeper zkCli = null; private volatile List&lt;String&gt; serverList = null; /** * @Description 获取连接 * @Author 刘俊重 * @Date 2017/12/13 */ public void getConnect() throws Exception&#123; zkCli = new ZooKeeper(CONNECT_URL, SESSION_TIME_OUT, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; // 收到事件通知后的回调函数（应该是我们自己的事件处理逻辑） System.out.println(event.getType()+&quot;-----------&quot;+event.getPath()); try&#123; //重新更新服务器列表，并且注册了监听 getServerList(); &#125;catch (Exception e)&#123; &#125; &#125; &#125;); &#125; /** * @Description 获取服务器子节点信息，并对父节点进行监听 * @Author 刘俊重 */ public void getServerList() throws Exception &#123; List&lt;String&gt; children = zkCli.getChildren(PARENT_NODE, true); List&lt;String&gt; servers = new ArrayList&lt;String&gt;(); for(String child : children)&#123; // child只是子节点的节点名 byte[] data = zkCli.getData(PARENT_NODE + &quot;/&quot; + child, false, null); servers.add(new String(data)); &#125; //把servers赋值给成员变量serverList，以提供给各业务线程使用 serverList = servers; System.out.println(&quot;节点数据：&quot;+serverList); &#125; /** * @Description 模拟实际的业务操作 * @Author 刘俊重 * @Date 2017/12/13 */ public void handelBusiness() throws Exception &#123; System.out.println(&quot;客户端开始工作。。。&quot;); Thread.sleep(Long.MAX_VALUE); &#125; public static void main(String[] args) throws Exception &#123; DistributeClient client = new DistributeClient(); client.getConnect(); client.getServerList(); client.handelBusiness(); &#125;&#125; 5.2场景二：分布式锁实现假设现在集群中有50台机器对某台机器上的同一文件进行修改，如何才能保证这个文件不会被写乱呢，使用java中的synchronized锁肯定是不行的，因为这个锁是对某个程序而言的，而我们这根本就不是在一个服务器上，怎么会锁的住，用zookeeper实现的分布式锁可以实现。设计思路：服务器启动时都去zookeeper上注册一个“短暂+序号”的znode节点（如/lock/1;/lock/2），并设置监听父节点变化；获取到父节点下所有子节点，并比较序号的大小；约定比如序号最小的获取锁，去操作某一文件，操作完成后删除自己的节点（相当于释放锁），并注册一个新的“短暂+序号”的znode节点；其它程序收到zookeeper发送的节点变化的通知之后，去比较序号的大小，看谁获得新锁。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class DistributedClientLock &#123; // 会话超时 private static final int SESSION_TIMEOUT = 2000; // zookeeper集群地址 private String hosts = &quot;mini1:2181,mini2:2181,mini3:2181&quot;; private String groupNode = &quot;locks&quot;; private String subNode = &quot;sub&quot;; private boolean haveLock = false; private ZooKeeper zk; // 记录自己创建的子节点路径 private volatile String thisPath; /** * 连接zookeeper */ public void connectZookeeper() throws Exception &#123; zk = new ZooKeeper(hosts, SESSION_TIMEOUT, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; try &#123; // 判断事件类型，此处只处理子节点变化事件 if (event.getType() == EventType.NodeChildrenChanged &amp;&amp; event.getPath().equals(&quot;/&quot; + groupNode)) &#123; //获取子节点，并对父节点进行监听 List&lt;String&gt; childrenNodes = zk.getChildren(&quot;/&quot; + groupNode, true); String thisNode = thisPath.substring((&quot;/&quot; + groupNode + &quot;/&quot;).length()); // 去比较是否自己是最小id Collections.sort(childrenNodes); if (childrenNodes.indexOf(thisNode) == 0) &#123; //访问共享资源处理业务，并且在处理完成之后删除锁 doSomething(); //重新注册一把新的锁 thisPath = zk.create(&quot;/&quot; + groupNode + &quot;/&quot; + subNode, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); // 1、程序一进来就先注册一把锁到zk上 thisPath = zk.create(&quot;/&quot; + groupNode + &quot;/&quot; + subNode, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); // wait一小会，便于观察 Thread.sleep(new Random().nextInt(1000)); // 从zk的锁父目录下，获取所有子节点，并且注册对父节点的监听 List&lt;String&gt; childrenNodes = zk.getChildren(&quot;/&quot; + groupNode, true); //如果争抢资源的程序就只有自己，则可以直接去访问共享资源 if (childrenNodes.size() == 1) &#123; doSomething(); thisPath = zk.create(&quot;/&quot; + groupNode + &quot;/&quot; + subNode, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); &#125; &#125; /** * 处理业务逻辑，并且在最后释放锁 */ private void doSomething() throws Exception &#123; try &#123; System.out.println(&quot;gain lock: &quot; + thisPath); Thread.sleep(2000); &#125; finally &#123; System.out.println(&quot;finished: &quot; + thisPath); //释放锁 zk.delete(this.thisPath, -1); &#125; &#125; public static void main(String[] args) throws Exception &#123; DistributedClientLock dl = new DistributedClientLock(); dl.connectZookeeper(); Thread.sleep(Long.MAX_VALUE); &#125;&#125; 参考文档：http://www.cnblogs.com/likehua/tag/zookeeper/ 6 zookeeper的选举机制6.1全新集群paxos以一个简单的例子来说明整个选举的过程.假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数据量这一点上,都是一样的.假设这些服务器依序启动,来看看会发生什么.1) 服务器1启动,此时只有它一台服务器启动了,它发出去的报没有任何响应,所以它的选举状态一直是LOOKING状态2) 服务器2启动,它与最开始启动的服务器1进行通信,互相交换自己的选举结果,由于两者都没有历史数据,所以id值较大的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3),所以服务器1,2还是继续保持LOOKING状态.3) 服务器3启动,根据前面的理论分析,服务器3成为服务器1,2,3中的老大,而与上面不同的是,此时有三台服务器选举了它,所以它成为了这次选举的leader.4) 服务器4启动,根据前面的分析,理论上服务器4应该是服务器1,2,3,4中最大的,但是由于前面已经有半数以上的服务器选举了服务器3,所以它只能接收当小弟的命了.5) 服务器5启动,同4一样,当小弟. 6.2非全新集群的选举机制(数据恢复)那么，初始化的时候，是按照上述的说明进行选举的，但是当zookeeper运行了一段时间之后，有机器down掉，重新选举时，选举过程就相对复杂了。需要加入数据id、leader id和逻辑时钟。数据id：数据新的id就大，数据每次更新都会更新id。Leader id：就是我们配置的myid中的值，每个机器一个。逻辑时钟：这个值从0开始递增,每次选举对应一个值,也就是说: 如果在同一次选举中,那么这个值应该是一致的 ; 逻辑时钟值越大,说明这一次选举leader的进程更新.选举的标准就变成：1、逻辑时钟小的选举结果被忽略，重新投票2、统一逻辑时钟后，数据id大的胜出3、数据id相同的情况下，leader id大的胜出根据这个规则选出leader。]]></content>
      <categories>
        <category>后台—分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机中设置Linux网络为静态IP踩过的坑]]></title>
    <url>%2F2017%2F12%2F15%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%AE%BE%E7%BD%AELinux%E7%BD%91%E7%BB%9C%E4%B8%BA%E9%9D%99%E6%80%81IP%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[在公司使用虚拟机准备弄个linux集群测点东西，无奈ip一直变来变去，只好修改成固定的，中间走点弯路，做一下记录（我这一开始是NAT模式，dhcp自动获取ip，改的结果是NAT模式，static静态设置ip）。 1.查看虚拟机的网关 依次点击虚拟机左上角的编辑——虚拟网络编辑器——NAT模式（注意：网络有桥接，NAT，host-only的连接方式，我这用的是NAT的）——NAT设置——点开的对话框中网关（自己也可以对这个网关修改），记下来等会用。2.修改IP地址使用vim编辑器执行下面命令修改ip：1vim /etc/sysconfig/network-scripts/ifcfg-eth0 在打开的页面配置成这样（有的有双引号，有的无，没有关系）12345678910DEVICE=&quot;eth0&quot;BOOTPROTO=&quot;static&quot;HWADDR=&quot;00:0C:29:F5:26:26&quot;BROADCAST=192.168.85.255IPADDR=192.168.85.100NETMASK=255.255.255.0GATEWAY=192.168.85.1NM_CONTROLLED=&quot;no&quot;ONBOOT=&quot;yes&quot;TYPE=&quot;Ethernet&quot; 下面几项必须要配置，其它的使用默认即可。BOOTPROTO=static 默认的是dhcp，这里用static，意思是使用静态ip。NETMASK=255.255.255.0 子网掩码，配置成255.255.255.0就可以。GATEWAY=192.168.85.1 网关地址，就是第一步我让记下的那个地址。ONBOOT=yes 开机即使用这套配置NM_CONTROLLED=no 不允许Network Manager管理网络（这里有坑，我下面会说）。 3.添加nameserver在执行完上一步之后，我在网上搜到要通过以下方式再设置一下网关，按理说在上面配置完之后已经不需要了，我不太清楚这二者是否有必然的联系，如果你那里设置完不生效，也可以每一步都按我这来。 设置网关 1route add default gw 192.168.85.1 添加nameserver 123vi /etc/resolv.conf在文件末尾追加，这个ip就是上面的网关nameserver 192.168.85.1 4.不允许Network Manager管理网络这里解释一下为什么第二步设置NM_CONTROLLED=no ，如果不设置这个，你会发现在你执行完service network restart 这条命令之后第三步设置的nameserver什么都没有了，导致无法联网，换言之，如果你让Network Manager管理网络了，则/etc/resolv.conf 文件每次重启都会被还原。现在可以执行1service network restart 重启网络服务，然后执行1ping baidu.com 测试配置结果。彻底废掉Network Manager 1chkconfig NetworkManager off 参考文档：http://blog.csdn.net/q_l_s/article/details/50729805 后记：今天又发现一个问题，开机用xshell连不通虚拟机了，ping不通虚拟机，但是虚拟机里面的linux可以上网，也可以ping通我的window ip，搜索之后得出以下解决方案:因为公司网络我用的是自动获取ip，导致我今天来之后VMnet8 ip变成了其它的，与我设置的linux静态ip192.168.85.100不在同一个网段内，所以ping不通，将window电脑中VMnet8网卡的ip设置成固定ip，例如192.168.85.50即可，问题解决！ 2017-12-08]]></content>
      <categories>
        <category>服务器—linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux软件安装总结]]></title>
    <url>%2F2017%2F12%2F15%2FLinux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[首先Xshell一个好用的选项，如果你同时要管理几台一样的服务器组成的集群，一台一台操作很麻烦，可以使用Xshell菜单栏——工具——勾选发送键输入到所有会话，这样你在一个bash窗口输入的指令，其它所有打开的会话服务器也都会执行这条指令。 1.安装JDK 上传jdk-7u45-linux-x64.tar.gz到Linux上 解压jdk到/usr/local目录tar -zxvf jdk-7u45-linux-x64.tar.gz -C /usr/local/-C 后面是指定要解压的路径，如果没有-C及其后面的默认解压到当前文件夹 配置环境变量，在/etc/profile文件最后追加相关内容vi /etc/profile12export JAVA_HOME=/usr/local/jdk1.7.0_45export PATH=$PATH:$JAVA_HOME/bin $PATH是默认变量，新设置的PATH不能把原来的给覆盖了，所以先写原来的，冒号后面在写新的bin路径。 刷新环境变量source /etc/profile 测试java命令是否可用java -version2.安装Tomcat 上传apache-tomcat-7.0.68.tar.gz到Linux上 解压tomcat 1tar -zxvf apache-tomcat-7.0.68.tar.gz -C /usr/local/ 启动tomcat 1/usr/local/apache-tomcat-7.0.68/bin/startup.sh 查看tomcat进程端口 1netstat -nltp 通过浏览器访问tomcathttp://192.168.0.101:8080/ 3.安装mysql 执行yum命令，删除原来的MySQLlib库和服务文件 1yum remove mysql mysql-server mysql-libs mysql-server; 查找是否删除干净 1rpm -qa | grep mysql 或者 find / -name mysql 如果还有mysql文件，运行“rm -rf 文件名”删除残留的MySQL文件 将MySQL-client-5.5.48-1.linux2.6.i386.rpm和MySQL-server-5.5.48-1.linux2.6.i386.rpm拷贝到centos服务器上。 安装MySQL-server-5.5.48-1.linux2.6.i386.rpm1rpm -ivh MySQL-server-5.5.48-1.linux2.6.i386.rpm 如果报错，说明需要安装perl依赖，执行以下命令安装perl依赖环境12yum install perl*这个命令基本上把perl的模块给安装齐了。 如果再报缺少其它的依赖包，就使用yum一个一个的安装，比如：yum install libaio.so.1。 卸载冲突的依赖包继续刚才的安装，如果报类似于下面的12file /usr/share/mysql/charsets/README from install of MySQL-server-5.5.48-1.linux2.6.i386 conflicts with file from package mysql-libs-5.1.73-8.el6_8.x86_64 file /usr/share/mysql/charsets/Index.xml from install of MySQL-server-5.5.48-1.linux2.6.i386 conflicts with file from package mysql-libs-5.1.73-8.el6_8.x86_64 就是有冲突，一次卸载冲突包，比如：1rpm -e mysql-libs-5.1.73-8.el6_8.x86_64 --nodeps 如果成功，会看到进度条。最后，有关于root密码设置的提示，一定要记下来，推荐截图保存我这个是5.5版本的，这个版本的提示是，先启动serverservice mysql start然后/usr/bin/mysql_secure_installation 命令去交互式修改root密码 当我执行/usr/bin/mysql_secure_installation这条命令修改密码时，它提示我需要先安装client，那我就安装client，但是安装完之后记得还是要执行修改密码那一步，因为我们是第一次进来没有密码，直接按回车进去设置即可。1rpm -ivh MySQL-client-5.5.48-1.linux2.6.x86_64.rpm 客户端安装成功后，记得还要用/usr/bin/mysql_secure_installation 命令去交互式修改root密码 登录验证1mysql -uroot -proot 查询测试1show databases; 验证成功，退出1exit; 安装中途如果出现什么问题导致无法继续下去，把所有mysql东西卸载干净，重启服务器，再重新装。 设置navicat可以连接如果使用navicat连接不上，报“1130 host xxx is not allowed to connect mysql”那么就需要执行下面这些配置。12341.在装有MySQL的机器上登录MySQL mysql -u root -p密码2.执行use mysql;3.执行update user set host = &apos;%&apos; where user = &apos;root&apos;;这一句执行完可能会报错，不用管它。4.执行FLUSH PRIVILEGES; 4.安装nginx4.1安装nginx 下载nginx 1官网：http://nginx.org/ 上传并解压nginx 1tar -zxvf nginx-1.8.1.tar.gz -C /usr/local/src -C后面是执行解压路径 编译nginx因为nginx是用c写的，在不同的机器上需要编译之后再运行，不然可能运行不起来，所以要对官方提供的源码进行编译，这个预编译其实就是一个检查的过程。java中因为直接运行在了jvm机上，所以运行别人编译打包之后的jar或war是没问题的。 12345678进入到nginx源码目录（切记一定要进入到源码目录在执行下面的检查命令）cd /usr/local/src/nginx-1.8.1检查安装环境,并指定将来要安装的路径./configure --prefix=/usr/local/nginx如果报错./configure: error: C compiler cc is not found说明缺少编译包，使用YUM安装缺少的包yum -y install gcc pcre-devel openssl openssl-devel 编译安装 1make &amp;&amp; make install 安装完后测试是否正常： 1234执行下面命令启动nginx/usr/loca/nginx/sbin/nginx查看端口是否有ngnix进程监听netstat -ntlp | grep 80 4.2配置nginx 配置反向代理1.修改nginx配置文件12345678server &#123; listen 80; server_name mini1; #nginx所在服务器的主机名反向代理的配置location / &#123; #拦截所有请求 root html; proxy_pass http://192.168.0.21:8080; #这里是代理转向的目标服务器 &#125;&#125; 上面这段话的意思是当我访问http://mini1:80 时(80可以省略)，请求会被转发到http://192.168.0.21:8080 的tomcat服务器上，/代表是所有的请求都被拦击，亦即所有的请求都会被转发至http://192.168.0.21:8080 ，当然你也可以配置静态资源（比如css，html,图片）不做转发。2.启动mini1上的tomcat3.启动nginx1234重启或关闭nginx进程：/usr/local/nginx/sbin/nginx -s reload/usr/local/nginx/sbin/nginx -s stop参考网址:http://www.cnblogs.com/jianxie/p/3990377.html 动静分离123456789动态资源 index.jsplocation ~ .*\.(jsp|do|action)$ &#123; proxy_pass http://192.168.0.21:8080;&#125;静态资源location ~ .*\.(html|js|css|gif|jpg|jpeg|png)$ &#123; expires 3d;&#125; 配置完成后当请求动态资源jsp文件时就会被转发至http://192.168.0.21:8080 服务器，请求静态资源就不做转发。 负载均衡在http这个节下面配置一个叫upstream的，后面的名字可以随意取，但是要和location下的proxy_pass http://后的保持一致。123456789101112http &#123; 是在http里面的, 已有http, 不是在server里,在server外面 upstream tomcats &#123; server http://192.168.0.21:8080 weight=1;#weight权重 server http://192.168.0.22:8080 weight=1; server http://192.168.0.23:8080weight=1;&#125;卸载server里location ~ .*\.(jsp|do|action) &#123; proxy_pass http://tomcats; #tomcats是后面的tomcat服务器组的逻辑组号&#125;&#125; 4.3设置nginx开机自启动 添加配置文件在linux系统的/etc/init.d/目录下创建nginx文件，使用如下命令：(我建议可以在window下面编辑好之后再上传到nginx上)1vim /etc/init.d/nginx 在nginx文件中添加以下内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0nginx=&quot;/apps/nginx/sbin/nginx&quot;prog=$(basename $nginx)NGINX_CONF_FILE=&quot;/apps/nginx/conf/nginx.conf&quot;[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &apos;s/[^*]*--user=\([^ ]*\).*/\1/g&apos; -` if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep &apos;configure arguments:&apos;` for opt in $options; do if [ `echo $opt | grep &apos;.*-temp-path&apos;` ]; then value=`echo $opt | cut -d &quot;=&quot; -f 2` if [ ! -d &quot;$value&quot; ]; then # echo &quot;creating&quot; $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $&quot;Starting $prog: &quot; daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $&quot;Stopping $prog: &quot; killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $&quot;Reloading $prog: &quot; killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case &quot;$1&quot; in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot; exit 2esac 注意要把下面两项配置修改成你自己的：nginx=”/apps/nginx/sbin/nginx” 修改成nginx执行程序的路径。NGINX_CONF_FILE=”/apps/nginx/conf/nginx.conf” 修改成nginx配置文件的路径。 添加执行权限1chmod a+x /etc/init.d/nginx 现在就可以通过该脚本对nginx服务进行管理了：12/etc/init.d/nginx start 启动/etc/init.d/nginx stop 停止 终极方案——开机自启动nginx到上一步其实已经可以方便的管理了，但我还是比较懒，希望开机就自启动nginx运行，可以使用chkconfig来设置。先将nginx服务加入chkconfig管理列表：1chkconfig --add /etc/init.d/nginx 加完这个之后，就可以使用service对nginx进行启动，重启等操作了。12service nginx startservice nginx stop 设置开机自启动：1chkconfig nginx on 使用下面命令确定是否加入了开机自启动。1chkconfig | grep nginx END参考文档：http://blog.csdn.net/u013870094/article/details/52463026 5.安装KeepAlived实现高可用keepalive是一款可以实现高可用的软件，通常部署在2台服务器上，分为一主一备。Keepalived可以对本机上的进程进行检测，一旦Master检测出某个进程出现问题，将自己切换成Backup状态，然后通知另外一个节点切换成Master状态。 5.1keepalived安装 下载keepalived 1官网:http://keepalived.org 将keepalived解压到/usr/local/src目录下 1tar -zxvf keepalived-1.2.19.tar.gz -C /usr/local/src 进入到/usr/local/src/keepalived-1.2.19目录 1cd /usr/local/src/keepalived-1.2.19 开始configure 1./configure --prefix=/usr/local/keepalived -编译并安装1make &amp;&amp; make install 5.2将keepalived添加到系统服务中拷贝执行文件1cp /usr/local/keepalived/sbin/keepalived /usr/sbin/ 将init.d文件拷贝到etc下,加入开机启动项12cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived 将keepalived文件拷贝到etc下1cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/ 创建keepalived文件夹1mkdir -p /etc/keepalived 将keepalived配置文件拷贝到etc下1cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf 添加可执行权限1chmod +x /etc/init.d/keepalived 也可以一次性执行以上命令：12345678cp /usr/local/keepalived/sbin/keepalived /usr/sbin/cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalivedcp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/ mkdir -p /etc/keepalivedcp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.confchmod +x /etc/init.d/keepalivedchkconfig --add keepalived chkconfig keepalived on 添加keepalived到开机启动12chkconfig --add keepalived chkconfig keepalived on 5.3配置keepalived虚拟IP修改配置文件： /etc/keepalived/keepalived.confMASTER节点12345678910111213141516global_defs &#123;&#125;vrrp_instance VI_1 &#123; state MASTER #指定A节点为主节点 备用节点上设置为BACKUP即可 interface eth0 #绑定虚拟IP的网络接口 virtual_router_id 51 #VRRP组名，两个节点的设置必须一样，以指明各个节点属于同一VRRP组 priority 100 #主节点的优先级（1-254之间），备用节点必须比主节点优先级低 advert_int 1 #组播信息发送间隔，两个节点设置必须一样 authentication &#123; #设置验证信息，两个节点必须一致 auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; #指定虚拟IP, 两个节点设置必须一样 192.168.33.60/24 #如果两个nginx的ip分别是192.168.33.61,192.168.33.62，则此处的虚拟ip跟它俩同一个网段即可 &#125;&#125; BACKUP节点12345678910111213141516global_defs &#123;&#125;vrrp_instance VI_1 &#123; state BACKUP interface eth0 virtual_router_id 51 priority 99 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.33.60/24 &#125;&#125; 测试：分别启动两台机器上的keepalived1service keepalived start 杀掉master上的keepalived进程，你会发现，在slave机器上的eth0网卡多了一个ip地址查看ip地址的命令： ip addr 5.4配置keepalived心跳检查原理：Keepalived并不跟nginx耦合，它俩完全不是一家人但是keepalived提供一个机制：让用户自定义一个shell脚本去检测用户自己的程序，返回状态给keepalived就可以了MASTER节点:1234567891011121314151617181920212223242526272829303132global_defs &#123;&#125;vrrp_script chk_health &#123; script &quot;[[ `ps -ef | grep nginx | grep -v grep | wc -l` -ge 2 ]] &amp;&amp; exit 0 || exit 1&quot; interval 1 #每隔1秒执行上述的脚本，去检查用户的程序ngnix weight -2&#125;vrrp_instance VI_1 &#123; state MASTER interface eth0 virtual_router_id 1 priority 100 advert_int 2 authentication &#123; auth_type PASS auth_pass 1111 &#125; track_script &#123; chk_health &#125; virtual_ipaddress &#123; 10.0.0.10/24 &#125; notify_master &quot;/usr/local/keepalived/sbin/notify.sh master&quot; notify_backup &quot;/usr/local/keepalived/sbin/notify.sh backup&quot; notify_fault &quot;/usr/local/keepalived/sbin/notify.sh fault&quot;&#125; 添加切换通知脚本1vi /usr/local/keepalived/sbin/notify.sh 内容如下：123456789101112131415161718192021#!/bin/bashcase &quot;$1&quot; in master) /usr/local/nginx/sbin/nginx exit 0 ;;backup) /usr/local/nginx/sbin/nginx -s stop /usr/local/nginx/sbin/nginx exit 0 ;; fault) /usr/local/nginx/sbin/nginx -s stop exit 0 ;; *) echo &apos;Usage: notify.sh &#123;master|backup|fault&#125;&apos; exit 1 ;;esac 添加执行权限chmod +x /usr/local/keepalived/sbin/notify.sh 在第二台机器上添加notify.sh脚本 分别在两台机器上启动keepalived12service keepalived start chkconfig keepalived on 6.虚拟机克隆严格来说这不属于安装软件的范畴，但是为了总结方便，也把虚拟机的克隆放在这里记一下：有时候我们在虚拟机模拟集群的时候需要多台linux服务器，如果一台已经安装好了，这时就可以采用克隆的办法去快速生成多台liunx服务器。虚拟机桌面上，选定你要克隆的虚拟机——右键——管理——克隆，下一步下一步即可。克隆完成后需要修改ip，主机名等配置： 修改hosts：vi /etc/hosts 1192.168.85.102 mini2 修改sysconfig/network：vi /etc/sysconfig/network 1HOSTNAME=mini1 修改resolv.confvi /etc/resolv.conf 1search mini1 修改ifcfg-eth0: 123配置IP为：IPADDR=192.168.85.101删掉UUID和HWADDR那两行 删除70-persistent-net.rules： 1rm -rf /etc/udev/rules.d/70-persistent-net.rules 重启即可使用： 1reboot 7.从一台linux登录到另一台linux机器上并配置免密登录 从一台linux登录到另一台linux现在假如有两台服务器192.168.85.101和192.168.85.102，如果我想从101服务器向102服务器复制文件，而又不想走xshell做一次中转，那就可以直接从101登录到102上。liunx上的登录采用的是ssh协议的方式，分为客户端和服务端，每一台服务器就是服务端，那什么是客户端呢，只需要输入ssh即可，就相当于调出了linux这台机器上的客户端。1ssh 192.168.85.102 输入yes和密码，就可以从101上登录到102这台服务器上了，输入exit可以退出102服务器。以magic用户的身份登录102服务器（前提是192.168.85.102服务器上存在magic这个用户）1ssh magic@192.168.85.102 使用root用户的身份将testfile文件拷贝到192.168.85.102服务器的apps文件夹下，scp就是在服务器之间拷贝文件的命令。1scp testfile root@192.168.85.102:/apps 配置免密登录上面基本已经解决了前面的问题，但是有个缺陷，每次都需要输入密码，很麻烦，可以配置免密登录。ssh是远程登录的安全外壳协议，提供两种身份验证机制：用户名+密码或者密钥验证。 配置主机之间的免密ssh登陆假如从192.168.85.101要登陆192.168.85.102在192.168.85.101上进行操作：1.首先生成密钥对：1ssh-keygen 中间有提示时，直接回车即可。2.再将192.168.85.101的公钥拷贝并追加到192.168.85.102的授权列表文件authorized_keys中,使用下面命令执行。1ssh-copy-id 192.168.85.102 到此结束，安装完成，直接ssh 192.168.85.102 不用输密码即可登录。]]></content>
      <categories>
        <category>服务器—linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进阶命令和Shell编程]]></title>
    <url>%2F2017%2F12%2F15%2FLinux%E8%BF%9B%E9%98%B6%E5%91%BD%E4%BB%A4%E5%92%8CShell%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.高级文本命令——sed1.1sed简介sed全称是：Stream EDitor，即流编辑器，是一个很好的文本处理工具，本身是一个管道命令，处理时，把当前处理的行存储在临时缓冲区中，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行。它是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作。 1.2sed选项-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。-e ：直接在命令列模式上进行 sed 的动作编辑；-i ：直接修改读取的文件内容，而不是输出到终端。 1.3sed函数a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)d ：删除，因为是删除啊，所以 d 后面通常不接任何内容i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行s ：取代，可以直接进行取代的工作！通常这个 s 的动作可以搭配正规表示法！例如 20s/old/new/g练习：1234567删除之后写入sed &apos;2d&apos; testfile 只在展示的时候删除第二行，实际testfile文件并没有改变sed -i &apos;2d&apos; testfile 将第二行删除并写入testfile文件，那么实际上testfile的第二行就被物理删除了。替换sed &apos;s/hell/8888/g&apos; testfile 以s开头代表替换，将hell替换成8888，/g代表全局替换，整个文件中的hell都被替换，如果不写则只替换第一个。sed -i &apos;s/hell/88888/g&apos; testfile 替换完之后并写入到testfile文件，即物理替换。 2.高级文本命令——awk2.1简介awk是一种优良的文本处理工具。其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母，awk 提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。实际上 awk 的确拥有自己的语言：awk 程序设计语言， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许你创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有其他的许多功能。练习：1234last查最近登录的用户 last -n 5 查最近登录的五个用户last -n 5 | awk &apos;&#123;print $1&#125;&apos; 查最近登录的五个用户并把结果作为后面的输入，输出第一列的值，即输出最近登录的五个用户的用户名。awk工作流程是这样的：读入有&apos;\n&apos;换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是&quot;空白键&quot; 或 &quot;[tab]键&quot;,所以$1表示登录用户，$3表示登录用户ip,以此类推（说白了，其实就是以空格或tab作为分隔符划分为几列，$1就是取第一列的值）。 3.高级文本命令——cut、wc、sort3.1cut命令cut命令可以从一个文本文件或者文本流中提取文本列，有点类似于java中的split（分割）。cut语法：12cut -d&apos;分隔字符&apos; -f fields &lt;==用于有特定分隔字符cut -c 字符区间 &lt;==用于排列整齐的信息 选项与参数：-d ：后面接分隔字符。与 -f 一起使用；-f ：依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思；-c ：以字符 (characters) 的单位取出固定字符区间；示例：1234567891011121314151617181920212223[root@www ~]# echo $PATH/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games1 | 2 | 3 | 4 | 5 | 6 | 7 将 PATH 变量取出，要找出第五个路径。echo $PATH | cut -d &apos;:&apos; -f 5/usr/local/bin 将 PATH 变量取出，要找出第三和第五个路径。echo $PATH | cut -d &apos;:&apos; -f 3,5/sbin:/usr/local/bin将 PATH 变量取出，要找出第三到最后一个路径。echo $PATH | cut -d &apos;:&apos; -f 3-/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games将 PATH 变量取出，要找出第一到第三个路径。echo $PATH | cut -d &apos;:&apos; -f 1-3/bin:/usr/bin:/sbin:将 PATH 变量取出，我要找出第一到第三，还有第五个路径。echo $PATH | cut -d &apos;:&apos; -f 1-3,5/bin:/usr/bin:/sbin:/usr/local/bin 3.2wc命令wc命令用来统计文件里面有多少单词，多少行，多少字符。wc语法：12345wc [-lwm]选项与参数：-l ：仅列出行；-w ：仅列出多少字(英文单字)；-m ：多少字符； 示例：12345678910111213使用wc统计/etc/passwdwc /etc/passwd40 45 1719 /etc/passwd40是行数，45是单词数，1719是字节数wc -l /etc/passwd #统计行数，在对记录数时，很常用40 /etc/passwd #表示系统有40个账户wc -w /etc/passwd #统计单词出现次数45 /etc/passwdwc -m /etc/passwd #统计文件的字符数1719 3.3sort 命令sort 命令对 File 参数指定的文件中的行排序，并将结果写到标准输出。如果 File 参数指定多个文件，那么 sort 命令将这些文件连接起来，并当作一个文件进行排序。sort语法：12345678910sort [-fbMnrtuk] [file or stdin]选项与参数：-f ：忽略大小写的差异，例如 A 与 a 视为编码相同；-b ：忽略最前面的空格符部分；-M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；-n ：使用『纯数字』进行排序(默认是以文字型态来排序的)；-r ：反向排序；-u ：就是 uniq ，相同的数据中，仅出现一行代表；-t ：分隔符，默认是用 [tab] 键来分隔；-k ：以那个区间 (field) 来进行排序的意思 例如：123456789101112131415对/etc/passwd 的账号进行排序cat /etc/passwd | sortadm:x:3:4:adm:/var/adm:/sbin/nologinapache:x:48:48:Apache:/var/www:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinsort 默认以第一个数据来排序，而且默认是以字符串形式来排序,所以由字母 a 开始升序排序。/etc/passwd 内容是以 : 来分隔的，如果想以第三栏来排序，该如何cat /etc/passwd | sort -t &apos;:&apos; -k 3root:x:0:0:root:/root:/bin/bashuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologin 4.Shell编程4.0Shell介绍Shell是用户与内核进行交互的一种接口，目前最流行的Shell是bash Shell；Shell也是一门编程语言（解释型的编程语言），即shell脚本。一个系统可以存在多个shell，可以通过：cat /etc/shells 命令查看系统中安装的shell，不同的shell可能支持的命令语法是不相同的。 4.1 Shell的执行方式首先需要赋予+x的权限，即执行的权限 bash或sh +脚本，就是sh加空格加脚本名称 123sh /root/helloWorld.sh或sh helloWorld.sh 在脚本的路径前加”. “ 1./startup.sh 4.2变量和运算符 变量：Shell中的变量分为“系统变量”和“用户自定义变量”，可以通过set命令查看当前所有的变量系统变量：$HOME、$PWD、$SHELL、$USER等等。自定义变量：需要注意以下几点。定义规则：变量＝值；等号两侧不能有空格；变量名称一般习惯为大写；双引号和单引号有区别，双引号仅将空格脱意，单引号会将所有特殊字符脱意；使用unset 变量名 来撤销变量；使用readonly 声明静态变量；使用export可将自定义变量提升为全局变量，例如我们在配置jdk时，就会把JAVA_HOME提升为系统变量。 12345678STR=abc就是定义了一个变量STR，它的值是abc.STR=&quot;hello world&quot;就是定义了一个变量STR，它的值是hello worldA=9unset A 就是撤销变量 Areadonly B=2 声明静态的变量 B=2 ，不能 unsetexport 变量名 可把变量提升为全局环境变量，可供其他shell程序使用 将命令的返回值赋给变量可以使用以下两种方式将返回值赋给变量 121.A=`ls -la` 反引号，运行里面的命令(列举出所有的文件)，并把结果返回给变量A，注意这个点号是tab键上面的那个符号，而不是引号。2.A=$(ls -la) 等价于反引号 特殊变量 123456$? 表示上一个命令退出的状态,0表示执行正常，不等于0表示执行不正常。$$ 表示当前进程编号$0 表示当前脚本名称$n 表示n位置的输入参数（n代表数字，n&gt;=1）$# 表示参数的个数，常用于循环$*和$@ 都表示参数列表 运算符：格式 :expr m + n 或$((m+n)) ，注意expr运算符间要有空格，m,n与+之间也要有空格。计算（5+4）*6 12345#!/bin/bashS=`expr 5 + 4`expr $S \* 6echo $(((2+3)*4)) 输出结果是54和20，值得注意的是上面的表达式expr与5，+与5,4之间都要有空格，输出结果不能带echo，下面的表达式输出结果必须带echo，而且2与3，+之间无空格。写完脚本之后记得chmod +x expr.sh给脚本添加权限。 4.3循环 for循环第一种形式12345678910111213下面这三种等价，记住一种即可，我一般用第一种#!/bin/bashfor N in 1 2 3do echo $N donefor N in 1 2 3;do echo $N;donefor N in &#123;1..3&#125;;do echo $N;done 第二种形式1234for((i=1;i&lt;=5;i++))do echo &quot;weclome $i&quot;done 注意括号必须是两对，就是这种语法，而且不能是int i=1,而是直接写i=1。 while循环1234567#!/bin/bashi=1while((i&lt;=5))do echo &quot;welcome $i&quot; let i++done do开始执行语句，done代表执行结束，let i++代表让i++,改变i的值 4.4条件语句1234567891011#!/bin/bashcase $1 instart) echo &quot;starting&quot; ;;stop) echo &quot;stoping&quot; ;;*) echo &quot;没有匹配的&quot;esac 这里需要传一个参数进来，用$1接住，然后判断这个参数如果等于start就输出starting，注意;;不能省略，不然会报错，如果输入stop，那这里就输出stoping，如果参数都不匹配，就输出没有匹配的，结尾的esac就是case的倒过来，这些计算机上古大神设计的东西确实很奇妙，不同于现在大部分这样结尾的，而是把单词倒过来，666。测试的时候就需要传入参数,我这个脚本的名称是case.sh，测试命令如下，start，star是传入的参数。1234[root@server1 test]# sh case.sh startstarting[root@server1 test]# sh case.sh star没有匹配的 4.5read命令命令规则：read -p “提示语句” 参数，这个类似于java中的Scanner，就是获取用户在控制台输入的内容。1234[root@server1 test]# read -p &quot;请输入你的名称:&quot; name请输入你的名称:Java开发日记[root@server1 test]# echo $nameJava开发日记 也可以把这个命令编写在shell脚本中，我这里用read.sh来写123#!/bin/bashread -p &quot;请输入你的名字:&quot; nameecho $name 测试时：123[root@server1 test]# sh read.sh 请输入你的名字:Java开发日记Java开发日记 4.6 if语句123456789101112#!/bin/bashread -p &quot;请输入用户名&quot; NAMEprintf &apos;%s\n&apos; $NAMEif [ $NAME = root ] then echo &quot;欢迎你 $&#123;NAME&#125;&quot;elif [ $NAME = magic ] then echo &quot;欢迎你，$&#123;NAME&#125;&quot; else echo &quot;你是谁，滚犊子&quot;fi 首先从控制台输入一个用户名，如果谁的等于root，或者等于magic，欢迎，如果都不是，提示出错信息。这里有几点注意，条件表达式里面的[与字符串，字符串与=中间都需要有空格，不然报错，条件表达式用中括号而不是小括号，是elif而不是elseif，结束时是fi（if反过来写）。测试时：123456789101112[root@server1 test]# sh if.sh 请输入用户名rootroot欢迎你 root[root@server1 test]# sh if.sh 请输入用户名magicmagic欢迎你，magic[root@server1 test]# sh if.sh 请输入用户名hahahaha你是谁，滚犊子 补充1：条件表达式里面如果是非空则是true，空则是false，例如[ magic ]则是true,[ ]则是false，可以$?进行验证。补充2：[ condition ] &amp;&amp; echo OK || echo notok，条件满足，执行输出OK，否则输出notok，类似于java中的三目运算。测试示例如下：1[ $NAME = magic ] &amp;&amp; echo magic || echo root 如果输入的$NAME等于magic，则输出magic，否则输出root。 4.7常用判断条件123456789101112131415= 字符串比较-lt 小于-le 小于等于-eq 等于-gt 大于-ge 大于等于-ne 不等于-r 有读的权限-w 有写的权限-x 有执行的权限-f 文件存在并且是一个常规的文件-s 文件存在且不为空-d 文件存在并是一个目录-b文件存在并且是一个块设备-L 文件存在并且是一个链接]]></content>
      <categories>
        <category>服务器—linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最实用的Linux命令总结]]></title>
    <url>%2F2017%2F12%2F15%2F%E6%9C%80%E5%AE%9E%E7%94%A8%E7%9A%84Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.linux安装中文环境（可选）联网之后执行：sudo yum groupinstall chinese-support，安装完语言包之后修改/etc/sysconfig/i18n文件，修改LANG=”zh_CN.UTF-8”。如果只想对当前登录用户有效请编辑~/.bashrc文件，在最后加入：export LANG=”zh_CN.UTF-8” 2. 一些杂项2.1监听网络端口netstat -nltp 比如可以看3306是否存在来确定mysql是否启动service network status 可以查看某个服务的运行状态 2.2查看进程树pstree每新开一个命令行窗口都有一个新的bash 2.3set命令set会显示当前环境中所有的变量包含系统变量和用户变量。export 变量名 会将这个变量提升为全局环境变量，供其它shell使用，完事之后source会把export指令输出一遍，比如source /etc/profile 3.网络连接方式VMware虚拟机三种联网方法及原理 3.1Brigde——桥接：默认使用VMnet0 这一种联网方式最简单，在局域网内，你的主机是怎么联网的，你在虚拟机里就怎么连网。把虚拟机看成局域网内的另一台电脑就行了！ （备注：我在公司用这种方式连接，配置静态IP无法上网，动态获取ip可以） 提示：主机网卡处在一个可以访问Internet的局域网中，虚拟机才能通过Bridge访问Internet。 3.2NAT——网络地址转换 ：默认使用VMnet8 NAT 是 Network address translate的简称。NAT技术应用在internet网关和路由器上，比如192.168.0.123这个地址要访问internet，它的数据包就要通过一个网关或者路由器，而网关或者路由器拥有一个能访问internet的ip地址，这样的网关和路由器就要在收发数据包时，对数据包的IP协议层数据进行更改（即 NAT），以使私有网段的主机能够顺利访问internet。此技术解决了IP地址稀缺的问题。VMWare的NAT上网也是同样的道理，它在主机和虚拟机之间用软件伪造出一块网卡，这块网卡和虚拟机的ip处于一个地址段。同时，在这块网卡和主机的网络接口之间进行NAT。虚拟机发出的每一块数据包都会经过虚拟网卡，然后NAT，然后由主机的接口发出。联网方式： 动态IP地址：主机是静态IP或动态IP，都无所谓，将虚拟机设置成使用DHCP方式上网,Windows下选择“自动获取IP“，linux下开启DHCP服务即可。（这种方法最简单，不用过多的设置，但要在VMware中进行“编辑→虚拟网络设置”，将NAT和DHCP都开启了。一般NAT默认开启，DHCP默认关闭） 静态IP地址：如果不想使用DHCP，也可以手动设置：IP设置与vmnet1同网段,网关设置成vmnet8的网关（在“虚拟网络设置”里的Net选项卡里能找到Gateway）通常是xxx.xxx.xxx.2，子网掩码设置与VMnet8相同（设置好IP地址后，子网掩码自动生成），DNS设置与主机相同。3.3Host-Only——私有网络共享主机：默认使用VMnet1只想让虚拟机和主机之间有数据交换，而不想让虚拟机访问Internet，就要采用这个设置了。联网方法： 动态IP地址：像上面那样开启DHCP后，虚拟机直接自动获取IP地址和DNS。就可以和主机相连了。当然，还要进行一些局域网共享的操作，这里不再赘述。 方法2、静态IP地址：也可以手动设置，将虚拟机IP设置与VMnet1同网段,网关设置成VMnet1的网关相同,其余设置与VMnet1相同,DNS设置与主机相同。例如：VMnet1 IP:172.16.249.1 Gateway :172.16.249.2 那么虚拟机 IP:172.16.249.100 Gateway: 172.16.249.24.修改网络和主机配置 修改ip地址vi /etc/sysconfig/network-scripts/ifcfg-eth0123456DEVICE=eth0TYPE=EthernetONBOOT=yes #是否开机启用BOOTPROTO=static #ip地址设置为静态IPADDR=192.168.0.101NETMASK=255.255.255.0 service network restart 修改之后重启 修改主机vi /etc/sysconfig/network 12NETWORKING=yesHOSTNAME=server1.catchu.me 修改ip地址和主机名的映射关系vi /etc/hosts 123127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.0.101 server1.catchu.me 关闭iptables(防火墙)并设置其开机启动/不启动 123456service iptables stop 关闭防火墙service iptables status 查看防火墙状态service iptables start 开启防火墙service iptables restart 重启防火墙chkconfig iptables on 设置防火墙开机启动chkconfig iptables off 设置防火墙开机不启动 注意：如果在xshell中可以ping通你的linux主机，却无法连接，多半是被防火墙拦截了。通过chkconfig指令可以查询哪些进程是开机自启动的 5.查询用户密码cat /etc/passwd123456root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinmysql:x:496:493:MySQL server:/var/lib/mysql:/bin/bashmagic:x:500:500:HAir:/home/magic:/bin/bash root，密码是占位符x，用户id是0，组id是0，root是别名，/root是家目录，/bin/bash默认用的shell解析器。用户id为0的超级用户，大于等于500的是超级用户，小于500的是伪用户，不能登录，但是它操作的时候也是以一个用户的身份，比如mysql就是以mysql用户的身份。cat /etc/group 可以查看所有的组linux查看帮助：ls –help wc –help 6.防火墙iptablesiptables也叫netfilter，从字面上也不难理解，它是对网络进行过滤的。防火墙（iptables）可以对流入，流出，流经服务器的数据包进行精细的控制。它的底层由四张表构成，分别是filter,nat,mangle和raw，每一张表都包含不同的链，最常用的是filter表。我一般把防火墙理解成过滤ip的表。 6.1基本操作 查看iptables状态 123456service iptables status或者下面这命令也是同样的效果列出iptables规则iptables -L -n列出iptables规则并显示规则编号iptables -L -n --line-numbers 开启/关闭iptables 12service iptables startservice iptables stop 查看iptables是否开机启动 1chkconfig iptables --list 设置iptables开机启动/不启动 12chkconfig iptables onchkconfig iptables off 查看帮助123iptables -hiptables -helpman iptables 6.2规则配置 清除所有规则1iptables -F -重启iptables发现规则依然存在，那是因为没有保存1service iptables restart 保存配置规则 1service iptables save 使用vim编辑器编辑规则vim /etc/sysconfig/iptables 12-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT 解释一下含义1234567-A, --append 追加到规则的最后一条-D, --delete 从规则中删除-I, --insert 插入，添加到规则的第一条-p, --proto 协议，常用协议有tcp、udp、icmp、all-j, --jump 常见的行为有ACCEPT、DROP和REJECT三种，但一般不用REJECT，会带来安全隐患，ACCEPT接受，表示可以访问；DROP扔掉，表示不能访问INPUT数据流入，OUTPUT数据流出注意：INPUT和DROP这样的关键字需要大写 其它还有一些规则比如匹配某些端口范围或者多个端口的，可以去网上搜，不记太多不常用的命令。 7.帮助命令1.内部命令：echo查看内部命令帮助：help echo 或者 man echo2.外部命令：ls查看外部命令帮助：ls –help 或者 man ls 或者 info ls3.man文档的类型(1~9)man 7 manman 5 passwd4.快捷键：ctrl + c：停止进程ctrl + l：清屏ctrl + r：搜索历史命令ctrl + q：退出5.善于使用tab键 8.文件相关命令8.1ls命令-a all全部的，包含隐藏文件-l long长的，表示详细信息-d directory目录，查看目录的信息文件类型drwxr-xr-x 2 root root 4096 10月5 08：24 bin第一个表示文件类型d directory 目录-binary 二进制文件l link 软链接文件rwx r-x r-xr read 读w write 写x execute 执行三组代表三种权限所有者u（user,onwer,谁创建谁是所有者） 所属组g（group） 其他人o（others）2代表硬链接数第一个root代表所有者第二个root代表所属组4096代表文件大小，不是准确数值，数据块，存储数据的最小单位，默认512字节10月5 08：24 创建时间或最后修改时间bin 文件名或目录类名 8.2cd命令cd change directory 切换目录cd / 切换到根目录cd .. 切换到上级目录 8.3pwd命令pwd print working directory 打印当前所在的目录 8.4 touch命令touch 创建空文件touch newFile 8.5mkdir命令mkdir make directories 创建目录mkdir newDir 8.6cp命令cp copy复制文件cp 原文件地址 目标文件地址cp /etc/servers /test 将etc目录下的servers文件复制到test目录下；cp -R /etc /test 使用-R是复制目录的，将etc目录复制到test目录下；scp sourecFile romoteUserName@remoteIp:remoteAddr 远程拷贝，scp是远程拷贝命令 8.7mv命令mv a.txt /ect/ 移动mv b.txt a.txt 改名mv a.txt ../b.txt 移动并改名 8.8rm命令rm remove删除文件rmdir 删除空目录（使用较少）rm file1 删除文件1rm -r dir1 删除目录1，记得加-r 8.9ln命令ln link产生链接文件ln -s 产生软链接，不加-s产生硬链接ln -s /etc/issue /issue.soft创建issue文件的软链接issue.soft,软链接相当于windows系统的快捷方式ln /etc/issue /issue.hard创建issue的硬链接issue.hard,硬链接相当于拷贝，除了时间不同 9.文件查看编辑命令9.1cat命令cat fileName 不能分页，一次展示文件内容 9.2more命令more 分页显示文件more /etc/services空格或f 显示下一页Enter 显示下一行q或Q 退出 9.3head命令head 显示文件前几行head -20 /etc/services 显示services文件前20行 不加默认显示前十行 9.4tail命令tail 显示文件后几行tail -30 /etc/servicestail -f logs.log 一直滚动显示logs.log的后几行（f follow）用于查看日志 9.5less命令比more功能更强大，可以搜索，可以直接进入vi编辑器中回车键 向下移动一行空格键 向下滚动一屏b 向上滚动一屏g 跳到第一行G 跳到最后一行/pattern 搜索pattern ，比如 /MAIL表示在文件中搜索MAIL单词v 进入vi编辑器q 退出less 9.6vim命令 最基本用法vi somefile1、首先会进入“一般模式”，此模式只接受各种快捷键，不能编辑文件内容2、按i键，就会从一般模式进入编辑模式，此模式下，敲入的都是文件内容3、编辑完成之后，按Esc键退出编辑模式，回到一般模式；4、再按：，进入“底行命令模式”，输入wq命令（或者shift+z+z），回车即可 一些有用的快捷键（在一般模式下使用）：a 在光标后一位开始插入A 在该行的最后插入I 在该行的最前面插入gg 直接跳到文件的首行G 直接跳到文件的末行dd 删除行，如果 5dd ，则一次性删除光标后的5行yy 复制当前行, 复制多行，则 3yy，则复制当前行附近的3行p 粘贴v 进入字符选择模式，选择完成后，按y复制，按p粘贴ctrl+v 进入块选择模式，选择完成后，按y复制，按p粘贴shift+v 进入行选择模式，选择完成后，按y复制，按p粘贴:set number 显示行号:set nonumber 不显示行号查找并替换（在底行命令模式中输入）%s/sad/88888888888888 效果：查找文件中所有sad，替换为88888888888888/you 效果：查找文件中出现的you，并定位到第一个找到的地方，按n可以定位到下一个匹配位置（按N定位到上一个）10.系统相关命令10.1查看主机名hostname10.2修改主机名(重启后无效)hostname magic修改主机名(重启后永久生效)vi /ect/sysconfig/network10.3修改IP(重启后无效)ifconfig eth0 192.168.12.22修改IP(重启后永久生效)vi /etc/sysconfig/network-scripts/ifcfg-eth010.4查看系统信息uname -auname -r10.5日期datedate +%Y-%m-%ddate +%Tdate +%Y-%m-%d” “%T10.6日历cal 201210.7挂载硬盘mountumount加载windows共享mount -t cifs //192.168.1.100/tools /mnt10.8查看文件大小du -hdu -ah10.9查看分区df -h10.10ssh连接其它服务器ssh root@192.168.1.110.11关机和重启shutdown -h now /init 0/halt 关机命令shutdown -r now /reboot 重启命令11用户和用户组相关命令11.1添加一个tom用户，设置它属于users组，并添加注释信息分步完成：useradd tomusermod -g users tom usermod -c &quot;hr tom&quot; tom 一步完成：useradd -g users -c “hr tom” tom11.2设置tom用户的密码passwd tom11.3修改tom用户的登陆名为tomcatusermod -l tomcat tom11.4将tomcat添加到sys和root组中usermod -G sys,root tomcat11.5查看tomcat的组信息groups tomcat11.6添加一个jerry用户并设置密码useradd jerrypasswd jerry11.7添加一个名为america的组groupadd america11.8将jerry添加到america组中usermod -g america jerry11.9将tomcat用户从root组和sys组删除gpasswd -d tomcat rootgpasswd -d tomcat sys11.10将america组名修改为amgroupmod -n am america12权限相关命令12.1 chmod命令chmod change the permissions mode of a file改变文件或者目录的权限chmod u+r 给所有者增加读权限g-w 给所属组减去写权限 o=x 不管其他人是什么权限，置为执行权限 u 代表所有者 g所属组 o其他人例如 chmod u+r a 给a文件的所属者添加读权限但是，通常使用数字表示r-4 w-2 x-1rwxr-xr– 代表的就是754例如：将/apps目录下的所有文件与子目录皆设为任何人可读取chmod -R a+r /apps （a代表的就是all）将/apps目录下的所有文件与子目录的拥有者设为root，用户拥有组为userschown -R root:users /apps12.2 rwx权限解析对于文件来说r 查看文件内容，命令 cat,more,head,tailw 修改文件内容，命令echo,vix 执行文件，包括命令或者脚本对于目录来说r 列出目录中的内容，命令lsw 在目录中创建和删除文件，想要删除文件，即使对这个文件有写权限也不行，只能修改文件，必须要对目录有w权限，才可以删除目录下的文件，命令mkdir,touch,rmx 可以进入目录,命令cd.所以可以看到对于一个目录文件一般都由rwx权限，不然死活都进不去的12.3chown命令chown change file ownership 改变文件或目录的所有者chown nobody file1 改变file1的所有者nobody 注意所有者不能随便写，必须是系统中存在的用户，例如nobody就是系统自带的用户，类似于windows的guest引入知识点 切换用户，命令：su - 用户名 例如su - root 切换到root用户 添加用户，命令：useradd 用户名 例如useradd hair 添加hair用户之后设置密码让他登陆，命令：passwd 密码12.4chgrp命令chgrp change file group owership 改变文件或目录的所属组chgrp adm file1 改变file1的所属组为adm adm是系统自带的缺省组12.5umask命令umask 显示或折这文件的缺省权限直接umask显示的结果：0022解析0022首个0是特殊权限位后面的022为权限掩码值777-022=755 表示所有者有读写执行权限，所属组和其他人有读执行权限。可以使用这样来修改创建文件的默认权限，例如umask -027 则新创建的文件或者目录所有者是读写执行，用户组是读，执行，其他人什么权限也没有还可以直接使用umask -S命令，结果u=rwx,g=rx,o=rx13查找相关命令13.1 which命令which 命令名称 显示命令所在目录which ls 查找可执行的命令whereis 命令名称 显示命令所在目录，二者的区别是which可以显示出命令的别名，whereis可以显示出命令所在的帮助文档。使用这个命令可以查看目录所在位置，进而知道命令是超级用户(sbin)或者普通用户（bin）可以执行的。whereis ls 查找可执行的命令和帮助的位置13.2find命令语法：find 搜索路径 搜索关键字 查找文件或目录find /etc -name init 在etc目录下面查找名称为init的文件，还可以使用通配符，init表示以init开头的文件，init*表示包含init的文件 find / -size +204800 在根目录下查找大于100MB的文件，是以block块为单位算的，一个block块是512字节，即0.5kb,100MB=102400kb=204800个0.5kb.find / -user hair 在根目录下查找所有者为hair的文件find /etc -ctime -1 在etc目录下查找24小时之内被修改过属性的文件和目录-ctime -atime -mtime 以天为单位-cmin -amin -mmin 以分钟为单位c change修改过文件的属性，比如所有者，所属组等属性信息a access访问过文件m modify修改过文件的内容-之内，+超过find /etc -mmin -120 在etc目录下查找两小时之内被修改过的文件find /etc -size +163840 -a -size -204800 在etc目录下查找大于80MB小于100MB的文件-a and表示逻辑与-o or表示逻辑或find /etc -name inittab -exec ls -l {} \;在etc目录下查找名称为inittab的文件并列出它的详细信息exec执行，固定格式find … -exec 命令 {} \;解析：{}代表前面find到的文件的集合。\代表执行命令本身。 ;代表语句结束。-exec可以换成-ok,只是ok执行之前会询问 13.3locate命令locate 寻找文件或目录locate file 列出所有跟file相关的文件例如：locate test.txt 查找文件(需要更新库:updatedb) 13.4grep命令grep 在文件中搜索字符串匹配的行并输出grep ftp /etc/services 在services文件中搜索包含ftp的行 14打包与压缩指令14.1gzip命令gzip GNU zip的缩写，用于压缩文件，且只能压缩文件，不能压缩目录，压缩完成之后原文件消失，压缩后的文件以.gz结尾gzip newfile1 压缩newfile1文件 14.2gunzip命令gunzip GUN unzip解压.gz的压缩文件gunzip newfile1.gz 14.3bzip2命令bzip2 与一般的压缩命令不同，这个可以大大提高压缩比，将文件压缩的更小，压缩后文件后缀.bz2bzip2 -k file1 压缩文件file1,压缩后为文件名为file1.bz2,去掉-k压缩完之后将不保留原文件 14.4bunzip2命令bunzip2 解压文件bunzip2 -k file1.bz2 解压file1.bz2文件。解压之后保留原文件，如果不想要原文件，去掉-k注意：.gz和.bz2的命令不能压缩目录，只能压缩文件 14.5tar命令(重要)tar 将目录打包成文件后再压缩tar 选项 打包后的名字 待打包的目录选项有以下几种-c 产生.tar打包文件-v 显示详细信息-f 指定压缩后的文件名-z 打包同时压缩压缩后的文件格式.tar.gztar -zcvf dir1.tar.gz dir1 将dir1文件打包并压缩tar解压命令-x 解包.tar文件-v 显示详细信息-f 指定解压文件-z 解压tar -zxvf dir1.tar.gz 解压dir1文件 14.6zip命令zip 可以压缩文件也可以压缩目录，不同的是压缩目录要加上-r，同样要把压缩后的文件名写在前面，待压缩的文件写在后面,zip比gzip的好处是压缩后原文件并不会消失，同时对于大的文件会显示压缩比。.zip格式的压缩文件是唯一的windows和linux通用的压缩文件zip services.zip /etc/services 压缩文件，将etc目录下的services文件压缩成services.zipzip -r test.zip /test 压缩目录，将test目录压缩成test.zip，记得加-r 14.7unzip命令unzip 解压缩命令unzip 文件名unzip test.zip 解压test.zip文件 15网络通信相关指令15.1write命令write 用户名 向另外一个用户发信息，Ctrl+D结束write root 向root发送信息 15.2wall命令wall 信息 向所有用户发送广播信息wall happy new year 系统中的所有用户均会收到happy new year的消息 15.3ping命令ping ip地址，测试与给定的ip是否连通，如果未连通，测试ping 本机地址，如果依然不能ping通，ping 127.0.0.1ping -s 60000 127.0.0.1 向本机发送60000个数据包（少可能看不出来效果，现在明显看到时间有延迟）ping -c 4 127.0.0.1 发送4次之后自动停止，不加-c 4的话会一直ping,知道按ctrl+c 15.4ifconfig命令ifconfig 查看网络设置信息eth0 实际的物理网卡lo 会话地址网卡ifconfig eth0 192.168.1.1 可以临时改变本机的物理网卡，但是下次启动时会显然显示原来的网卡，这就涉及到linux系统的一般规律，只要改变了配置文件信息，下次才依然生效，命令行修改的只在临时有效。 16进程控制相关指令16.1查看用户最近登录情况lastlastlog 16.2查看硬盘使用情况df 16.3查看文件大小du 16.4查看内存使用情况free 16.5查看进程ps -e | grep nginx 查看所有进程并从中选出nginx的进程信息ps –ef | grep tomcat 查看所有有关tomcat的进程 16.6结束进程kill 1234kill -9 4333 17Linux的软件包管理linux软件包分为二进制软件包管理（RPM,Yum），源代码包安装，脚本安装（shell或java）,Debian系软件包管理 17.1RPM软件包管理RPM软件命令示例sudo-1.7.2pl-5.el5.i386.rpmsudo软件名1.7.2pl版本号5.el5更新号i386硬件平台 17.1.1卸载命令：rpm -e sudo如果与其他软件包有依赖关系，卸载时会有提示信息，可以使用–nodeps命令no dependent 没有依赖关系rpm -e –nodeps sudo 17.1.2安装安装sudo-1.7.2pl-5.el5.i386.rpm1.挂在光盘，虚拟机让他关联系统管盘，在mnt目录下创建目录cdrom,mkdir /mnt/cdrom,之后使用mount命令挂载mount /dev/cdrom /mnt/cdrom,将系统光盘挂在在刚才创建的cdrom下，使用命令ll | grep sudo，查看是否有sudo文件，答案是存在sudo文件。安装命令：rpm -ivh sudo-1.7.2pl-5.el5.i386.rpmi install安装v view安装时查看h hash安装时显示详情信息i是必须的命令：rpm -q sudo查看sudo软件是否安装了命令：rpm -qa|grep sambaa all全部前半部分，查询所有安装的软件包，后半部分，在这些软件包中包含samba关键字命令：rpm -ivh –test sudo-1.8.6p3-24.el6.x86_64.rpmtest测试，不真实的安装，只测试一下命令：rpm -ivh –replacepkgs sudo-1.8.6p3-24.el6.x86_64.rpm覆盖原有的基础上安装 17.1.3RPM其他命令命令：rpm -qa|grep vim 查看所有安装的包含vim文件的文件(all)命令：rpm -ql sudo查询sudo安装后的文件所在位置(location)命令：rpm -qi sudo查询sudo文件的相关信息介绍（information）命令：rpm -qc sudo查询sudo的配置文件信息(conf)命令：rpm -qd sudo查询sudo的帮助文档信息（document） 17.1.4RPM文件的校验我首先修改sudo文件的配置文件，vim /etc/sudo.conf,修改文件命令：rpm -V sudo校验sudo文件，控制台显示的结果是S.5….T. c /etc/sudo.confS size文件大小改变5 md5文件md5的校验值改变L link链接改变T time创建时间改变D device设备文件改变U user文件的用户改变G group文件的用户组改变M 文件权限改变 17.2Yum包管理命令：yum list | grep sudo列出yum源上所有包含文件sudo的文件命令：yum install sudo使用yum方式安装文件sudo命令：yum check-update sudo检查sudo有无更新命令：yum update sudo更新sudo命令：yum info sudo获取sudo软件包信息命令：yum remove sudo卸载sudo命令：yum -help或man yum获取yum的帮助信息 17.3源代码包管理以proftpd为例：去http://www.proftpd.org/ 官网下载.tar.gz的源代码文件到本地，通过xshell上传到服务器1.解压压缩包,命令：tar -xzvf proftpd-1.3.5b.tar.gz2.进入文件内,命令：cd proftpd-1.3.5b3.配置安装位置，命令：./configure –prefix=/test/proftpd/proftpdinstall中间它提示我缺少c编译器，安装无法继续，我就使用yum方法安装gcc用于编译c语言写的文件rpm -q gcc提示gcc未安装yum list|grep gccyum install gcc到此安装gcc完毕4.编译，命令：make5.安装，命令：make install]]></content>
      <categories>
        <category>服务器—linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx代理负载均衡及详细配置]]></title>
    <url>%2F2017%2F12%2F15%2FNginx%E4%BB%A3%E7%90%86%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8F%8A%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.Nginx正向代理和反向代理有很多同学都分不清正向代理和反向代理，下面我尽量用通俗易懂的文字指出二者的区别。首先需要明白代理的意思，代理是指受委托代表当事人从事某种活动。正向代理就是平时说的代理（比如Shadowsocks就是正向代理），是指Nginx代理服务器受客户端委托代理客户端，转发请求，并将从服务端获得的响应返回给客户端；反向代理是指Nginx代理服务器受服务端的委托代理服务端，作为集群的web节点，反向代理一般和负载均衡配合使用。一言以蔽之：正向代理，代理端代理的是客户端；反向代理，代理端代理的是服务端。见下图： nginx做反向代理时根据不同的配置策略，可以进行不同的转发，比如图片结尾的走文件服务器，动态页面走web服务器，而且可以判断被分发的服务器的状态，如果存在异常将转发给其它服务器。 2.负载均衡负载均衡的实现必须依赖于反向代理，Nginx的负载均衡策略有两种：内置策略和扩展策略。内置策略： 轮询：将请求依次轮询发给每个服务器。 最少连接：将请求发送给持有最少活动链接的服务器。 IP哈希：通过哈希函数决定请求发送给哪个服务器。 权重：服务器的权重越高，处理请求的概率越大。 3.Nginx的配置文件nginx.conf是nginx的配置文件，上面提到的代理和负载均衡都需要在配置文件中进行配置，#在配置文件中是注释掉的，不会起作用。12345678910111213141516171819202122232425... #全局块events &#123; #events块 ...&#125;http #http块&#123; ... #http全局块 server #server块 &#123; ... #server全局块 location [PATTERN] #location块 &#123; ... &#125; location [PATTERN] &#123; ... &#125; &#125; server &#123; ... &#125; ... #http全局块&#125; 全局块：一般配置影响nginx全局的指令。一般配置用户组，日志存放路径，pid存放路径和worker_connections； events块：配置nginx服务器与用户的网络连接。 http块：可以嵌套多个server块，配置代理服务器，日志 server块：可以嵌套多个location块，配置代理服务器的相关参数。 location块：配置请求路由和处理请求的页面或服务器。3.1 配置正向代理现在前后端分离已经越来越流行，那么前端开发时可以在本地配置一个nginx正向代理服务器，来代理前端的请求，将其转发至后台服务器中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475########### 每个指令必须以分号结束。##################user nobody; #配置用户或者组，默认为nobody nobody。#worker_processes 1; #允许生成的进程数，默认为1，设置的话一般设置成跟cpu数量相等#pid /nginx/pid/nginx.pid; #指定nginx进程运行文件存放地址error_log log/error.log debug; #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emergevents &#123; accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off #use epoll; #事件驱动模型，仅用于linux2.6以上内核,可以大大提高nginx的性能 worker_connections 1024; #最大连接数 # 并发总数=worker_processes*worker_connections;&#125;http &#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain #access_log off; #取消服务日志 log_format myFormat &apos;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&apos;; #自定义格式 access_log log/access.log myFormat; #combined为日志格式的默认值 sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。 keepalive_timeout 65; #连接超时时间 tcp_nodelay on; #开启gzip压缩 gzip on; gzip_disable &quot;MSIE [1-6].&quot;; #设定请求缓冲 client_header_buffer_size 128k; large_client_header_buffers 4 128k; #设定虚拟主机配置 server &#123; #侦听1000端口(可以随意设定成你想要的未占用的端口) listen 1000; #定义使用 localhost访问(设定成你本地的IP地址或localhost) server_name localhost; #定义服务器的默认网站根目录位置 root html; #设定本虚拟主机的访问日志 access_log logs/nginx.access.log main; #默认请求 location / &#123; index index.html index.htm; #定义首页索引文件的名称 &#125; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; location ~* \.(html|js|css|png|jpg|jpeg|gif|ttf)$ &#123; proxy_pass http://127.0.0.1:63342; #访问http://localhost:1000/项目名/以html，js,css等结尾的文件请求均会被转发至http://127.0.0.1:63342;服务器中 &#125; location ~* \.*$ &#123; proxy_pass http://192.168.27.100:8180; #访问http://localhost:1000/项目名/任意路径的请求均会被转发至http://192.168.27.100:8180服务器中 &#125; #禁止访问 .ht结尾的文件 location ~ /.ht &#123; deny all; &#125; &#125;&#125; 我们最常配置的地方是location里面的代理服务器地址，这里要注意的是，1要把拦截小范围请求的放在前面，把拦截大范围请求的配置放在后面，因为像这里：location ~ .$ 拦截以结尾的请求(即所有请求)，如果它放在前面了，那么请求再也走不到location ~ .(html|js|css|png|jpg|jpeg|gif|ttf)$这个配置里面了（在前面已经被拦截到了）。2.还是要注意检查结尾，我之前踩过一个坑，nginx配置文件是直接拷过来的，当时配置的location ~* .do$,此意为拦截以.do结尾的请求（java中可以配置），但我真正的请求是以.action结尾的，所以不会被拦截到，亦即不会被转发至后台服务器中，导致每次请求均是404。 3.2 配置负载均衡配置负载均衡时Nginx充当的是反向代理服务器，当请求进来时，根据相应的负载策略，将请求分发至不同的处理器进行处理，配置步骤如下： 3.2.1 添加节点在http块下，添加upstream节点。1234upstream mytest &#123; server 192.168.1.1:8081; server 192.168.1.2:8082; &#125; mytest可以改成任何你喜欢的变量， 3.2.2 配置路径将server块下的location节点中的proxy_pass配置为：http:// + upstream名称，即“http://mytest”。12345location / &#123; root html; index index.html index.htm; proxy_pass http://mytest; &#125; 现在负载均衡初步完成了。upstream按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器(比如第一个请求进来就交给第一个服务器处理，第二个请求进来就交给第二个服务器处理)，如果后端服务器down掉，能自动剔除。虽然这种方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡（比如明明一台服务器性能很强他处理的请求跟低配的服务器一样，那肯定是资源的浪费，要让”年轻力壮”的比”老弱病残”的处理更多的请求）。适用于图片服务器集群和纯静态页面服务器集群。所以除此之外，upstream还有其它的负载策略，分别如下： 3.2.3 weight（权重）指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。如下所示，192.168.1.2:8082的访问比率要比192.168.1.1:8081的访问比率高一倍。1234upstream mytest&#123; server 192.168.1.1:8081 weight=5; server 192.168.1.2:8082 weight=10; &#125; 3.2.4 ip_hash（按访问IP进行哈希计算）每个请求按访问IP的hash结果分配，这样每个访客固定访问一个后端服务器，同时也解决了session的问题。12345upstream mytest&#123; ip_hash; server 192.168.1.1:8081; server 192.168.1.2:8082; &#125; 3.2.5 fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。与weight分配策略类似。12345upstream mytest&#123; server 192.168.1.1:8081; server 192.168.1.2:8082; fair; &#125; 3.2.6 url_hash（第三方）按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。注意：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。123456upstream mytest&#123; server 192.168.1.1:8081; server 192.168.1.2:8082; hash $request_uri; hash_method crc32; &#125; 上面是常用的几种负载均衡策略及配置，其实upstream还可以为每个服务器设置状态值，这些状态值的含义分别如下： down ：落下（宕机），表示当前的server暂时不参与负载。 weight ：权重，默认为1。weight越大，负载的权重就越大。 max_fails ：最大失败次数，允许请求失败的次数默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误. fail_timeout ：失败超时时间，max_fails次失败后，暂停的时间。 backup：备份，其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。1234567upstream mytest&#123; #定义负载均衡设备的Ip及设备状态 ip_hash; server 192.168.1.1:9090 down; server 192.168.1.1:8080 weight=2; server 192.168.1.1:6060; server 192.168.1.1:7070 backup; &#125; 以上简单介绍了nginx的应用，基本可以满足平时的开发需要，以后如果有哪些补充再进行追加。]]></content>
      <categories>
        <category>服务器—nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud中使用Hystrix保护应用]]></title>
    <url>%2F2017%2F12%2F14%2Fspringcloud%E4%B8%AD%E4%BD%BF%E7%94%A8Hystrix%E4%BF%9D%E6%8A%A4%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.Hystrix入门示例1.1目前存在的问题当前项目中如果服务提供者的响速度十分缓慢，导致消费者请求一直处于等待状态，资源得不到释放，一旦请求积累过多，资源耗尽，就会导致服务不可用。顺便提一个名词雪崩效应就是这么引起的，比如存在服务ABCD，服务B是服务A的消费者，服务C，D又是服务B的消费者，服务A的不可用，随后引起服务B的不可用，进而导致服务C,D都不可用，这种因服务提供者的不可用导致消费者不可用，并将服务不可用状态放大的过程就是雪崩效应。那么如何避免雪崩效应的发生呢： 超时机制通过网络请求服务时必须设置超时时间。正常请求时，一般会很快获得响应，当服务提供者不可用或者网络不可用时响应时间都会变的很长，这将会导致请求者会一直等待响应，而每个请求都会对应指定的线程或进程，那么这些资源将无法释放，一般请求堆积或并发量高时就会拖坏这个应用，所以设置超时时间很有必要，在规定的时间内，如果没有获得响应，就默认这个请求失败，释放请求占用的资源。 熔断机制这个类似于家用断路器，当发生火灾或线路过载等问题时，断路器就会自动断开（跳闸），我们这里的熔断就是也是同样的道理，比如设置请求超时时间是1秒，一连100个请求都没获得响应，那么基本就可以判断这个服务挂了，为了避免资源的浪费，没有必要再去访问这个不可用的服务了，可以采用断路器断开这个服务。最后再补充一下监控。1.2简单的Hystrix的示例 引入jar1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 老规矩，使用某个组件的功能，首先要在pom文件中引入这个文件的jar Main方法中加入断路器的注解@EnableCircuitBreaker1234567891011121314@SpringBootApplication@EnableEurekaClient@RibbonClient(name=&quot;microservice-provider-user&quot;,configuration = BalanceConfiguration.class)@EnableCircuitBreakerpublic class MicroserviceConsumerMovieRibbonWithHystixApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123;SpringApplication.run(MicroserviceConsumerMovieRibbonWithHystixApplication.class, args); &#125;&#125; @EnableCircuitBreaker的作用是声明这个主方法已经引入了断路器的注解，可以使用断路器了。 实际调用方法中加入出现错误之后的处理方法，并用fallbackMethod指向这个方法123456789101112131415161718@RestControllerpublic class MovieController &#123; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/simple/&#123;id&#125;&quot;) @HystrixCommand(fallbackMethod =&quot;findUserByIdFallBack&quot; ) public User findUserById(@PathVariable Long id)&#123; return restTemplate.getForObject(&quot;http://microservice-provider-user/simple/&quot;+id, User.class); &#125; public User findUserByIdFallBack(Long id)&#123; User user = new User(); user.setId(1L); user.setUsername(&quot;出错了&quot;); return user; &#125;&#125; 定义一个方法findUserByIdFallBack作为服务提供者不可用时的处理方法，注意这个方法与原调用方法findUserById参数用和返回类型必须一致，并用@HystrixCommand指定提供者不可用时调用此方法作为响应。 application.yml中加入超时时间1hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 5000 #设置超时时间为5秒 配置文件中加入Hystrix的超时时间，这里设置的5秒，但并不是必须。 测试依次启动注册中心，服务提供者user，服务消费者movie，第一次正常调用获得响应，随后将提供者user的服务停掉，再次调用发现返回的是我们定义的服务出错时的信息。2.健康指标（Health Indicator）和指标流（metrics stream） 健康检查 ：健康检查就是通过访问 http://你的服务ip:你的服务端口/health 来确定服务的可用状态，上面的一开始是可用的（UP），当把提供者停掉之后，再重复的刷新调用者，触发断路器，发现健康检查里面就会提示服务不可用 。 Hystrix指标流：若想使用Hystrix的指标流需要引入spring-boot-starter-actuator的依赖。1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 使用Hystrix指标流可以将/hystrix.stream作为管理端点，访问http://你的服务ip:你的服务端口/hystrix.stream 可以查看项目运行的各个指标。说白了hystrix.stream其实就是一个监控，监控每个API的运行状态，但是它的可读性很差，整页整页的代码不便查看，后面将会说Hystrix的仪表盘（Hystrix Dashboard）。 3.Feign对Hystrix的支持3.1引入Hystrix的jar依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 3.2给Main方法加入@EnableCircuitBreaker12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClients@EnableCircuitBreakerpublic class MicroserviceConsumerMovieFeignWithHystrixApplication &#123; public static void main(String[] args) &#123;SpringApplication.run(MicroserviceConsumerMovieFeignWithHystrixApplication.class, args); &#125;&#125; 加入@EnableCircuitBreaker注解表明这个模块对断路器是支持的。 3.3实现自定义Feign的接口并在这个接口里面写服务不可用的处理方式12345678910@Componentpublic class UserFeignFallBack implements UserFeign&#123; @Override public User findUserbyId(Long id) &#123; User user = new User(); user.setId(-1L); user.setUsername(&quot;服务者出错了&quot;); return user; &#125;&#125; UserFeign就是我们自己定义的那个调用服务的接口客户端，UserFeignFallBack是出错时的处理类，里面重写方法，在其内写出错处理代码。注意UserFeignFallBack类要被Spring管理，添加@Component注解，不然报错。 3.4在Feign客户端中指明出错时的处理类12345@FeignClient(name = &quot;microservice-provider-user&quot;, fallback = UserFeignFallBack.class)public interface UserFeign &#123; @RequestMapping(value = &quot;/simple/&#123;id&#125;&quot;,method = RequestMethod.GET) public User findUserbyId(@PathVariable(&quot;id&quot;) Long id);&#125; 上面的UserFeignFallBack类就是实现的这个UserFeign接口，现在在这个接口上面添加fallback时的处理类为UserFeignFallBack.class，现在就已经写完了，可以起服务进行测试。 4.Hystrix Dashboard的使用上面我们说过当我们使用指标流，即访问http://192.168.0.12:7909/hystrix.stream 可以看到项目的运行指标，但是可读性很差，如果有一种图形化的界面可以直观的反映出项目的运行状况就非常棒了，确实存在这样的一个东西，那就是Hystrix Dashboard。首先我们需要创建一个Dashboard项目。 新建项目microservice-hystrix-dashboard，引入spring-cloud-starter-hystrix-dashboard的jar。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; main方法中加入@EnableHystrixDashboard注解 12345678@SpringBootApplication@EnableHystrixDashboardpublic class MicroserviceHystrixDashboardApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceHystrixDashboardApplication.class, args); &#125;&#125; yml配置文件中配置端口号 12server: port: 8030 启动项目访问：http://localhost:8030/hystrix 会看到如下界面：在地址栏中输入你要访问的项目的hystrix.stream可以看到如下页面，这里反映的就是项目运行状态。 5.Turbin的使用使用Dashboard可以获取访问实例的状态，但是生产环境中通常是集群部署，监控单一项目意义不大，Turbin可以做一个数据的聚合，达到监控整个集群的目的。 创建microservice-hystrix-turbin项目，并引入spring-cloud-starter-turbine的jar 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt; &lt;version&gt;1.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; main方法中注入EnableTurbine注解 12345678@SpringBootApplication@EnableTurbinepublic class MicroserviceHystrixTurbinApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceHystrixTurbinApplication.class, args); &#125;&#125; yml文件中配置要聚合的实例 12345678910111213141516server: port: 8031spring: application: name: microservice-hystrix-turbineeureka: client: serviceUrl: defaultZone: http://admin:qwe123@localhost:8761/eureka instance: prefer-ip-address: trueturbine: aggregator: clusterConfig: default appConfig: microservice-consumer-movie-ribbon-with-hystrix,microservice-consumer-movie-feign-with-hystrix clusterNameExpression: &quot;&apos;default&apos;&quot; 比如我这里要监控的是microservice-consumer-movie-ribbon-with-hystrix和microservice-consumer-movie-feign-with-hystrix项目。之后分别启动注册中心，消费者，服务者，turbin和dashboard项目，在dashboard项目中访问turbin项目的指标流即可看到聚合项目的运行状况。]]></content>
      <categories>
        <category>后台—springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud中使用Ribbon和Feign调用服务以及服务的高可用]]></title>
    <url>%2F2017%2F12%2F14%2Fspringcloud%E4%B8%AD%E4%BD%BF%E7%94%A8Ribbon%E5%92%8CFeign%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.消费者使用Ribbon组件负载均衡的调用服务者接口在上一节中只介绍了如何将服务者和消费者注册到Eureka注册中心中，消费者并没有调用服务者，现在开始介绍，首先为了避免混淆，不再用上一节的消费者，重新建一个名为microservice-consumer-movie-ribbon的消费者，代码跟microservice-consumer-movie的一样，下面介绍如何负载均衡的调用。 1.1 使用Ribbon默认的轮询方式调用服务者 引入jar包如果调用者要使用Ribbon实现调用服务者的负载均衡首先想到的是引入Ribbon的jar包，这里Eureka中已经包含了此jar，我们上一节已经引入了Eureka的jar，这里可以不用再引入了。 Main方法中引入@LoadBalanced负载均衡注解在MicroserviceConsumerMovieRibbonApplication的创建调用实例对象RestTemplate中加入注解@LoadBalanced注解，默认是轮询。 1234567891011@SpringBootApplication@EnableEurekaClientpublic class MicroserviceConsumerMovieRibbonApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceConsumerMovieRibbonApplication.class, args); &#125;&#125; 启动两个或两个以上服务者进行测试启动注册中项目和服务者，消费者项目，这里因为要测负载均衡，所以至少要启动两个服务者才行。启动完第一个服务者之后，修改application.yml的端口号，接着启动第二个服务者，如下图：经过以上步骤即可创建另一个服务者实例MicroserviceProviderUserApplication2，启动它将其注册到注册中心中。访问消费者的项目，多刷新一次会发现交替调用服务者MicroserviceProviderUserApplication和MicroserviceProviderUserApplication2，测试成功。 1.2自定义负载均衡算法调用服务者可以自己定义一个负载均衡策略的类，我这里定义一个随机策略。 123456789101112131415/** * @author 刘俊重 * @Description 负载均衡配置,配置调用者调用服务者的调用策略 * @date 13:56 */@Configurationpublic class BalanceConfiguration &#123; /** * @Description 定义随机调用的负载均衡算法 */ @Bean public IRule ribbonRule()&#123; return new RandomRule(); &#125;&#125; 在Main方法中，RibbonClient注解中指明调用某个服务使用某个指定的策略。1@RibbonClient(name=&quot;microservice-provider-user&quot;,configuration = BalanceConfiguration.class) 调用microservice-provider-user服务时，使用BalanceConfiguration定义的负载均衡策略，完整的代码如下：1234567891011121314@SpringBootApplication@EnableEurekaClient@RibbonClient(name=&quot;microservice-provider-user&quot;,configuration = BalanceConfiguration.class)public class MicroserviceConsumerMovieRibbonApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceConsumerMovieRibbonApplication.class, args); &#125;&#125; 注意：所有用到Ribbon负载均衡的均要有@LoadBalanced注解，只是我们没有定义自己的调用策略时，默认会使用轮询的策略。同时这里有坑，不能把定义的策略类BalanceConfiguration放在Main方法同级或子包下面，会有冲突（或者你自己用注解@ComponentScan再写方法，不让spring扫描这个自定义的策略类），官方文档中写的非常清楚，不懂的可以看看：https://springcloud.cc/spring-cloud-dalston.html#_customizing_the_ribbon_client 1.3使用配置文件自定义RibbonClient实现客户端负载均衡springcloud从1.2.0版本之后支持通过自定义配置文件的方式配置负载均衡策略。官方在application.yml中这样配置的：123users: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule 你只需要把users改成你的服务提供者的应用名称即可，WeightedResponseTimeRule可以配置成其他的策略，这里为了不影响其它代码，我再重新创建一个microservice-consumer-movie-ribbon-custom-properties项目。之前Main方法的@RibbonClient可以去掉了，application.yml中这么配置：123microservice-provider-user: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 这段配置的意思就是通过Ribbon调用microservice-provider-user服务时采用RandomRule（随机）的策略。小结：消费者调用服务者时，我们使用Ribbon实现请求的负载均衡，而且Eureka的jar中已经集成了Ribbon，不用再引jar包即可直接使用。使用有三种方法：1.直接在RestTemplate实例中添加@LoadBalanced即可实现默认轮询的负载均衡，2.自定义负载均衡策略类，并在RibbonClient中引入这个策略类，3.在yml配置文件中自定义负载策略，其中第三种比较方便。 2.使用Ribbon不使用Eureka为防止污染其它代码，再创建一个microservice-consumer-movie-ribbon-without-eureka项目，用来演示使用Ribbon时不适用Eureka。官方文档中在application.yml中这样配置：123stores: ribbon: listOfServers: example.com,google.com 意为通过ribbon调用stores不适用Eureka中注册的服务者，而是调用example.com和google.com这两个服务。那我也这样做，配置文件如下：123microservice-provider-user: ribbon: listOfServers: localhost:7100 当使用ribbon调用microservice-provider-user服务时调用localhost:7100的服务，虽然Eureka中microservice-provider-user注册了好几个服务提供者（比如localhost:7100，localhost:7101，localhost:7102），但只会调用localhost:7100，这就是使用Ribbon不使用Eureka。注意：@LoadBalanced注解不要落下，因为listOfServers这里也可以配置多个主机，同样需要负载均衡。文档地址：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon-without-eureka 3.在Ribbon中禁用Eurekaapplication.yml中这样配置即可：123ribbon: eureka: enabled: false 文档地址：https://springcloud.cc/spring-cloud-dalston.html#_example_disable_eureka_use_in_ribbon 4.声明式的Rest客户端:FeignFeign是一种声明式的Web服务客户端，通过它可以方便的调用服务提供者的服务。使用Feign的步骤如下： 引入Feign的jar 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 自定义Feign客户端类 1234567891011/** * @Description 用户自定义Feign客户端 * @Author 刘俊重 * @Date 2017/11/8 */@FeignClient(&quot;microservice-provider-user&quot;)public interface UserFeign &#123; @RequestMapping(value = &quot;/simple/&#123;id&#125;&quot;,method = RequestMethod.GET) public User findUserbyId(@PathVariable(&quot;id&quot;) Long id);&#125; @FeignClient注明要调用的服务microservice-provider-user，public User findUserbyId(@PathVariable(“id”) Long id)这个接口是服务提供者接受调用的。 Main方法中加入@EnableFeignClients表明这个Feign客户端 1234567@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class MicroserviceConsumerMovieFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceConsumerMovieFeignApplication.class, args); &#125;&#125; 消费者调用端注入自定义的Feign客户端，发起调用请求。 123456789@RestControllerpublic class MovieController &#123; @Autowired private UserFeign userFeign; @GetMapping(&quot;/simple/&#123;id&#125;&quot;) public User findUserById(@PathVariable Long id)&#123; return userFeign.findUserbyId(id); &#125;&#125; 自定义了Feign客户端就不需要再使用RestTemplate调用了，现在的调用顺序是调用者通过调用自定义Feign客户端调用，自定义的Feign客户端又通过@FeignClient声明要调用的服务，通过跟服务者同名的方法调用。但是这里还有几个坑： @GetMapping不支持,需要使用@RequestMapping，在括号里面指定请求方式。 @PathVariable得设置value，@PathVariable(“id”)如果没有(“id”)会报错 Feign里面方法的参数如果是复杂对象（引用数据类型），即使你通过method = RequestMethod.GET指定这个get请求，请求到达服务提供者时依然是以Post请求方式到达的。5.覆盖Feign的默认值（自定义Feign的配置方式）默认情况下，Feign使用的是SpringMvcContract（Springmvc的契约），可以在Feign客户端中使用1@RequestMapping(value = &quot;/simple/&#123;id&#125;&quot;,method = RequestMethod.GET) 这种方式调用服务者，但是假如我们不想采用这种方式，而是通过自定义的方式那就可以定义这样一个类。 定义Feign配置类，覆盖默认配置 1234567891011/** * @author 刘俊重 * @Description 自定义Feign的配置 */@Configurationpublic class CustomFeignConfiguration &#123; @Bean public Contract feignContract() &#123; return new feign.Contract.Default(); &#125;&#125; 在Feign客户端中引入刚才定义的配置类 12345@FeignClient(name=&quot;microservice-provider-user&quot;,configuration = CustomFeignConfiguration.class)public interface UserFeign &#123; @RequestLine(&quot;GET /simple/&#123;id&#125;&quot;) public User findUserbyId(@Param(&quot;id&quot;) Long id);&#125; 因为我们已经覆盖了Feign的默认配置，自定义了CustomFeignConfiguration，里面定义契约不再采用springmvc的而是采用Feign的，所以这里请求注解@RequestMapping要改成@RequestLine，相应参数也要改变了，不然会报错。参考文档：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign-overriding-defaults 6.解决Feign第一次请求超时的问题在实际测试中发现如果机器配置比较低，第一次使用Feign调用服务者时经常会出现超时的现象，之后再调用就没有问题了，可以通过以下方法解决。123456# 解决第一次请求报超时异常的方案：# hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 5000 (将请求超时时间设为5秒)# 或者： （直接禁用超时提醒）# hystrix.command.default.execution.timeout.enabled: false# 或者：feign.hystrix.enabled: false ## 索性禁用feign的hystrix支持 Eureka的高可用设置Eureka在这里充当的是注册中心的作用，所以必须要保证高可用，每个Eureka服务器同时也是一个Eureka客户端，同时还需要至少一个服务来定位对等体。Eureka的高可用可以采用下面的步骤来完成。 application.xml中配置多个Eureka对等体12345678910111213141516171819202122232425spring: application: name: EUREKA-HA---server: port: 8761spring: profiles: peer1eureka: instance: hostname: peer1 client: serviceUrl: defaultZone: http://peer2:8762/eureka/---server: port: 8762spring: profiles: peer2eureka: instance: hostname: peer2 client: serviceUrl: defaultZone: http://peer1:8761/eureka/ 上面的意思就是定义一个应用名为EUREKA-HA，定义一个profiles名为peer1,它的主机名是peer1，将其注册到http://peer2:8762/eureka/ 服务器上，peer2跟它同理，现在peer1跟peer2就是对等体（名字可以随便定）。 window系统修改hosts文件。进入“C:\Windows\System32\drivers\etc”，修改hosts文件 1127.0.0.1 peer1 peer2 依次启动peer1和peer2。启动pee1时可能会报错，因为它要把服务注册到peer2上，但是peer2还未启动，不用管它，访问http://localhost:8761 ,发现什么都没有；接着启动peer2，访问http://localhost:8762 ，发现8761和8762都注册在了8762上，此时在刷新8761的浏览器页面发现8761和8762已经都在了，因为peer1和peer2是对等体，他们互相注册，服务注册表也是共享了，由此就组成了Eureka的高可用。启动peer1和peer2图片如下图（Active profiles必须配置，否则报错）：注意：如果你引入了spring-boot-starter-security包，但是并没有指定用户名和密码，那么Eureka会为你生成一个随机密码，导致你登录不上，所以请不要引入spring-boot-starter-security或者自己指定密码。参考地址：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-eureka-server-zones-and-regions总结：本节首先是将服务提供者和消费者注册在了Eureka的注册中心上，之后消费者通过两种方式调用服务者，一种是Ribbon负载均衡调用，一种是用Feign客户端调用，当然在每种调用方式中都可以进行自定义配置；鉴于Eureka注册中心的地位非常重要，一旦宕机将导致其它服务都不可用，所以需要保证Eureka注册中心的高可用。代码地址：https://gitee.com/catchu/springcloud-study]]></content>
      <categories>
        <category>后台—springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud将服务者和消费者注册到注册中心(Eureka)]]></title>
    <url>%2F2017%2F12%2F14%2Fspringcloud%E5%B0%86%E6%9C%8D%E5%8A%A1%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%B3%A8%E5%86%8C%E5%88%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-Eureka%2F</url>
    <content type="text"><![CDATA[1.服务注册和发现的一些术语解释1.1服务发现组件的功能 服务注册表：服务注册表是一个记录当前可用服务实例的数据库，是服务发现机制的核心。服务注册表提供查询API和管理API，通过查询Api可以查看当前可用的服务实例，通过管理Api可以注册或注册实例。 服务注册：就是服务在启动时，将服务实例的网络地址注册到服务注册表中 健康检查：服务注册表会通过某些机制（如心跳监测）定期检查已注册的服务，如果发现某个服务不可用，就将其从注册表中移除。 服务注册组件：不同人的称谓可能不同，不过说的都是一个组件，有的称为注册中心，服务注册，服务发现，在这里统一称为服务注册发现组件（如Dubbo使用Zookeeper,Edas使用阿里自己定制的AliTomcat，我们这里使用Netfix提供的Eureka，当然springcloud也支持其它的注册发现组件）。1.2服务注册发现方式不同的框架用的组件可能不能，不过总的来说有客户端发现和服务端发现，Eureka和Zookeeper使用客户端发现方式，Consul属于服务端发现方式。2.将服务端和客户端注册到Eureka注册组件中今天介绍的内容均可以查看这里的中文文档：https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_netflix 。2.1创建Eureka服务注册组件项目这里的注册中心跟zookeeper不同，zookeeper启动之后再启动服务即可注册实例，我们这里需要自己开发注册中心项目。使用IDEA创建名为microservice-discovery-eureka的项目，pom中引入 spring-cloud-starter-eureka-server的jar包。12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在MicroserviceDiscoveryEurekaApplication方法中添加注解@EnableEurekaServer，表明这是一个服务注册组件的服务端1234567@SpringBootApplication@EnableEurekaServerpublic class MicroserviceDiscoveryEurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceDiscoveryEurekaApplication.class, args); &#125;&#125; 将application.porperties注册文件改名为application.yml，之后进行配置。12345678server: port: 8761eureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://localhost:8761/eureka Eureka的默认端口就是8761，其中“defaultZone”是一个魔术字符串后备值，为任何不表示首选项的客户端提供服务URL（即defaultZone是有用的默认值）。现在就可以启动这个Main方法，之后再浏览器中输入http://localhost:8761 ,打开页面如下： 2.2将服务者注册到Eureka中首先引入jar包spring-cloud-starter-eureka，这里引的跟上面引的jar不一样，上面的服务端，这里的是客户端。12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在之前的main方法中添加@EnableEurekaClient注解，表明它是客户端。1234567@SpringBootApplication@EnableEurekaClientpublic class MicroserviceProviderUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceProviderUserApplication.class, args); &#125;&#125; 修改application.yml配置文件，配置应用实例名称，应用访问方式等。123456789101112131415161718192021server: port: 7900spring: jpa: generate-ddl: false show-sql: true hibernate: ddl-auto: none datasource: platform: h2 schema: classpath:schema.sql data: classpath:data.sql application: name: microservice-provider-user #应用名称eureka: client: #配置eureka客户端 service-url: defaultZone: http://localhost:8761/eureka instance: prefer-ip-address: true #配置在eureka中显示ip地址 instance-id: $&#123;spring.application.name&#125;:$&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125; #配置应用访问方式。应用名:IP:端口号 现在启动服务者项目即可将服务注册到Eureka中，刷新eureka的页面可看到注册的服务实例。 2.3将调用者注册到Eureka中调用者和服务者注册到Eureka的方式一样，首先引入spring-cloud-starter-eureka的jar包，之后给main方法配置@EnableEurekaClient注解，再修改application.yml的配置文件，不再赘余。123456789101112server: port: 7901spring: application: name: microservice-consumer-movie #配置项目名eureka: client: #配置要访问的注册中心地址，即eureka所在的地址 service-url: defaultZone: http://localhost:8761/eureka instance: #配置是否显示ip prefer-ip-address: true instance-id: $&#123;spring.application.name&#125;:$&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125; 至此服务者和调用者均已经注册到服务注册组件Eureka中了，刷新http://localhost:8761/ 即可查看，至于如何调用，下一节介绍 3.补充知识补充身份认证和健康检查。 3.1身份认证在Eureka的项目中引入springboot提供的安全认证jar包,服务者和调用者不用引入。12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;1.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在application.yml中配置要访问的用户名和密码，注册中心，服务者，消费者均要修改访问路径跟Eureka中defaultZone的一致。1234567891011121314security: basic: enabled: true user: name: admin password: qwe123server: port: 8761eureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://admin:qwe123@localhost:8761/eureka 这样在访问http://localhost:8761/ 的时候就需要输入用户名和密码了。 3.2健康检查微服务中要想保证服务可用就必须要保证每个服务均是可用的，Eureka中提供了健康检查机制，检测到某个服务不可用会将其从注册表中移除，下面介绍如何进行健康检查： 在每一个需要注册到注册中心的服务项目中都引入spring-boot-starter-actuator的jar包（Eureka项目中不引入） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;1.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在每个要注册到注册中心的项目的application.yml中都加入 healthcheck:enabled: true的配置（Eureka的配置文件不加）。示例如下： 12345678910111213141516server: port: 7901user: userServicePath: http://localhost:7900/simple/spring: application: name: microservice-consumer-movie #配置项目名eureka: client: #配置要访问的注册中心地址，即eureka所在的地址 healthcheck: enabled: true service-url: defaultZone: http://admin:qwe123@localhost:8761/eureka instance: #配置是否显示ip prefer-ip-address: true instance-id: $&#123;spring.application.name&#125;:$&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125; 这样在某个服务不可用是就会从注册表中剔除。]]></content>
      <categories>
        <category>后台—springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SpringCloud构建简单的服务者和消费者]]></title>
    <url>%2F2017%2F12%2F14%2F%E4%BD%BF%E7%94%A8SpringCloud%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[0.SpringCloud的特点Springcloud具有下列特点： 约定优于配置； 开箱即用，快速启动（springboot可以以jar或war的方式启动） 适用于多种环境（Pc Server、Docker） 组件轻量，选型中立（例如注册中心可以是Eureka、Consul、Zookeeper） 组件丰富，功能齐全（注册中心，配置中心，智能路由，负载均衡，熔断机制）1.创建springboot的项目springcloud分布式项目里面的每个小项目都是springboot项目，所以首先搭建springboot项目（这里不主要讲），有两种方法，我使用的编辑器是inteiilij idea. 方法一：File—— new Project ——左侧选择Spring Initializr（如果没有这个选项，在插件里面搜索spring boot并安装，之后重启idea），右侧选择jdk版本，default选项不用管，之后接着下一步下一步选择依赖（具体方法网上写的有，可以参考：http://blog.csdn.net/yxl8359026/article/details/51464041） 方法二：直接到http://start.spring.io/ 填写项目信息和依赖的服务，之后生成一个压缩包，解压缩就是一个maven类的项目，直接导入编辑工具即可。至此服务者microservice-simple-provider-user和消费者microservice-simple-consumer-movie创建完毕。2.配置springboot的application.yml配置文件默认生成之后是application.properties格式的文件，直接把后缀名改为yml结尾的即可，yml格式的是类似于树型结构的配置文件，示例如下：12345678910111213141516171819server: port: 7900spring: jpa: generate-ddl: false show-sql: true hibernate: ddl-auto: none datasource: platform: h2 schema: classpath:schema.sql data: classpath:data.sqllogging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACE com.catchu: DEBUG 这种yml的配置文件首先需要idea识别你的maven工程，才会给出提示，不然不会提示，自己写的话容易出错（yml对格式要求比较严），树型配置文件，与我们熟悉的properties的差不多，比如server:port:7900就相当于server.port=7900。上面配置的意思是配置端口为7900，配置jpa和数据源（为模拟简便使用h2数据库），配置日志级别。 3.开发服务提供者为模拟简单，这里直接用controller调用dao，不在写业务层，dao直接继承JpaRepository。12345678910111213package com.catchu.microservice.dao;import com.catchu.microservice.entity.User;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;/** * @author 刘俊重 * @Description 用户数据访问层 * @date 18:06 */@Repositorypublic interface UserDao extends JpaRepository&lt;User,Long&gt;&#123;&#125; controller代码如下：123456789101112131415161718192021package com.catchu.microservice.controller;import com.catchu.microservice.dao.UserDao;import com.catchu.microservice.entity.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;/** * @author 刘俊重 * @Description * @date 18:09 */@RestControllerpublic class UserController &#123; @Autowired private UserDao userDao; @GetMapping(&quot;/simple/&#123;id&#125;&quot;) public User findUserbyId(@PathVariable Long id)&#123; return userDao.findOne(id); &#125;&#125; 至此提供者写完了，直接运行根包下面的main项目即可，不用单独配置tomcat，浏览器访问http://localhost:7900/simple/3 接收到返回的数据。 4.开发服务消费者同样是先配置application.yml文件，本例中配置一下端口即可，随后在main方法中创建RestTemplate示例对象，来调用服务者的接口。1234567891011121314@SpringBootApplicationpublic class MicroserviceSimpleConsumerMovieApplication &#123; /** * @Description 在这里创建RestTemplate实例供其他调用者调用消费者 * @Author 刘俊重 * @Date 2017/10/30 */ @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceSimpleConsumerMovieApplication.class, args); &#125;&#125; 在消费者的控制层中调用服务者的控制层。1234567891011121314151617181920212223/** * @author 刘俊重 * @Description 电影服务控制层 * @date 18:29 */@RestControllerpublic class MovieController &#123; /** * @Description restTemplate名字与MicroserviceSimpleConsumerMovieApplication里面@bean创建的对象名要一样 */ @Autowired private RestTemplate restTemplate; @Value(&quot;$&#123;user.userServicePath&#125;&quot;) private String userServicePath; /** * @Description 使用restTemplate对象调用服务者——用户模块 */ @GetMapping(&quot;/simple/&#123;id&#125;&quot;) public User findUserById(@PathVariable Long id)&#123; return restTemplate.getForObject(userServicePath+id, User.class); &#125;&#125; 到这里消费者已经写好了，直接启动main方法，访问http://localhost:7901/simple/3 就可以看到调用了7900端口下的服务。总结：首先创建服务的提供者和消费者两个项目，之后修改配置文件，编写服务者和消费者。两个项目是独立的单元，都有自己的控制层，业务层，可以独立部署运行，但它们之前的服务又互相调用；同时服务依赖太严重又会导致不稳定，之后介绍使用注册中心的服务注册和发现。代码地址：https://gitee.com/catchu/springcloud-study]]></content>
      <categories>
        <category>后台—springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven项目打包遇到的两个问题]]></title>
    <url>%2F2017%2F12%2F14%2FMaven%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[项目部署上线时需要打包，我们的项目是采用maven工程，打包时碰到过两个问题，做下记录： 1.Maven如何打入本地jar包使用支付宝API时发现有些jar没有在中央仓库中，只能从支付宝下载jar，然后引入到项目中，这种情况下再使用平时的打包方式存在问题，需要做如下处理： 我在与src并列的目录下新建一个lib的文件夹，将支付宝的alipay-sdk-java-ALL20171128134549.jar包放在这个文件夹里面。 pom的依赖中这样写： 1234567 &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;ALL20171128134549&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;basedir&#125;/lib/alipay-sdk-java-ALL20171128134549.jar&lt;/systemPath&gt;&lt;/dependency&gt; pom的引入插件中这样写： 1234567891011121314151617181920&lt;plugins&gt; &lt;!--打包war,引入lib下的jar--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;warName&gt;$&#123;project.artifactId&#125;&lt;/warName&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;lib/&lt;/directory&gt; &lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 这样就可以在部署时将本地jar包打入war包中了。 2.使用maven的profiles动态选择配置文件日常开发中通常会有开发环境和生产环境，配置文件一般都是在xxx.properties中配置着，如果变动比较少还尚可采用注释掉不用的配置，放开需要的配置，但是如果生产和开发好多配置文件都不一样，每次打包之前都要不停的改动，不紧浪费时间，而且顾此失彼容易出错，maven的profiles可以解决这个问题，我们只需要勾选需要的环境，就可以动态的打包出不同的配置了。如下图： pom.xml中的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;ALL20171128134549&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;basedir&#125;/lib/alipay-sdk-java-ALL20171128134549.jar&lt;/systemPath&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;env&gt;prod&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;build&gt; &lt;finalName&gt;scm&lt;/finalName&gt; &lt;filters&gt; &lt;filter&gt;src/main/resources/profiles/$&#123;env&#125;.properties&lt;/filter&gt; &lt;/filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--打包war,引入lib下的jar--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;warName&gt;$&#123;project.artifactId&#125;&lt;/warName&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;lib/&lt;/directory&gt; &lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;!-- &lt;url&gt;http://192.168.25.138:8080/manager/text&lt;/url&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;password&gt;tomcat&lt;/password&gt; --&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; dev.properties的配置 123456789101112131415profile.env=dev#支付宝网关alipay.gateway = https://openapi.alipaydev.com/gateway.do#支付宝appidalipay.app.id = appid#私钥alipay.private.key = 私钥#公钥alipay.public.key =公钥#支付宝授权登录页alipay.url = https://openauth.alipaydev.com/oauth2/publicAppAuthorize.htm#支付宝授权成功之后的回调地址redirect.url = 回调地址#我们自己网站的域名,用于重定向至错误页面web.site = www.baidu.com prod.properties的配置 123456789101112131415profile.env=prod#支付宝网关alipay.gateway = https://openapi.alipaydev.com/gateway.do#支付宝appidalipay.app.id = appid#私钥alipay.private.key = 私钥#公钥alipay.public.key =公钥#支付宝授权登录页alipay.url = https://openauth.alipaydev.com/oauth2/publicAppAuthorize.htm#支付宝授权成功之后的回调地址redirect.url = 回调地址#我们自己网站的域名,用于重定向至错误页面web.site = www.baidu.com 通过profile.env指定不同的环境 sys-config.properties核心文件的配置（看你spring中引入的是哪个配置文件了）12345678910env=$&#123;profile.env&#125;alipay.gateway=$&#123;alipay.gateway&#125;alipay.app.id=$&#123;alipay.app.id&#125;alipay.private.key=$&#123;alipay.private.key&#125;alipay.public.key=$&#123;alipay.public.key&#125;alipay.url=$&#123;alipay.url&#125;redirect.url=$&#123;redirect.url&#125;web.site=$&#123;web.site&#125;#endpoint = http://oss-cn-qingdao.aliyuncs.com 如果没有特别的需要是不用再这里在写alipay.gateway=${alipay.gateway}，我这里因为java类中用到了读配置文件的value值来生成实例，我就让java类来读这个sys-config.properties，而不去读dev.properties，所以这里用占位符的方式指定不确定的值。 打包时如果用的是idea（eclipse我没试）直接在右上角的位置选定你需要的环境打就可以了，比较方便。3.补充之前知识：我之前写过一篇【spring.xm中配置文件使用占位符】，再次贴出来，可以结合着一块来看，全文如下：在spring中，可以使用PropertyPlaceholderConfigurer引入properties的配置文件，在配置文件中定义key，value形式的键值对，之后在xml中读取${key}的值，可以灵活的配置常用参数。1.定义.properties的配置文件这里用一个mysql数据库连接的配置文件做测试。1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://192.168.49.127\:3306/test?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;useSSL=truejdbc.username=rootjdbc.password=root 2.在.xml中引入.properties配置文件12345678&lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath*:jdbc.properties&lt;/value&gt; &lt;value&gt;/WEB-INF/mail.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 注意上面一种classpath是引用src目录下的文件写法，下面一种是引入在WEB-INF下面的文件。如果引入单个文件，还可以不用list。1234567&lt;bean id=&quot;propertyConfigurerForProject1&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;location&quot;&gt; &lt;value&gt;classpath:/com/catchu/me/jdbc.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 3.使用配置文件123456&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/bean&gt; 使用时直接使用${}就可以了，类似于EL表达式。]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用支付宝账号授权登录网站]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%94%AF%E4%BB%98%E5%AE%9D%E8%B4%A6%E5%8F%B7%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[本周在项目开发中使用到了支付宝授权登录（一键登录）我们的网站，周末做一下总结： 0.总体思路为防止各位朋友看迷糊，先说一下整体执行流程：用户在我们网站点击一个“支付宝授权登录”按钮，请求到了java后台，完成跳转至支付宝之前的字符串拼接（包括回调地址，appid，scope，state），后台将这个地址处理完成之后返回给前端，前端通过window.href=”url”的形式跳转至支付宝登录页面，用户通过输入密码或者扫码，支付宝判断如果正确就会携带支付宝用户id和access_token跳转至我写的回调地址里面（这个回调地址是我们自己写的，让支付宝调用的，需要在支付宝页面配置，下面会说），我根据alipay_user_id查自己的库，看用户是否存在，如果存在说明已经与我们平台的用户系统进行绑定，将其重定向至成功页，否则重定向至绑定用户信息页，完善信息。需要明白的是我们平台也有自己的用户系统，必须将从支付宝拿过来的alipay_user_id与我们平台的用户系统进行绑定，否则区分不出哪个是哪个用户，绑定就是在这个完善用户信息页面进行的。 1.开通蚂蚁金服开发服务并配置完成。上面只说了思路，下面说具体的操作流程。既然需要调用支付宝的接口，那就要开通蚂蚁金服的服务，通过下面地址开通：https://openhome.alipay.com/platform/appManage.htm ，需要营业执照或者身份证信息，审核通过后创建应用，并在功能选项中选择要使用的服务，比如我这里使用“获取会员信息”，点击“继续添加”可以添加其他的，如下图：点击概览下面的应用信息，配置回调地址和公钥，密钥，如下图：随后下载支付宝sdk的jar，已经集成了非常简单的调用方法。参考文档如下：https://docs.open.alipay.com/289/105656#s3 2.代码开发代码开发不太难，有点绕的是怎么传参。我是通过state传递的。从官方文档中可以看到：state参数不是必须参数，属于商户自定义参数，用户授权后，重定向到redirect_uri时会原样回传给商户，而且最大长度只能是100，最好是做到既不可预测，又可以证明客户端和当前第三方网站的登录认证状态存在关联，那我们就可以通过state参数进行传递，比如我这里通过1_0，2_500这种形式拼接的，前面的数代表操作类型，比如我这里1代表登录，2代表修改支付宝账号，0代表无上级id，大于0表示那就是上级id，如500代表上级id，然后拿到传递过来的参数之后使用split参数进行分割、解析、判断不同情况，部分示例代码如下：12345678910111213141516171819/** * @Description 登录接口 * @Author 刘俊重 */@NoLogin@RequestMapping(&quot;/supplierLogin&quot;)public R supplierLogin(@RequestBody Map&lt;String, Object&gt; map) throws Exception &#123; //获取核心企业id，0表示不是通过核心企业邀请链接登录 Object coreId = map.get(&quot;coreId&quot;); if (null == coreId || coreId == &quot;&quot;) &#123; coreId = 0; &#125; String s = DbEnum.CallBack.Type.LOGIN+&quot;_&quot;+coreId; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;s&quot;+s); /***重定向至支付宝授权登录页*/ String encode = URLEncoder.encode(SystemVar.REDIRECT_URL,&quot;UTF-8&quot;); return R.ok().put(&quot;visitUrl&quot;, SystemVar.ALIPAY_URL+&quot;?app_id=&quot; + SystemVar.APP_ID + &quot;&amp;scope=auth_user&amp;redirect_uri=&quot; + encode + &quot;&amp;state=&quot; + s);&#125; 回调函数部分代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * @Description 支付宝登录成功之后的回调函数，供支付宝调用 * @Author 刘俊重 */ @NoLogin @RequestMapping(&quot;/callBackLogin&quot;) @ResponseBody public R callBackLogin(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; String authCode = request.getParameter(&quot;auth_code&quot;); String state = request.getParameter(&quot;state&quot;); /***我们需要的参数，拿到之后以下划线分割*/ if(null==state || state==&quot;&quot;)&#123; return R.error(&quot;获取支付宝授权失败&quot;); &#125; AlipaySystemOauthTokenResponse authToken = getAuthToken(authCode); if (null == authToken) &#123; return R.error(&quot;获取支付宝授权失败&quot;); &#125; String userId = authToken.getUserId(); String accessToken = authToken.getAccessToken(); String[] split = state.split(&quot;_&quot;); String type = split[0]; if(DbEnum.CallBack.Type.LOGIN.equals(type))&#123; String coreId = split[1]; //登录 /***根据支付宝用户id查询供应商是否存在*/ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;alipayUserId&quot;, userId); SuppliersInfo suppliersInfo = suppliersInfoService.look(map); if (null == suppliersInfo) &#123; if(&quot;0&quot;.equals(coreId))&#123; //说明没有注册而且没有带核心企业id，跳转至错误提示页面 response.sendRedirect(SystemVar.WEBSITE + &quot;/#/error?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); return R.ok(); &#125; //根据上级id查询是否确实存在，避免乱注册 Map&lt;String, Object&gt; param = new HashMap&lt;String, Object&gt;(); param.put(&quot;finmallId&quot;, coreId); CoreCorpInfo coreCorpInfo = coreCorpInfoService.look(param); if (null == coreCorpInfo) &#123; response.sendRedirect(SystemVar.WEBSITE + &quot;/#/error?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); return R.ok(); &#125; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;完善信息地址&quot;+SystemVar.WEBSITE + &quot;/#/fillCompMess?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); //信息不存在，说明没有注册，去完善信息页 response.sendRedirect(SystemVar.WEBSITE + &quot;/#/fillCompMess?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); return R.ok(); &#125; String auditState = suppliersInfo.getAuditState(); if (SuppliersInfo.AuditState.WAIT.equals(auditState)) &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;待审核地址&quot;+SystemVar.WEBSITE + &quot;/#/waitExam?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); //待审核，进待审核提示页 response.sendRedirect(SystemVar.WEBSITE + &quot;/#/waitExam?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); return R.ok(); &#125; else if (SuppliersInfo.AuditState.UNPASSED.equals(auditState)) &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;审核拒绝地址&quot;+SystemVar.WEBSITE + &quot;/#/refuse?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); //审核拒绝，进审核拒绝提示页 response.sendRedirect(SystemVar.WEBSITE + &quot;/#/refuse?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId); return R.ok(); &#125; else if (SuppliersInfo.AuditState.PASSED.equals(auditState)) &#123; //审核通过，把用户信息放session中 String token = TokenUtils.getToken(); cacheManager.getCache(SysCache.SESSION_CACHE_NAME).put(token, suppliersInfo); //往cookie中添加token CookieUtils.setCookie(request, response, CookieName.SCM_TOKEN, token); logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;审核通过地址&quot;+SystemVar.WEBSITE + &quot;/#/alipay?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId + &quot;&amp;token=&quot; + token); response.sendRedirect(SystemVar.WEBSITE + &quot;/#/alipay?userId=&quot; + userId + &quot;&amp;coreId=&quot; + coreId + &quot;&amp;token=&quot; + token); return R.ok(); &#125; &#125; return null; &#125; 支付宝获取获取authToken方法如下（支付宝中也有示例）：123456789101112131415161718192021/** * @Description 获取支付宝authToken * @Author 刘俊重 * @Date 2017/11/27 */private AlipaySystemOauthTokenResponse getAuthToken(String authCode) &#123; AlipayClient alipayClient = new DefaultAlipayClient(SystemVar.ALIPAY_GATEWAY, SystemVar.APP_ID, SystemVar.PRIVATE_KEY, &quot;json&quot;, CHARSET_UTF8, SystemVar.ALIPAY_PUBLIC_KEY, &quot;RSA2&quot;); AlipaySystemOauthTokenRequest request = new AlipaySystemOauthTokenRequest(); request.setCode(authCode); request.setGrantType(&quot;authorization_code&quot;); AlipaySystemOauthTokenResponse oauthTokenResponse = null; try &#123; oauthTokenResponse = alipayClient.execute(request); System.out.println(oauthTokenResponse.getAccessToken()); &#125; catch (AlipayApiException e) &#123; //处理异常 e.printStackTrace(); &#125; return oauthTokenResponse;&#125; 到这里已经可以获取到alipay_user_id供我们使用了，如果还想获取其它信息，可以使用accessToken换取用户信息，文档中有，这里不再赘述。 3.如何配置支付宝沙箱测试支付宝的回调地址只能填写一个，如果项目已经上线了，那总不能一会把回调地址配置成生产的，一会配置成测试的吧，好在支付宝提供了一套供测试使用的沙箱环境，沙箱环境的文档地址如下：https://docs.open.alipay.com/200/105311 ，也可以看我下面说的这些：首先进入如下地址：https://openhome.alipay.com/platform/appDaily.htm?tab=info 配置沙箱环境，包括沙箱的网关，授权url，appid，公钥，密钥，均跟生产的都不同，需要重新配置，其中授权url如下：https://openauth.alipaydev.com/oauth2/publicAppAuthorize.htm 。沙箱环境使用正常的支付宝账号也无法登录，必须要使用沙箱环境分配的账号，可以在下面地址中找到沙箱测试账号：https://openhome.alipay.com/platform/appDaily.htm?tab=account ，以上便是支付宝授权登录网站的开发流程。]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>支付宝登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度统计数据导出服务踩的坑]]></title>
    <url>%2F2017%2F12%2F14%2F%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E6%9C%8D%E5%8A%A1%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[今天在项目中引入百度统计，我们是打算在我们的页面中引入百度提供的接口，而不仅仅是用百度统计里面的一些js，中途踩到一些坑，做下记录。 1.开通百度统计导出服务这个导出服务算是高级功能吧，开通完之后百度统计会给你分配一个token，在后面会用到，开通的图如下： 2.通过代码调用百度统计的接口为避免看此篇文章的同学不看完就动手操作导致翻车，先说结论，直接在postman中测即可，不用登录，不清楚的继续往下看。在官网页面我首先看到最下面的示例代码和开发文档，把它们下载下来看，发现效果不好，一大坨一大坨的，直接用postman测https://api.baidu.com/json/tongji/v1/ReportService/getSiteList 这个接口，报如下错误：12345678910111213&#123; &quot;header&quot;: &#123; &quot;desc&quot;: &quot;system failure&quot;, &quot;failures&quot;: [ &#123; &quot;code&quot;: 8603, &quot;message&quot;: &quot;The request header you provided is invalid. sn:289933044807937&quot;, &quot;position&quot;: &quot;_sys&quot; &#125; ], &quot;status&quot;: 3 &#125;&#125; 难道姿势不对，我又回过头来仔细的看百度文档，终于翻到下面这篇文档，我如获至宝，以为可以把问题解决，但就是这篇文档把我一步步带到坑中。1http://tongji.baidu.com/open/api/more?p=tongjiapi_guide.tpl 它在使用流程中写到，首先要进行身份认证，就是根据账号，密码和token进行身份验证，之后进行站点选择，这让我坚信，我上面操作失败是因为少了一步登录操作，我开始去百度上搜索这个问题，回答着寥寥，大部分都是提问，其中有一两个回答把我引到了github上，网址如下：12https://github.com/nqdy666/BaiduTongjiClient和https://github.com/justlive1/baiduTongJi 一个是gradle项目一个是maven项目，费了老牛鼻子劲把这两个项目捡下来，下载依赖包，跑起来发现依旧不能运行，这就走了好大的弯路，现在又会过头在继续搜在postman中遇到的那个说请求头不可用的问题，发现下面一篇文档：1https://www.cnblogs.com/w1570631036/p/7096966.html?utm_source=debugrun&amp;utm_medium=referral 然后我把请求体进行了修改，直接就请求成功了，详见如下截图， 请求体代码如下：123456789101112131415&#123; &quot;header&quot;: &#123; &quot;account_type&quot;: 1, &quot;password&quot;: &quot;你的密码&quot;, &quot;token&quot;: &quot;你的token&quot;, &quot;username&quot;: &quot;你的用户名&quot; &#125;, &quot;body&quot;: &#123; &quot;siteId&quot;:&quot;你的siteId&quot;, &quot;method&quot;: &quot;visit/district/a&quot;, &quot;start_date&quot;: &quot;20170818&quot;, &quot;end_date&quot;: &quot;20171118&quot;, &quot;metrics&quot;: &quot;pv_count,visitor_count,avg_visit_time&quot; &#125;&#125; 如果postman能请求成功，那么我们使用java编写httpclient发送请求肯定也是可以的，我想纠正的就是百度统计的getSiteList和getData这两个接口只要你有用户名，密码，token（siteId在首页点击网站名称进去在浏览器地址栏中问号后面就可以获取到）组织好请求体就可以调用，完全不是某些网友回答的要费很大劲登录后才能调用，使用httpclient怎么调用就不说了，实在不会引入一个hutool工具包，里面有现成的工具类，最后希望大家少走弯路！！]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>百度统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven项目和gradle项目互相转化]]></title>
    <url>%2F2017%2F12%2F14%2Fmaven%E9%A1%B9%E7%9B%AE%E5%92%8Cgradle%E9%A1%B9%E7%9B%AE%E4%BA%92%E7%9B%B8%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.maven项目转gradle项目 cmd命令行进入maven项目的根目录（即pom.xml文件所在的路径），执行如下命令：1gradle init --type pom 执行完之后会生成build.gradle和setting.gradle等gradle项目的配置文件。 2.gradle项目转maven项目 在你要转化的项目的build.gradle中加入以下代码：123456apply plugin: &apos;java&apos;apply plugin: &apos;maven&apos;group = &apos;com.cachu&apos;version = &apos;1.0.0&apos;sourceCompatibility = 1.7 group和version可以自己随便命名，artifactId默认为目录名称，sourceCompatibility是编译的jdk的版本。 cmd命令行进入你要转化的项目的路径下（即步骤1中build.gradle所在的目录），执行gradle install 命令。完整命令如下： 12345678910111213141516171819202122C:\Users\CatchU&gt;d:D:\&gt;cd D:\gitLocalRepo\innerManage\fmInnerManageD:\gitLocalRepo\innerManage\fmInnerManage&gt;gradle installStarting a Gradle Daemon, 2 incompatible and 1 stopped Daemons could not be reused, use --status for details:compileJavaDownload https://jcenter.bintray.com/com/aliyun/aliyun-java-sdk-core/3.4.0/aliyun-java-sdk-core-3.4.0.pomDownload https://jcenter.bintray.com/org/json/json/20170516/json-20170516.pomDownload https://jcenter.bintray.com/javax/mail/mail/1.4/mail-1.4.jarDownload https://jcenter.bintray.com/com/aliyun/aliyun-java-sdk-core/3.4.0/aliyun-java-sdk-core-3.4.0.jarDownload https://jcenter.bintray.com/javax/activation/activation/1.1/activation-1.1.jarDownload https://jcenter.bintray.com/org/json/json/20170516/json-20170516.jar注: 某些输入文件使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。:processResources:classes:war:installBUILD SUCCESSFULTotal time: 1 mins 9.01 secsD:\gitLocalRepo\innerManage\fmInnerManage&gt; 上面命令执行完毕之后会在build——poms——pom-default.xml找到pom文件，将其复制到项目下改为pom.xml即可。到此gradle项目转maven项目就完成了。如果maven编译时出现如下警告： 1WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent! 在pom.xml中加入如下代码：123&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt;]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven将jar包安装到本地仓库]]></title>
    <url>%2F2017%2F12%2F14%2Fmaven%E5%B0%86jar%E5%8C%85%E5%AE%89%E8%A3%85%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[现在有一个问题，我用到阿里云发短信的服务时，在maven中央仓库没有aliyun-java-sdk-dysmsapi-1.0.0的jar包，只能把它下载到本地，然后打包到本地仓库。方法如下： 首先将jar复制到本地仓库并命令行进入。 12C:\Users\CatchU&gt;d:D:\&gt;cd D:\maven3.5\myRepo\com\aliyun 执行下面打包命令 1mvn install:install-file -Dfile=aliyun-java-sdk-dysmsapi-1.0.0.jar -DgroupId=com.aliyun -DartifactId=aliyun-java-sdk-dysmsapi -Dversion=1.0.0 -Dpackaging=jar pom.xml文件中使用： 12345&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取javaweb文件路径]]></title>
    <url>%2F2017%2F12%2F14%2F%E8%8E%B7%E5%8F%96javaweb%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.java工具类中获取resources下面的文件夹下面的文件路径。例如resources/img/logo.png。 1SendMailUtil.class.getClassLoader().getResource(&quot;img/logo.png&quot;).getPath() 输出结果：/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/resources/img/logo.png 2.获取java工具类中classpath（class文件的路径）。 123456System.out.println(Class.class.getClass().getResource(&quot;/img/logo.png&quot;).getPath());System.out.println(Thread.currentThread().getContextClassLoader().getResource(&quot;img/logo.png&quot;));System.out.println(SendMailUtil.class.getClassLoader().getResource(&quot;img/logo.png&quot;));System.out.println(ClassLoader.getSystemResource(&quot;&quot;));System.out.println(SendMailUtil.class.getResource(&quot;&quot;));System.out.println(SendMailUtil.class.getResource(&quot;/&quot;)); /D:/gitLocalRepo/innerManage/fmInnerManage/out/production/resources/img/logo.pngfile:/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/resources/img/logo.pngfile:/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/resources/img/logo.pngfile:/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/classes/file:/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/classes/com/ynet/finmall/innermanage/utils/file:/D:/gitLocalRepo/innerManage/fmInnerManage/out/production/classes/]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一级缓存引发的问题]]></title>
    <url>%2F2017%2F12%2F14%2FMybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天出现一个很奇怪的问题，更新数据库之后查询并没有走数据库，没有打印sql语句，导致更新未生效，一开始以为是mybatis二级缓存，禁止之后还是有这样的问题，仔细检查代码，发现同事在Java代码方法中加了事务Transactional，当开始事务后，spring会使用同一个sqlsession做查询，一级缓存生效，导致没有跑库。]]></content>
      <categories>
        <category>工作—后台</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker与Java框架整合]]></title>
    <url>%2F2017%2F12%2F14%2FFreeMarker%E4%B8%8EJava%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.FreeMarker与Servlet的整合FreeMarker与Servlet的整合有两种方式： 在Servlet中直接处理模版与数据模型，然后输出到响应中。示例代码：123456789101112131415161718192021222324252627282930313233@WebServlet(name=&quot;test&quot;,urlPatterns=&quot;/test&quot;)public class Test extends HttpServlet &#123; private Configuration cfg; /** * @Description 初始化Configuration * @Author 刘俊重 * @date 2017年11月19日 */ @Override public void init() throws ServletException &#123; cfg = new Configuration(Configuration.VERSION_2_3_22); cfg.setServletContextForTemplateLoading(getServletContext(), &quot;WEB-INF/ftl&quot;); &#125; /** * @Description 接收请求 * @Author 刘俊重 * @date 2017年11月19日 */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Map map = new HashMap(); map.put(&quot;name&quot;, &quot;Java开发日记&quot;); map.put(&quot;list&quot;, Arrays.asList(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;)); Template template = cfg.getTemplate(&quot;index.ftl&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); Writer writer = response.getWriter(); try &#123; template.process(map, writer); &#125; catch (TemplateException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Servlet接收到test的请求之后直接在doGet方法中处理完数据与模板的整合，把处理后的数据响应给用户。 配置web.xml文件：设置处理*.ftl的Servlet为 freemarker.ext.servlet.FreemarkerServlet。示例代码如下： 12345678910@WebServlet(name=&quot;test2&quot;,urlPatterns=&quot;/test2&quot;)public class Test2 extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute(&quot;name&quot;, &quot;Java开发日记&quot;); request.setAttribute(&quot;list&quot;, Arrays.asList(&quot;战三&quot;,&quot;李四&quot;,&quot;王五&quot;)); request.getRequestDispatcher(&quot;index.ftl&quot;).forward(request, response); &#125;&#125; web.xml中进行如下配置：123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;TemplatePath&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/ftl&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ContentType&lt;/param-name&gt; &lt;param-value&gt;text/html;charset=UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;default_encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 整段的意思是当请求test2时，将数据set进request中，并将请求转发至index.ftl页面，而又在web.xml中又进行了如下配置：所有请求以ftl结尾的文件时，都交给freemarker.ext.servlet.FreemarkerServlet处理，在这个类里面将数据和模板进行整合返回给用户。所以完整的顺序是请求先到达doGet方法，在这里面进行了请求转发至FreemarkerServlet类中完整数据和模板的组装响应给用户。 2.FreeMarker与Struts的整合Struts框架已经好久不用了，上次用还是在大学的时候，但是Struts2默认的模版技术就是FreeMarker，所以还是有必要说一下的。Struts中使用FreeMarker非常简单，只需要在结果类型中配置result的type=”freemarker”即可。测试类TestAction:123456789101112public class TestAction &#123; private String name; private List&lt;String&gt; nameList; public String execute()&#123; name=&quot;Java开发日记&quot;; nameList = Arrays.asList(&quot;战三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;); return &quot;success&quot;; &#125; //省略set/get方法 &#125; struts.xml的配置：1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;package name=&quot;testfreemarker&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;test&quot; class=&quot;com.catchu.me.TestAction&quot;&gt; &lt;result type=&quot;freemarker&quot; name=&quot;success&quot;&gt;/test.ftl&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; web.xml中的配置：1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 首先在web.xml中使用过滤器配置struts的核心过滤器StrutsPrepareAndExecuteFilter，再在struts.xml中配置请求项，当请求test时交给com.catchu.me.TestAction类进行处理，如果处理结果是“success”时，响应test.ftl文件，其中结果类型是freemarker。 3.FreeMarker与SpringMvc整合FreeMarker与SpringMvc的整合要点是配置FreeMarkerConfigurer和FreeMarkerViewResolver，即如下两个类：bean class=”org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer”bean class=”org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver”TestController代码：123456789@Controllerpublic class TestController &#123; @RequestMapping(&quot;/test&quot;) public String test(Model model)&#123; model.addAttribute(&quot;name&quot;, &quot;Java开发日记&quot;); model.addAttribute(&quot;nameList&quot;, Arrays.asList(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;)); return &quot;test&quot;; &#125;&#125; web.xml123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;3.0&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;withSpringMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;withSpringMvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; withSpringMvc-servlet.xml123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-3.0.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt; &lt;mvc:annotation-driven /&gt; &lt;mvc:default-servlet-handler /&gt; &lt;context:component-scan base-package=&quot;com.catchu.me&quot; /&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/&quot; /&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在withSpringMvc-servlet.xml中配置注解驱动，扫描包，模板路径，编码方式，后缀名等信息，当请求test时即返回一个test的model，又因为配置了后缀为ftl，即响应test.ftl文件]]></content>
      <categories>
        <category>后台—模板引擎</category>
      </categories>
      <tags>
        <tag>模板引擎</tag>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker基本语法]]></title>
    <url>%2F2017%2F12%2F14%2FFreeMarker%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. FreeMarker介绍FreeMarker是一种模板引擎，通过定义的模板和数据来生成文本（包括但不局限于html，js，java等文本格式），通俗的讲就是先定义一下模板，然后传入不同的数据，动态的生成不同的文本，但它不是面向用户的，而是面向程序员的，可以直接自动的生成代码，减少程序员重复的劳动。FreeMarker最重要的两部分是模板和数据：模板：FreeMarker Template Language，简称FTL，模板文件以ftl为后缀，组成： 文本，包括HTML标签与静态文本等静态内容，会原样输出； 插值：这部分的输出会被计算的数据来替换，使用${}这种语法； 标签：给FreeMarker的指示，可以简单与指令等同，不会打印在内容中； 注释：由&lt;#–和–&gt;表示，不会被freemarker处理数据结构：树状结构：HashMap，Scalar，Sequence 2.基本使用从http://freemarker.org/ 下载FreeMarker的压缩包，将其中的freemarker.jar加到项目的构建路径下从maven仓库中引入maven依赖的jar包，注意两个核心类： 12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.24-atlassian-2&lt;/version&gt;&lt;/dependency&gt; Configuration：读取模板文件 Template：模板1234567891011Configuration cfg = new Configuration(Configuration.VERSION_2_3_21);Map&lt;String,String&gt; root= new HashMap&lt;String,String&gt;();root.put(&quot;name&quot;, &quot;Java开发日记&quot;); try &#123; cfg.setDirectoryForTemplateLoading(new File(&quot;src/ftl&quot;)); Template template = cfg.getTemplate(&quot;helloworld.ftl&quot;); Writer writer = new FileWriter(new File(&quot;src/finish/helloworld.html&quot;)); template.process(root, writer); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 使用Configuration读取配置文件，使用Map填充数据，给配置文件配置模板文件夹路径，读取模板文件，设置输出文件路径helloworld.html，执行输出文件，执行完之后就会在src目录下的finish文件夹中生成一个helloworld的html文件。模板文件如下：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;$&#123;name&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;这是我的第一个程序,$&#123;name&#125;&lt;/body&gt;&lt;/html&gt; 3.模板3.1 数据类型与变量模板中的数据类型： 标量：字符串，数字，布尔值，日期； 容器：哈希表，序列； 子程序：方法和函数，用户自定义指令；模板中的变量：简单变量，局部变量，循环变量，使用赋值指令：assign示例：1234567891011121314&lt;#assign num=10&gt;$&#123;num&#125;&lt;#assign name=&quot;Java开发日记&quot;&gt;$&#123;name&#125;&lt;#assign b=true&gt;$&#123;b?c&#125;&lt;#assign map=&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:15&#125;&gt;$&#123;map.name&#125;&lt;#assign list = [1,3,5]&gt;$&#123;list[2]&#125; freemarker中使用指令时必须要在指令前面用#（如果是自定义指令用@,后面说），assign指令是用来声明变量的，注意：如果是布尔值，输出时一定要带?c，表示定义的变量是布尔值，不然会报错。 3.2运算符模板中支持运算符： 算术运算符 比较运算符 逻辑运算符 空值处理运算符12345&lt;#assign b=1==2&gt;$&#123;b?c&#125;&lt;#assign b=1 gt 2&gt;$&#123;b?c&#125; 均输出false，gt表示大于。 3.3 插值插值是用来给插入具体值然后转换为文本，说白了，插值就是使用${}在那占个坑。使用位置： 文本区（如Hello ${name}!） 字符串表达式（如&lt;#include “/footer/${company}.html”&gt;）语法：${表达式}注意：插值表达式的结果必须是字符串，数字或日期类型。3.4指令 条件指令12345678910111213141516171819202122232425&lt;#assign score=50&gt;&lt;#if score gt 90&gt;优秀&lt;#elseif score gt 70&gt;良好&lt;#elseif score gt 60&gt;及格&lt;#else&gt;渣渣&lt;/#if&gt;&lt;#assign level=&quot;B&quot;&gt;&lt;#switch level&gt; &lt;#case &quot;A&quot;&gt; 优秀 &lt;#break &gt; &lt;#case &quot;B&quot;&gt; 良好 &lt;#break &gt; &lt;#case &quot;C&quot;&gt; soso &lt;#break &gt; &lt;#default&gt; 渣渣&lt;/#switch&gt; 需要注意的是switch语句需要有break，不然一直往下执行。 循环指令12345678&lt;#assign nums=[1,2,3,4,5]&gt;&lt;#list nums as num&gt; $&#123;num_index&#125;,$&#123;num&#125;,$&#123;num_has_next?c&#125;&lt;/#list&gt;&lt;#list nums as num&gt; $&#123;num&#125;&lt;#if num_has_next&gt;,&lt;/#if&gt;&lt;/#list&gt; 定义一个集合nums，使用list指令遍历，${别名_index}获取遍历的索引值，${别名_has_next}判断后面是否还有值，根据这个特性，可以结合if指令拼接不同的值（自动生成mybatis的配置文件时，不同字段最后一个后面不要逗号，用这个特性很好用）。 包含指令12&lt;#include &quot;condition.ftl&quot;&gt;从这里开始是自己的内容 使用include引入指令可以引入其它的模板页面。如果页面路径写不好可以用通配符，&lt;#include “*/condition.ftl”&gt; 其它原样输出指令noparse：它里面的内容是原样输出的；压缩指令compress：压缩所有的空格；设置指令setting：设置影响FreeMarker的值。 12345678910111213&lt;#noparse&gt; &lt;#assign num=1&gt; $&#123;num&#125;&lt;/#noparse&gt;&lt;#assign s=&quot; test \n\n&quot;&gt;&lt;#compress&gt; $&#123;s&#125; Compress&lt;/#compress&gt;&lt;#setting locale=&quot;hu&quot;&gt;$&#123;1.2&#125; 自定义指令可以将模版中重复的内容进行复用定义：使用macro指令定义或者使用Java实现。参数的声明：直接跟在指令名后，可以指定默认值嵌套内容：使用nested指令调用：使用&lt;@指令&gt;来调用（调用freemarker自带的指令用#命令）。 1234&lt;#macro mydirect name age=20&gt; 你好，$&#123;name&#125;,你今年$&#123;age&#125;&lt;/#macro&gt;&lt;@mydirect name=&quot;Java开发日记&quot; age=1/&gt; 自定义一个指令名为mydirect，它有两个参数name和age，其中age有默认值20，使用自定义指令时用@+自定义指令，同时为参数赋值即可。注意自定义指令是闭口的，不要漏掉最后的斜杠。 3.5 空处理有时候对象是空的，不进行判断就贸然进行处理会报错，所以要提前进行判空处理。 null对象的处理方式:使用!，只会做最后一个属性的判断； 变量不存在的处理方式:使用!或??做判断。123456$&#123;user.name!&#125;&lt;#if user.name??&gt; 名称存在 &lt;#else&gt; 名称不存在&lt;/#if&gt; 我认为是在插值时使用!，在其它指令内使用??。 3.6名称空间在编写可重复使用的模板时为了避免命名冲突，使用import指令导入命名空间。命名空间有点类似于java的包，即使类名相同，只要位于不同的包下，也是可以的。1234567test.ftl模板：&lt;#macro mydirective name&gt; 你好，$&#123;name&#125;&lt;/#macro&gt;namespace.ftl模板&lt;#import &quot;test.ftl&quot; as ns&gt;&lt;@ns.mydirective name=&quot;Java开发日记&quot; /&gt; 在这里我定义两个模板，在namespace.ftl中使用import指令导入test.ftl模板并为它起一个名为ns的命名空间，调用时我使用命令空间调用，即使namespace.ftl模板中有其它同名的也不至于混淆。另外在test.ftl中使用的是自定义指令定义了名为mydirective的指令，并为其制定一个参数name。 3.7函数FreeMarker中函数有如下几种： 字符串函数； 数字，日期布尔类型的函数； 序列（list，set）与哈希的函数； 自定义函数而且FreeMarker中的函数与java中函数调用有个很大的区别，在java中调用函数使用点号(.),而在FreeMarker中使用问号(?),这一点一定要记清。下面分别说上面提到的几种函数：3.7.1字符串函数1234567891011121314151617181920$&#123;&quot;abcdef&quot;?substring(2)&#125; &lt;#--从角标是2的位置开始截取到字符串结束--&gt;$&#123;&quot;abcdef&quot;?substring(2,4)&#125; &lt;#--从角标是2的位置开始截取到角标是4的位置，包括2不包括4（包前不包后）--&gt;$&#123;&quot;abcd mn&quot;?cap_first&#125; &lt;#--将整个字符串的首字母转大写--&gt;$&#123;&quot;Abcd&quot;?uncap_first&#125; &lt;#--将整个字符串的首字母转小写--&gt;$&#123;&quot;fden eb&quot;?capitalize&#125; &lt;#--将字符串的每个单词首字母转大写--&gt;$&#123;&quot;abcd&quot;?ends_with(&quot;d&quot;)?c&#125; &lt;#--是否以字符d结尾，这个结果是布尔值，不能直接输出，不然会报错，用?c转化成字符串--&gt;$&#123;&quot;abcd&quot;?starts_with(&quot;d&quot;)?c&#125; &lt;#--是否以字符d开头--&gt;$&#123;&quot;abac&quot;?index_of(&quot;a&quot;)&#125; &lt;#--字符a首次出现的位置--&gt;$&#123;&quot;abac&quot;?last_index_of(&quot;a&quot;)&#125; &lt;#--字符a最后一次出现的位置--&gt;$&#123;&quot;ab&quot;?left_pad(15,&quot;xy&quot;)&#125; &lt;#--将字符串ab填充成15位，如果不够15位，则左边循环填充xy--&gt;$&#123;&quot;ab&quot;?right_pad(15,&quot;xy&quot;)&#125; &lt;#--将字符串ab填充成15位，如果不够15位，则右边循环填充xy--&gt;$&#123;&quot;abac&quot;?contains(&quot;ab&quot;)?c&#125; &lt;#--判断字符串abac是否包含ab--&gt;$&#123;&quot;abac&quot;?replace(&quot;ab&quot;,&quot;AB&quot;)&#125; &lt;#--将ab替换成AB--&gt;&lt;#list &quot;abcabcabc&quot;?split(&quot;c&quot;) as s&gt; $&#123;s&#125; &lt;#--将字符串以c字符进行分割，结果是个数组，进行遍历--&gt;&lt;/#list&gt;$&#123;&quot; abc &quot;?trim&#125; &lt;#--去掉字符串空格--&gt;&lt;#list &quot; Hello FreeMarker Yes&quot;?word_list as s&gt;$&#123;s&#125; &lt;#--将字符串分割成一个个的单词，存在多个空格时，这个跟上面的split分割有一点区别--&gt;&lt;/#list&gt; 3.7.2数字，日期布尔类型的函数123456789101112131415$&#123;4.2?c&#125; &lt;#--以字符串的形式输出，上面说的布尔类型不能直接输出只能转化成字符串这种--&gt;$&#123;4.2?string&#125; &lt;#--与?c一样--&gt;$&#123;0.42?string.percent&#125; &lt;#--以百分号输出42%--&gt;$&#123;4.2?string.currency&#125; &lt;#--以货币形式输出￥4.20--&gt;$&#123;4.7?round&#125; &lt;#--四舍五入 --&gt;$&#123;4.7?floor&#125; &lt;#--向下取整，floor地板 --&gt;$&#123;4.7?ceiling&#125; &lt;#--向上取整，ceiling天花板--&gt;$&#123;date?string(&quot;yyyy-MM-dd&quot;)&#125; &lt;#--传入日期date，以yyyy-MM-dd形式输出，2017-11-18--&gt;$&#123;date?date&#125; &lt;#--输出年月日2017-11-18--&gt;$&#123;date?time&#125; &lt;#-- 输出时分秒20:41:49--&gt;$&#123;date?datetime&#125; &lt;#--输出年月日时分秒--&gt;$&#123;false?string(&quot;yes&quot;,&quot;no&quot;)&#125; &lt;#--条件如果成功输出yes,否则输出no--&gt;$&#123;4.2355?string(&quot;0.##&quot;)&#125; &lt;#--保留小数点后两位--&gt; 3.7.3 序列（list，set）与哈希的函数123456789101112131415161718192021222324252627282930&lt;#assign seq=[1,2,3,4,5,3,10]&gt;$&#123;seq?first&#125; &lt;#-- 输出序列seq的第一个--&gt;$&#123;seq?last&#125; &lt;#-- 输出序列seq的最后一个--&gt;$&#123;seq?seq_contains(6)?c&#125; &lt;#--判断序列是否包含6--&gt;$&#123;seq?seq_index_of(3)&#125; &lt;#--3在序列中首次出现的位置--&gt;$&#123;seq?seq_last_index_of(3)&#125; &lt;#--3在序列中最后一次出现的位置--&gt;&lt;#list seq?reverse as num&gt; &lt;#--翻转序列seq，结果还是一个序列，进行遍历--&gt;$&#123;num&#125;&lt;/#list&gt;$&#123;seq?size&#125; &lt;#--序列seq的长度--&gt;&lt;#list seq?sort as num&gt; &lt;#--对序列进行排序--&gt;$&#123;num&#125;&lt;/#list&gt;&lt;#assign seq1=[&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:23&#125;,&#123;&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:22&#125;,&#123;&quot;name&quot;:&quot;Rose&quot;,&quot;age&quot;:21&#125;,&#123;&quot;name&quot;:&quot;Tim&quot;,&quot;age&quot;:24&#125;]&gt;&lt;#list seq1?sort_by(&quot;age&quot;) as u&gt; &lt;#--以age对哈希seq1进行排序并遍历--&gt;$&#123;u.name&#125;+&quot;,&quot;+$&#123;u.age&#125;&lt;/#list&gt;&lt;#assign users=&#123;&quot;name&quot;:&quot;Tim&quot;,&quot;age&quot;:24&#125;&gt;&lt;#list users?keys as key&gt; &lt;#--获取到哈希users所有的键--&gt;$&#123;key&#125;&lt;/#list&gt; 3.7.4 自定义函数123456789101112131415161718&lt;#function add num1 num2&gt; &lt;#return num1+num2&gt;&lt;/#function&gt;&lt;#function addAll nums...&gt; &lt;#local total=0&gt; &lt;#list nums as num&gt; &lt;#local total=total+num&gt; &lt;/#list&gt; &lt;#return total&gt;&lt;/#function&gt;&lt;#--使用function指令定义函数add，有两个参数num1和num2，使用return返回计算之后的结果，使用$&#123;add(1,3)&#125;调用函数 --&gt;$&#123;add(1,3)&#125;&lt;#--使用function指令定义函数addAll，参数个数不固定，定义局部变量total来存储临时计算的结果，遍历所有的参数并进行运算，使用return返回计算之后的结果，使用$&#123;addAll(1,2,3,4,5)&#125;调用函数 --&gt;$&#123;addAll(1,2,3,4,5)&#125; 4.数据模型4.1数据类型使用基本数据类型来派生数字类型使用java.lang.String来构建字符串。使用java.lang.Number来派生数字类型。使用java.lang.Boolean来构建布尔值。使用java.util.List，java.util.Set或Java数组来构建序列。使用java.util.Map来构建哈希表。123456789101112131415161718192021222324Map root=new HashMap();root.put(&quot;d1&quot;, 100);root.put(&quot;d2&quot;, 100.99);root.put(&quot;d3&quot;, &apos;a&apos;);root.put(&quot;d4&quot;, true);root.put(&quot;d5&quot;, new Integer(200));root.put(&quot;d6&quot;, new Boolean(false));List&lt;String&gt; names= Arrays.asList(&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;);root.put(&quot;d7&quot;, names);Set&lt;String&gt; names1=new HashSet&lt;&gt;();names1.add(&quot;ABC&quot;);names1.add(&quot;DEF&quot;);names1.add(&quot;GHI&quot;);root.put(&quot;d8&quot;, names1);root.put(&quot;d9&quot;, new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);Map map=new HashMap();map.put(&quot;name&quot;, &quot;Java开发日记&quot;);map.put(&quot;age&quot;, 18);root.put(&quot;map&quot;, map); 就是java中常见的整型，浮点型，布尔型，字符，数组，list，set，map，不再多说 4.2 加载模板使用Configuration的方法加载模版：1,void setDirectoryForTemplateLoading(File dir);2,void setClassForTemplateLoading(Class cl, String prefix);3,void setServletContextForTemplateLoading(Object servletContext, String path);加载多个位置的模版：1,FileTemplateLoader2,ClassTemplateLoader3,TemplateLoader4,MultiTemplateLoader5,setTemplateLoader(MultiTemplateLoader mtl);123456789101112Configuration cfg = new Configuration(Configuration.VERSION_2_3_22);//cfg.setClassForTemplateLoading(TemplateLoad.class, &quot;../../../ftl&quot;);FileTemplateLoader ftl1=new FileTemplateLoader(new File(&quot;src/ftl&quot;));FileTemplateLoader ftl2=new FileTemplateLoader(new File(&quot;src/ftl2&quot;));ClassTemplateLoader ctl=new ClassTemplateLoader(TemplateLoad.class, &quot;../../../ftl3&quot;);TemplateLoader[] loaders=&#123;ctl,ftl2&#125;;MultiTemplateLoader mtl=new MultiTemplateLoader(loaders);cfg.setTemplateLoader(mtl);Template template=cfg.getTemplate(&quot;ftl2.ftl&quot;);System.out.println(template); javase项目中使用setDirectoryForTemplateLoading来加载模板所在文件夹，javaee项目中使用setClassForTemplateLoading路径，servlet中可以使用setServletContextForTemplateLoading来加载模板路径。 4.3其它配置配置就是在对象中存储常用的设置和定义某些想在所有模板中可用的变量，配置对象是freemarker.template.Configuration的实例，可以通过构造方法来创建它。而且一个应用程序通常只使用一个共享的Configuration实例。 设置共享变量：setSharedVariable() 国家地区：setLocale(); 数字格式：setNumberFormat(“0.##”); 通用设置：setSetting(String name, String value)方法 缓存：设置缓存：setCacheStorage(new freemarker.cache.MruCacheStorage(20, 250))或setSetting(Configuration.CACHE_STORAGE_KEY, “strong:20, soft:250”); 清空缓存：clearTemplateCache 123456789101112Configuration cfg=new Configuration(Configuration.VERSION_2_3_22); cfg.setDirectoryForTemplateLoading(new File(&quot;src/ftl&quot;)); //设置共享便令 cfg.setSharedVariable(&quot;site&quot;, &quot;Java开发日记&quot;); //设置小数点后保留两位 cfg.setNumberFormat(&quot;0.##&quot;);、 //设置缓存，一级缓存20个，2级缓存250个 cfg. setCacheStorage(new freemarker.cache.MruCacheStorage(20, 250)); //cfg.setSetting(Configuration.CACHE_STORAGE_KEY, &quot;strong:20, soft:250&quot;); //cfg.clearTemplateCache(); //清楚缓存 Template template = cfg.getTemplate(&quot;config.ftl&quot;); Writer writer = new FileWriter(new File(&quot;src/finish/config.html&quot;)); 总结：上面这些就是FreeMarker模板引擎的基本操作，首先需要进入jar包，之后设置模板所在的路径并引入模板，然后组装数据（实际操作中通过jdbc连接数据库来操作），所以主要学的就两方面内容：模板和数据，而模板又与这许许多多的指令相关，所以必须要掌握这些指令。]]></content>
      <categories>
        <category>后台—模板引擎</category>
      </categories>
      <tags>
        <tag>模板引擎</tag>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5学习笔记]]></title>
    <url>%2F2017%2F12%2F14%2Fhtml5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.应用程序标签 DataList(数据列表) Progress(进度条) Meter(数值显示器)示例:1234567891011121314151617181920212223&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;应用程序标签&lt;/title&gt; &lt;style&gt; .my-progress&#123; -webkit-appearance: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--数据列表，呈现需要载体--&gt;&lt;input type=&quot;text&quot; list=&quot;data-list&quot;&gt;&lt;datalist id=&quot;data-list&quot;&gt; &lt;option value=&quot;张三&quot;&gt;&lt;/option&gt; &lt;option value=&quot;李四&quot;&gt;&lt;/option&gt;&lt;/datalist&gt;&lt;!--进度条--&gt;&lt;progress&gt;&lt;/progress&gt;&lt;!--progress默认最大值是1，可以设定自己想要的值--&gt;&lt;progress class=&quot;my-progress&quot; value=&quot;30&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;meter min=&quot;0&quot; max=&quot;100&quot; low=&quot;40&quot; high=&quot;90&quot; optimum=&quot;100&quot; value=&quot;91&quot;&gt;A+&lt;/meter&gt;&lt;/body&gt; 可以利用数据列表（data-list）做一个那种带下拉框的输入框，可以根据用户输入的内容匹配下拉框的内容（select2也可以实现这种需求，而且最低可以兼容到IE8，推荐用select2）,后面的progress和meter样式不好控制，用的不太多。 2.自定义属性（data-*）在html5中可以自定义数据，以data开头，利用这个自定义标签我们可以把属性暂时存储到页面中，在js中可以使用，例子如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;data属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; // 键是ID 值是信息 var data = &#123; 01: &#123; name: &quot;张三1&quot;, age: 18 &#125;, 02: &#123; name: &quot;张三2&quot;, age: 19 &#125;, 03: &#123; name: &quot;张三3&quot;, age: 20 &#125; &#125;; var list = document.getElementById(&quot;list&quot;); for(var id in data)&#123; var item = data[id]; var liem = document.createElement(&quot;li&quot;); liem.innerHTML = item.name; //自定义data-*属性 liem.setAttribute(&quot;data-name&quot;,item.name); liem.setAttribute(&quot;data-age&quot;,item.age); list.appendChild(liem); //点击获取dataset属性 liem.addEventListener(&quot;click&quot;,function()&#123; //下面这两种方式均可以，都不带data- alert(this.dataset[&apos;name&apos;]); alert(this.dataset.name); &#125;) &#125;&lt;/script&gt; 下面这篇文章总结的很好，可以参考：http://blog.csdn.net/qq_31851435/article/details/53100691 3.新的表单提交方式传统的一共有9中表单提交方式，html5新增了几种，目前只用在移动端，pc端兼容性有问题，而且在输入的时候并没有进行验证，比如类型是email的，并没有校验邮箱格式，还是需要我们自己手动写正则表达式验证的，只是在手机端当唤起输入法的时候会自动切换到英文输入法。12345678910111213141516171819202122232425&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;新的表单提交方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;传统的表单提交方式（9种）&lt;/h3&gt;用户名：&lt;input type=&quot;text&quot;&gt; &lt;br&gt;密码：&lt;input type=&quot;password&quot;&gt;&lt;br&gt;性别：&lt;input type=&quot;radio&quot;&gt;&lt;br&gt;课程:&lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt;隐藏：&lt;input type=&quot;hidden&quot;&gt;文件：&lt;input type=&quot;file&quot;&gt;&lt;br&gt;按钮：&lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt;&lt;br&gt;表单:&lt;input type=&quot;submit&quot;&gt;&lt;br&gt;重置：&lt;input type=&quot;reset&quot;&gt;&lt;br&gt;&lt;hr&gt;&lt;h3&gt;新的表单提交方式（目前只用在移动端）&lt;/h3&gt;颜色：&lt;input type=&quot;color&quot;&gt;&lt;br&gt;网址：&lt;input type=&quot;url&quot;&gt;&lt;br&gt;搜索：&lt;input type=&quot;search&quot; results=&quot;10&quot; placeholder=&quot;Search...&quot;&gt;&lt;br&gt;邮箱：&lt;input type=&quot;email&quot; pattern=&quot;^\*.com&quot;&gt;&lt;br&gt;日期：&lt;input type=&quot;date&quot; min=&quot;2015-09-01&quot; max=&quot;2018-09-01&quot;&gt;&lt;br&gt;图片：&lt;input type=&quot;image&quot;&gt;&lt;br&gt;范围：&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;50&quot; value=&quot;10&quot;&gt;&lt;br&gt;数字：&lt;input type=&quot;number&quot;&gt;&lt;/body&gt; 4.新的选择器html5提供新的选择器，querySelector选择单个的元素，返回满足条件的第一个元素，是一个dom元素，querySelectorAll选择全部的元素，返回满足条件的全部元素，是一个dom数组，里面可以是id，标签或class类。1234567891011121314151617181920212223242526272829303132333435&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;新选择器&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;新选择器&lt;/h3&gt;&lt;ul&gt; &lt;li class=&quot;item&quot;&gt;item1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item3&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item4&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item5&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item6&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item7&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item8&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item9&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;item10&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;script&gt; //匿名函数，可以将作用域分隔开 (function()&#123; var liem = document.querySelector(&quot;.item&quot;); //只选择第一个 console.log(liem.innerHTML); var lis = document.querySelectorAll(&quot;ul&gt;li&quot;); //选择全部 for(var i=0;i&lt;lis.length;i++)&#123; console.log(lis[i]); lis[i].addEventListener(&quot;click&quot;,function()&#123; debugger; //可以调试代码。类似于浏览器打断点 console.log(this.innerHTML); &#125;) &#125; &#125;)()&lt;/script&gt; 5.元素类列表（Element.classList）新H5中DOM对象多了一个classList属性，是一个数组: add 添加一个新的类名 remove 删除一个类名 contains 判断是否包含一个指定的类名 toggle 切换一个类名。 element.toggle(‘class-name’,[add_or_remove])，第一个参数是类名，第二个参数是布尔值，如果是true，则添加类名，如果是false,则去掉类名。示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;元素类列表&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;collapse navbar-collapse&quot;&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; //匿名函数 (function()&#123; /** 点击时添加和删除类名**/ var lis = document.querySelectorAll(&quot;.nav li&quot;); for(var i=0;i&lt;lis.length;i++)&#123; lis[i].addEventListener(&quot;click&quot;,function(e)&#123; //去掉原先所有的样式 for(var j=0;j&lt;lis.length;j++)&#123; lis[j].classList.remove(&quot;active&quot;); &#125; //添加点击样式 this.classList.add(&quot;active&quot;); e.preventDefault(); //取消事件的默认操作 &#125;) &#125; /** 点击时存在类名则删除，不存在类名则添加**/ var elem = document.querySelector(&quot;.navbar-brand&quot;); //点击时如果存在active这个属性则去掉，如果不存在这个属性则加上 elem.addEventListener(&quot;click&quot;,function(e)&#123; //判断是否包含active这个类名 var isExist = elem.classList.contains(&quot;active&quot;); this.classList.toggle(&quot;active&quot;,!isExist); e.preventDefault(); &#125;) &#125;)()&lt;/script&gt;&lt;/body&gt; 6.访问历史Api在HTML5中可以通过window.history操作访问历史状态，让一个页面可以有多个历史状态 window.history.forward(); // 前进 window.history.back(); // 后退 window.history.go(); // 刷新 history.pushState(放入历史中的状态数据, 设置title(现在浏览器不支持)， 改变历史状态)，通过JS可以加入一个访问状态123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;历史记录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;测试历史记录&quot; onclick=&quot;addHistory()&quot;&gt;&lt;/body&gt;&lt;script&gt; //添加历史记录 function addHistory()&#123; //判断浏览器是否支持历史记录，毕竟是h5的新特性，低版本浏览器不支持 if(window.history &amp;&amp; history.pushState)&#123; //支持 history.pushState(new Date().toLocaleDateString(),&quot;设置历史记录的标签，但是目前浏览器还不支持&quot;,&quot;?demo=&quot;+new Date().toLocaleTimeString()); &#125;else&#123; console.log(&quot;抱歉，浏览器不支持历史记录&quot;) &#125; &#125; //下面这个事件是点击浏览器中的前进或后退时触发 window.addEventListener(&quot;popstate&quot;,function(e)&#123; console.log(&quot;点击了历史按钮&quot;+e.state); &#125;)&lt;/script&gt; 7.全屏ApiH5中可以用requestFullScreen()方法实现指定元素的全屏显示（类似于浏览器中按F11）。首先需要获取需要全屏显示的元素，然后判断浏览器是属于谷歌内核还是火狐内核或者其它浏览器，然后调用响应方法即可。(注意：目前这个特性浏览器兼容性还比较差，谷歌和火狐可以)12345678var elem = 需要全屏的元素;if (elem.webkitRequestFullScreen) &#123; elem.webkitRequestFullScreen();&#125; else if (elem.mozRequestFullScreen) &#123; elem.mozRequestFullScreen();&#125; else if (elem.requestFullScreen)&#123; elem.requestFullScreen();&#125; 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;全屏显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 style=&quot;cursor: pointer&quot;&gt;点我全屏显示&lt;/h3&gt;&lt;p&gt;测试全屏显示测试全屏显示测试全屏显示测试全屏显示测试全屏显示测试全屏显示 测试全屏显示测试全屏显示测试&lt;br&gt; 全屏显示测试全屏显示测试全屏显示测试全屏显示测试全屏显示&lt;/p&gt;&lt;script&gt; //匿名函数 (function () &#123; //获取事件源和要全屏显示的元素 var elem = document.querySelector(&quot;p&quot;); document.querySelector(&quot;h3&quot;).addEventListener(&quot;click&quot;,function(e)&#123; //判断浏览器是否支持全屏显示 if (elem.webkitRequestFullScreen) &#123; elem.webkitRequestFullScreen(); &#125; else if (elem.mozRequestFullScreen) &#123; elem.mozRequestFullScreen(); &#125; else if (elem.requestFullScreen)&#123; elem.requestFullScreen(); &#125;else&#123; console.log(&quot;浏览器不支持全屏显示&quot;) &#125; &#125;); &#125;)()&lt;/script&gt;&lt;/body&gt; 8.Application Cache离线访问技术在H5中可以利用Application Cache实现离线访问技术，测试时可以通过谷歌浏览器——NetWork——No throttling(Disable cache后面的那个下拉框)——下拉选择Offline(模拟未联网的情形)。示例如下：1234567891011121314151617181920212223242526272829303132html代码：&lt;html lang=&quot;en&quot; manifest=&quot;cache.manifest&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;离线访问&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是html页面中的内容&lt;/p&gt;&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;style.css文件代码body::before&#123; content: &quot;这是Css中引入的内容&quot;; font-size: 40px;&#125;script.js文件代码：document.write(&quot;这是js中引入的内容&quot;)cache.manifest文件代码：CACHE MANIFEST# version 1.0.1CACHE: 08离线访问.html script.js style.cssNETWORK: * 解释：在html代码中通过css的伪类和js的document.write函数分别输出两句话，模拟请求其它文件，然后在manifest（缓存清单）中定义了一个cache.manifest的缓存清单文件，文件里首先定义了当前软件的版本，下面的CACHE，代表断网情况下，从下面定义的文件中读取文件，NETWORK代表联网时候要读取的文件，星号代表全部。即断网时从我定义的文件中读取文件，联网时，读取全部文件，这样便可实现离线访问。 9.web网页存储h5中提供sessionStorage和localStorage两种数据存储方式，前者存储的内容只在本次会话中存储，浏览器关闭数据消失，后者是可以永久存储在浏览器中，除非手动或通过程序删除。这两种存储方式比cookie存储的数据量大，而且可以存储对象数据（cookie只能存储字符串数据）。12345678910111213141516171819202122232425262728293031323334&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;网页存储&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea rows=&quot;5&quot; cols=&quot;30&quot; id=&quot;txt-data&quot;&gt;&lt;/textarea&gt;&lt;input type=&quot;button&quot; value=&quot;设置数据&quot; id=&quot;set-data&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;获取数据&quot; id=&quot;get-data&quot;&gt;&lt;script&gt; (function()&#123; var txtValue = document.querySelector(&quot;#txt-data&quot;); console.log(txtValue.value); //设置数据 document.querySelector(&quot;#set-data&quot;).addEventListener(&quot;click&quot;,function (e) &#123; //判断是否支持存储 if(window.sessionStorage)&#123; sessionStorage.setItem(&quot;key&quot;,txtValue.value); &#125;else&#123; console.log(&quot;还在用渣渣IE吗？升级吧。。。&quot;) &#125; &#125;) //获取数据 document.querySelector(&quot;#get-data&quot;).addEventListener(&quot;click&quot;,function (e) &#123; //判断是否支持存储 if(window.sessionStorage)&#123; txtValue.value = sessionStorage.getItem(&quot;key&quot;); &#125;else&#123; console.log(&quot;还在用渣渣IE吗？升级吧。。。&quot;) &#125; &#125;) &#125;)()&lt;/script&gt;&lt;/body&gt; 10.操作文件Api通过file表单选择文件，之后利用h5提供的文件api可以获取文件名，大小，类型，最后修改时间等文件信息。123456789101112131415161718192021222324252627282930313233343536373839404142&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;操作文件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;form&gt; &lt;input type=&quot;file&quot; class=&quot;form-control hidden&quot; id=&quot;btn_file&quot; multiple&gt; &lt;input type=&quot;button&quot; value=&quot;选择文件&quot; class=&quot;btn btn-success&quot; id=&quot;btn_select&quot;&gt; &lt;div class=&quot;list-group&quot; id=&quot;ul_list&quot;&gt; &lt;!--待追加数据位置--&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; (function()&#123; var btn_file = document.querySelector(&quot;#btn_file&quot;); var btn_select = document.querySelector(&quot;#btn_select&quot;); var ul_list = document.querySelector(&quot;#ul_list&quot;); //利用“hidden”类将文件输入框隐藏，当点击“选择文件按钮时”，调用选择文件按钮，选择文件， // 因为input type=&quot;file&quot;这个无法修改样式，把它隐藏，点击其它按钮时，在其它按钮中调用点击上传文件 btn_select.addEventListener(&quot;click&quot;,function()&#123; btn_file.click(); &#125;) //选择文件完成后（即文件内容发生改变后） btn_file.addEventListener(&quot;change&quot;,function(e)&#123; var files = btn_file.files; //获取所有文件，并遍历 for(var i=0;i&lt;files.length;i++)&#123; console.log(files[i]); var liem = document.createElement(&quot;li&quot;); liem.setAttribute(&quot;class&quot;,&quot;list-group-item&quot;); liem.innerHTML = &apos; &lt;h4 class=&quot;list-group-item-heading&quot;&gt;&apos;+files[i].name+&apos;&lt;/h4&gt;&apos;+ &apos;&lt;p class=&quot;list-group-item-text&quot;&gt;&apos;+files[i].lastModifiedDate.toLocaleTimeString()+&apos; &apos;+(files[i].size/1024).toFixed(2)+&apos;kb&lt;/p&gt;&apos; ul_list.appendChild(liem); &#125; &#125;) &#125;)()&lt;/script&gt; 这里是用到了bootstrap的样式，因为file表单比较丑，而且无法改变样式，所以我们可以把文件表单隐藏（用hidden隐藏样式），提供一个按钮，当点击这个按钮时去雕砌选文件的弹框，multiple属性支持一次选择多个文件。 11.拖拽文件拖拽文件时需要依次注册以下事件： dragenter 注册拖拽进入事件 dragleave 注册拖拽离开事件 dragover 注册滑动事件（在这里面阻止默认事件） drop 注册松手落地事件。在拖动松手落地事件中判断拖进来的是文件还是图片地址还是文字，分别进行处理。e.dataTransfer获取拖动进来的信息。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;拖拽文件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.css&quot;&gt; &lt;style&gt; #target&#123; height: 200px; border: 5px dashed #c0c0c0; color: #505050; padding: 20px; font-size: 40px; cursor: pointer; text-align: center; -webkit-user-select: none; &#125; #target.actived&#123; border-color: #888; color: #080808; box-shadow: 0 0 80px #e0e0e0 inset; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h3&gt;拖拽文件&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;p&gt;我们这里测试拖拽文件&lt;/p&gt; &lt;img src=&quot;test.png&quot;&gt; &lt;/div&gt; &lt;div id=&quot;target&quot;&gt; 拖拽文件进来 &lt;ul id=&quot;result&quot; class=&quot;list-group&quot;&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; (function()&#123; var target = document.querySelector(&quot;#target&quot;); var fileList = document.querySelector(&apos;#result&apos;); //注册拖拽进入事件 target.addEventListener(&quot;dragenter&quot;,function()&#123; this.classList.add(&quot;actived&quot;); //添加样式 &#125;) //注册拖拽文件离开事件 target.addEventListener(&quot;dragleave&quot;,function()&#123; this.classList.remove(&quot;actived&quot;); //添加样式 &#125;) //注册落地事件之前必须要先阻止默认事件，这里在滑动里面阻止默认事件 target.addEventListener(&quot;dragover&quot;,function(e)&#123; e.preventDefault(); //阻止默认事件 e.stopPropagation(); &#125;) //注册松手落地事件 target.addEventListener(&quot;drop&quot;,function(e)&#123; //判断拖入进来的是文件，图片还是文字，分别处理 if(e.dataTransfer.files.length)&#123; //拖入的是文件 var files = e.dataTransfer.files; for (var i = 0; i &lt; files.length; i++) &#123; var li = document.createElement(&apos;li&apos;); li.setAttribute(&apos;class&apos;, &apos;list-group-item&apos;); // 创建信息的子节点 li.innerHTML = &apos;&lt;h5 class=&quot;list-group-item-heading&quot;&gt;&apos; + files[i].name + &apos;&lt;/h5&gt;&lt;p class=&quot;list-group-item-text&quot;&gt;&apos; + files[i].lastModifiedDate.toLocaleDateString() + &apos; &apos; + files[i].lastModifiedDate.toLocaleTimeString() + &apos; &apos; + (files[i].size / 1024).toFixed(2) + &apos;KB&lt;/p&gt;&apos;; fileList.appendChild(li); &#125; &#125;else&#123; //不是文件 var data = e.dataTransfer.getData(&apos;text/plain&apos;); //判断拖入的是文本还是图片 if(data)&#123; //拖入的是文本,直接置换 target.innerHTML = data; &#125;else&#123; //拖入的是图片 var imgElem = document.createElement(&quot;img&quot;); imgElem.src = data; target.appendChild(imgElem); &#125; &#125; &#125;) &#125;)()&lt;/script&gt; 12.访问设备信息h5提供了许多可以访问设备的Api，但是目前基本都应用在手机端，pc端使用非常有限。 获取网络状态。 12345678// × 所有PC浏览器现在都不支持 只有手机端的Firefoxvar connectionInfo = navigator.connection;或者下面这个方法：if (navigator.onLine)&#123; console.log(&apos;online&apos;);&#125;else&#123; console.log(&apos;offline&apos;);&#125; 获取重力感应方向 12345window.addEventListener(&apos;deviceorientation&apos;, function(event) &#123; var a = event.alpha; // Y轴 上下方向 var b = event.beta; // Z轴 东西方向 var g = event.gamma; // X轴 南北方向&#125;); 加速度计 1234window.addEventListener(&apos;devicemotion&apos;, function(e) &#123; // 获取加速计数据 &#123;x,y,z&#125; var acceleration = e.accelerationIncludingGravity;&#125;); 地理坐标 1234567navigator.geolocation.getCurrentPosition(function(e) &#123; // e.coords.longitude : 经度, e.coords.latitude : 纬度 document.querySelector(&apos;#result&apos;).innerHTML = JSON.stringify(e.coords);&#125;, function(e) &#123; document.querySelector(&apos;#result&apos;).innerHTML = JSON.stringify(e);&#125;);navigator.geolocation.watchPosition(success, error); H5还有其它的一些特性，包括语义化标签，ARIA无障碍互联网应用，多媒体（包括音频，视频）等等，真正使用的时候再详细研究。]]></content>
      <categories>
        <category>前端—html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门—js第五天]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E2%80%94js%E7%AC%AC%E4%BA%94%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[0.操作节点复习上一节的节点操作，append添加子节点，而且子节点在最后一个位置，cloneNode()，克隆节点，括号里面可以加参数，如果是true则是深克隆（克隆当前节点及其子节点），如果是false则是浅克隆，只可能当前选中的节点；parentNode父节点，给我的父节点增加子节点其实相当于给我增加了一个兄弟节。window.onload是入口函数,代表页面加载完毕之后执行（一个页面只能有一个window.onload，因为即使有多个，后面的也会覆盖前面的，导致前面的不生效）。需要注意的是添加元素时我们有时候使用append(),有时候使用appendChild()，他们两个是有点区别的，前者是jq里的写法，后者是js里的写法。1234567891011121314151617181920212223&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01节点操作&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; var demo = document.getElementById(&quot;demo&quot;); var btn = document.getElementsByTagName(&quot;button&quot;)[0]; btn.onclick = function()&#123; //创建标签 var newLi = document.createElement(&quot;li&quot;); newLi.innerHTML = &quot;测试创建节点&quot; demo.appendChild(newLi); demo.parentNode.appendChild(demo.cloneNode(true)); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;点击&lt;/button&gt;&lt;ul id=&quot;demo&quot;&gt;&lt;/ul&gt;&lt;/body&gt; 1.操作属性节点的属性操作中我们常用的是获取属性，设置属性，删除属性，分别使用以下方法： getAttribute(“属性名”) 根据属性名获取属性值 setAttribute(“属性名”,”属性值”) 给节点的某个属性设置属性值 removeAttribute(“属性名”) 删除节点的某个属性123456789&lt;body&gt;&lt;div id=&quot;demo&quot; class=&quot;test&quot; title=&quot;测试&quot;&gt;测试&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var demo = document.getElementById(&quot;demo&quot;); console.log(demo.getAttribute(&quot;class&quot;));//获取属性 demo.setAttribute(&quot;class&quot;,&quot;show&quot;); //设置节点 demo.removeAttribute(&quot;title&quot;); //删除节点&lt;/script&gt; 写的还有另外一个动态生成小圆点的示例，不再这里贴代码了，感兴趣的可以到文末代码地址中看。需要指出一点的是，我们好多时候写前端，都是先把基本的样式写好，某些需要动态生成，或通过后台取数据的再抽取出来，放在js里面，不要一上来就把想着全写出来，可能会有点吃力。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04发微博&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; ul&#123; list-style-type: none; &#125; .box&#123; width: 600px; margin: 100px auto; border:1px solid #ccc; padding: 20px; height: auto; &#125; textarea&#123; width: 450px; resize: none; /*固定使其不可拖拉*/ &#125; .box li&#123; line-height: 30px; border-bottom: 1px dashed #ccc; padding-left: 80px; width: 450px; &#125; .box ul a&#123; float: right; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var btn = document.getElementsByTagName(&quot;button&quot;)[0]; var txt = document.getElementsByTagName(&quot;textarea&quot;)[0]; //创建ul并追加 var ulEle = document.createElement(&quot;ul&quot;); btn.parentNode.appendChild(ulEle); btn.onclick = function()&#123; if(txt.value==&quot;&quot;)&#123; alert(&quot;内容不能为空&quot;); return; //停止代码执行 &#125; //创建li var liEle = document.createElement(&quot;li&quot;); liEle.innerHTML = txt.value+&quot;&lt;a href =&apos;javascript:;&apos;&gt;删除&lt;/a&gt;&quot;; txt.value=&quot;&quot;; //清空 //判断有无li，把新添加的li放在最前面 var lis = ulEle.children; if(lis.length==0)&#123; ulEle.appendChild(liEle) &#125;else&#123; ulEle.insertBefore(liEle,lis[0]); &#125; //点击删除按钮时进行删除 var as = document.getElementsByTagName(&quot;ul&quot;)[0].getElementsByTagName(&quot;a&quot;); for(var i=0;i&lt;as.length;i++)&#123; as[i].onclick = function()&#123; ulEle.removeChild(this.parentNode); //从ul中移除当前的li &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; 微博发布：&lt;textarea id=&quot;&quot; name=&quot;&quot; cols=&quot;40&quot; rows=&quot;10&quot; &gt;&lt;/textarea&gt;&lt;button&gt;发布&lt;/button&gt; &lt;!--&lt;ul&gt;--&gt; &lt;!--&lt;li&gt;合法你考虑到发交话费拉克丝发挥到了开始&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/li&gt;--&gt; &lt;!--&lt;/ul&gt;--&gt;&lt;/div&gt;&lt;/body&gt; resize: none可以设置textarea不可拖拉，textarea这里是双标签，有开始标签和结束标签，不能写成单标签，而且上面这个我就是先把样式写好，再把ul注释掉从js中动态生成的。 2.日期函数Date是js中的内置对象，使用它可以创建日期，获取当前的时间。var date = new Date(); 可以创建一个日期对象。12345678var date = new Date();console.log(date); //Wed Aug 30 2017 13:26:51 GMT+0800 (中国标准时间)console.log(date.getTime()); //1504070843457 从1970年至现在的毫秒数console.log(date.valueOf()); //1504070843457 跟上面的一样，但是没有上面的常用//直接使用的console.log(Date.now()); //1504070966613console.log(+new Date()); //1504070966613console.log(typeof (+&quot;123456&quot;)); //number js中，在某个值前使用”+”可以将这个变量转换成Number类型，如果转换失败，将得到NaN。所以上面的+new Date()跟其它值一样。 2.1日期函数常用方法日期函数中常用的方法如下： 方法 作用 getFullYear() 获取年（所有浏览器均支持） getYear() 获取年（从ECMAscriptv3开始停止使用了） 所以慎用！ getMonth() 获取月0-11 getDate() 获取日1-31 getDay() 获取星期0-6（跟上面获取日的要分清） getHours() 获取小时 （获取时分秒单词需要用复数） getMinutes() 获取分钟 getSeconds() 获取秒 getMilliseconds() 获取毫秒 getTime() 获取从1970年至今的累计毫秒数 12345678910111213&lt;script&gt; var date = new Date(); console.log(date.getFullYear()); //2017 console.log(date.getYear()); //117 console.log(date.getMonth()); //7 console.log(date.getDate()); //30 console.log(date.getDay()) //3 console.log(date.getHours()) //14 console.log(date.getMinutes()) //5 console.log(date.getSeconds()) //16 console.log(date.getMilliseconds()) //728&lt;/script&gt; 下面这一个是根据日历函数生成一个日历，其中定义一个数组来装星期的思路不错。123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06日历&lt;/title&gt; &lt;style&gt; .box&#123; width: 150px; height: 180px; margin: 100px auto; background-color: #336699; text-align: center; &#125; .box p&#123; line-height: 60px; color: #FFFFFF; font-size: 12px; &#125; .box span&#123; display: block; width: 75px; height: 75px; background-color:#9ACD32 ; margin: 0 auto; line-height: 75px; font-size: 50px; color: #000000; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var box = document.getElementById(&quot;box&quot;); var arr = [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;]; var childrens = box.children; var date = new Date(); childrens[0].innerHTML = date.getFullYear()+&quot;年&quot;+(date.getMonth()+1)+&quot;月&quot;+date.getDate()+&quot;日&quot;+ arr[date.getDay()]; childrens[1].innerHTML = date.getDate(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot; id=&quot;box&quot;&gt; &lt;p&gt;432431&lt;/p&gt; &lt;span&gt;3&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; 2.2自定义时间有时我们自己需要自己指定时间，那么在创建时间时传一个时间参数即可12var date = new Date(&quot;2016/09/11&quot;);console.log(date.getFullYear()); 所以new Date()里面如果有参数，生成指定日期，如果没有参数，生成当前日期。 3.定时器通过设定定时器可以让某个函数或动作持续的执行下去，定时器通过setInterval()函数来设定。window.setInterval(“函数名”,”时间间隔”)；每隔指定的时间间隔去执行函数。下面这几种写法都是可以的： window.setInterval(fun,1000); 其中fun是已经定义好的函数名 window.setInterval(function(){//函数体},1000);下面这两种会报错 window.setInterval(fun(),1000); window.setInterval(“fun()”,1000);网上有说这种方式也可以的，但是我试了试不行（不知道是不是姿势不对）1234567891011&lt;script&gt; window.onload = function ()&#123; var demo = document.getElementById(&quot;demo&quot;); var num=1; function myInterval()&#123; num++; demo.innerHTML = num; &#125; window.setInterval(myInterval,1000); &#125;&lt;/script&gt; 下面的例子是一个活动的倒计时，定时器每秒执行一次，根据截至时间和当前时间算出中间相隔的毫秒数(getTime()获取1970年到指定时间的毫秒数)，再利用毫秒数计算运算转换。12345678910111213141516171819202122232425262728293031323334353637 &lt;style&gt; span&#123; display: block; font-size: 30px; color: red; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var endTime = new Date(&quot;2017-08-31 24:00:00&quot;); var spanEle = document.getElementsByTagName(&quot;span&quot;)[0]; setInterval(clock,1000); //开启定时器，每秒执行一次 function clock()&#123; var startTime = new Date(); var minSecond = endTime.getTime()-startTime.getTime(); //得到距离截止时间还有多少毫秒 var second = parseInt(minSecond/1000); //得到秒数 var d = parseInt(second/24/3600); //得到天数 var h = parseInt(second/3600%24); //得到小时 var m = parseInt(second/60%60); //得到分钟 var s = parseInt(second%60); //得到秒数 d&lt;10?d=&quot;0&quot;+d:d; h&lt;10?h=&quot;0&quot;+h:h; m&lt;10?m=&quot;0&quot;+m:m; s&lt;10?s=&quot;0&quot;+s:s; spanEle.innerHTML = &quot;距离活动结束还有&quot;+d+&quot;天&quot;+h+&quot;小时&quot;+m+&quot;分钟&quot;+s+&quot;秒&quot;; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;span&gt; 5634298 &lt;/span&gt;&lt;/div&gt;&lt;/body&gt; 代码地址：https://git.oschina.net/catchu/web-study]]></content>
      <categories>
        <category>前端—javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门—js第四天]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E2%80%94js%E7%AC%AC%E5%9B%9B%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[0.升级tab栏切换在上一节中写了单一的一个容器里面tab切换的示例，在实际开发中往往都是多个容器里的多个tab互相切换，例如淘宝首页的几楼都是这样，本节先升级一下上节的示例，鼠标滑过时选中tab，如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01tab栏切换升级版&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box&#123; width: 300px; height: 300px; border:1px solid #ccc; margin: 50px auto; overflow: hidden; &#125; ul&#123; list-style-type: none; &#125; .top span&#123; display: inline-block; background-color: pink; width: 70px; height: 30px; line-height: 30px; text-align: center; cursor:pointer; &#125; .top span.current&#123; background-color: purple; &#125; .bottom li&#123; width: 100%; height: 270px; background-color: purple; display: none; &#125; .bottom li.show&#123; display: block; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; //获取所有的span和li(这里需要指出的是span和li必须是一一对应的，即个数必须得相等) var spans = document.getElementsByTagName(&quot;span&quot;); var lis = document.getElementsByTagName(&quot;li&quot;); for(var i=0;i&lt;spans.length;i++)&#123; spans[i].index = i; //给span设置index属性，先存下下标,关键 spans[i].onmouseover = function()&#123; //清除所有的li和span的属性（排他思想） for(var j=0;j&lt;spans.length;j++)&#123; spans[j].className=&quot;&quot;; lis[j].className=&quot;&quot;; &#125; //选中点击的span和它对应的li this.className=&quot;current&quot;; lis[this.index].className=&quot;show&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;top&quot;&gt; &lt;span class=&quot;current&quot;&gt;新闻&lt;/span&gt; &lt;span&gt;体育&lt;/span&gt; &lt;span&gt;娱乐&lt;/span&gt; &lt;span&gt;八卦&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt; &lt;ul&gt; &lt;li class=&quot;show&quot;&gt;新闻模块&lt;/li&gt; &lt;li&gt;体育模块&lt;/li&gt; &lt;li&gt;娱乐模块&lt;/li&gt; &lt;li&gt;八卦模块&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;top&quot;&gt; &lt;span class=&quot;current&quot;&gt;新闻&lt;/span&gt; &lt;span&gt;体育&lt;/span&gt; &lt;span&gt;娱乐&lt;/span&gt; &lt;span&gt;八卦&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt; &lt;ul&gt; &lt;li class=&quot;show&quot;&gt;新闻模块&lt;/li&gt; &lt;li&gt;体育模块&lt;/li&gt; &lt;li&gt;娱乐模块&lt;/li&gt; &lt;li&gt;八卦模块&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 1.循环语句js(以及大多数其它语言)都会有for循环，while循环，do while循环。 for循环：for(初始化;条件;增量){ //执行语句} while循环:while(条件){ //执行语句} do while循环:do{ //执行语句} while(条件);由以上可知，do while循环至少会执行一次语句（因为先执行才判断条件是否成立），三个循环不是太难，这里不再举例。2.switch分支语句switch是从多个条件中选择一个匹配的去执行，跟if elseif的作用是一样的，但是效率的话switch更高。1234567891011121314151617181920212223242526272829303132333435363738&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02switch语句&lt;/title&gt; &lt;style&gt; body&#123; background: url(images/chun1.jpg) no-repeat; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var sel = document.getElementById(&quot;sel&quot;); sel.onchange = function()&#123; switch(this.value)&#123; case &quot;1&quot;: document.body.style.backgroundImage = &quot;url(images/chun1.jpg)&quot;; break; case &quot;2&quot;: document.body.style.backgroundImage = &quot;url(images/xia1.jpg)&quot;; break; case &quot;3&quot;: document.body.style.backgroundImage = &quot;url(images/qiu1.jpg)&quot;; break; case &quot;4&quot;: document.body.style.backgroundImage = &quot;url(images/dong1.jpg)&quot;; break; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;select name=&quot;&quot; id=&quot;sel&quot;&gt; &lt;option value=&quot;1&quot;&gt;春意盎然&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;夏日炎炎&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;秋声瑟瑟&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;冬雪皑皑&lt;/option&gt;&lt;/select&gt;&lt;/body&gt; 这里根据不同的下拉选框，换不同的北京图片。onchange可以监听下拉改变事件，当当前选定的值匹配到1,2,3,4是执行对应的case语句，执行完毕之后需要break（字面意思打断）停止当前代码继续向下执行。可以使用backgroundImage属性来修改背景图片，如果是链接用url，路径不要加引号。 3.数组常用方法3.1添加数组元素 push() 从数组后面追加元素使用push()方法可向数组末尾添加一个或多个元素，并返回数组新的长度。例如：var arr = [“张三”,”李四”]; var length = arr.push(“王五”); 则执行结果是length=3，arr=[“张三”,”李四”,”王五”]; unshift() 从数组前面添加元素使用unshift()方法可在数组开头添加一个或多个元素，并返回数组新的长度。例如：var arr = [“张三”,”李四”]; var length = arr.push(“王五”); 则执行结果是length=3，arr=[“王五”,张三”,”李四”]; 3.2删除数组元素 pop() 删除数组最后一个元素，并返回最后一个元素的值如var arr=[1,3,5],var a = arr.pop(),执行完毕a=5,arr=[1,3]; shift() 删除数组第一个元素，并返回第一个元素的值如var arr=[1,3,5],var a = arr.shift(),执行完毕a=1,arr=[3,5];3.3连接数组元素 concat() 连接两个或多个数组使用concat()可以连接两个或多个数组，它不会修改当前的数组，只会返回一个连接后的新的数组var a=[1,2,3]; var b = [‘a’,’b’,’c’]; var c = a.concat(b);连接之后数组a,b都不会改变，c=[1,2,3,’a’,’b’,’c’];3.4把数组中的元素连接成字符串 join() 使用分隔符将数组中的元素连接成字符串使用join(‘分隔符’)函数可将数组中的元素通过分隔符连接成一个字符串，分隔符可以为空，为空时默认分隔符都逗号。如var arr = [1,2,3]; 则var str = arr.join(‘-‘); str的结果就是1-2-3.3.5把字符串分割成数组 split() 使用分隔符将字符串分割成数组。这个其实就是上面方法的逆运算使用split(‘分隔符’,’数组长度’)函数可以将字符串按照分隔符分割成数组，其中分隔符和数组长度都可以省略，分隔符省略时默认是逗号。如：var str = aa-bb-cc; var arr = str.split(“-“); 则arr数组的值为[aa,bb,cc].4.DOM操作js是由ECMAScript(欧洲计算机协会，负责描述了js的基本语法和对象)，DOM(Document Object Model文档对象模型，负责处理网页内容)对象和BOM(Borwser Object Model浏览器对象模型，负责处理与浏览器交互)对象组成。在这里我们主要介绍DOM，DOM为文档提供了结构化的描述，其实就是定义了如何通过脚本来访问文档结构（说白了就是怎么使用js操作html元素）。4.1节点整个html文档是个文档节点；每个html标签是个元素节点；标签中的文字是文字节点；标签的属性是属性节点；在html中一切皆是节点。4.2访问节点getElementById(); 根据id访问节点；getElementsByTagName(); 根据标签名访问节点；getElementsByClassName((); 根据类名访问节点，但是这个方法存在兼容问题，对于IE6/7/8不支持，我们可以封装自己的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03封装class类&lt;/title&gt; &lt;style&gt; div&#123; width: 50px; height: 50px; margin: 10px; background: pink; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; //封装我们自己的根据类名获取元素的方法 function getByClass(classname)&#123; //判断是否支持js原生方法（即区分IE678和其它浏览器） if(document.getElementsByClassName)&#123; return document.getElementsByClassName(classname); &#125; //程序走到这里，说明不支持document.getElementsByClassName方法，获取全部节点，遍历判断 var arr = []; //定义返回数组 var elems = document.getElementsByTagName(&quot;*&quot;); //获取页面所有节点 for(var i=0;i&lt;elems.length;i++)&#123; //获取这个元素的class类，并使用空格分割（比如demo test，不分割单纯的判断会有问题） var classes = elems[i].className.split(&quot; &quot;); for(var j=0;j&lt;classes.length;j++)&#123; if(classes[j]==classname)&#123; //存在此类名，将元素放入数组中 arr.push(elems[i]); &#125; &#125; &#125; return arr; &#125; //调用 var tests = getByClass(&quot;test&quot;); for(var k=0;k&lt;tests.length;k++)&#123; tests[k].style.backgroundColor=&quot;red&quot;; //结果就是两个变红，IE678测试没有问题 &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;demo test&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;test one&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 思路：根据getElementsByClassName判断是高级浏览器还是IE6/7/8,如果是高级浏览器则直接根据此方法返回，如果是IE6/7/8则遍历所有节点，再根据节点，获取节点里面的类，因为一个节点可能有多个类属性，中间是空格（比如demo test），所以再用空格分割，看是否包含这个类名，如果有则把当前节点（不是类名）放入数组中，最后返回。 4.3创建节点使用creatElement()方法可以创建节点。如：var div = document.creatElement(“div”);就生成了一个div标签。 4.4插入节点 appendChild(); 添加子节点（ 字面意思添加孩子），放到盒子最后面。 insertBefore(插入的节点，参照节点) 在参照节点之前插入节点，如果第二个参数不写则在盒子最后添加节点。如：demo.insertBefore(test,childrens[0]); 在第一个孩子元素之前添加节点test。 demo.insertBefore(test,null);在盒子最后添加节点test。4.5删除节点removeChild() 删除孩子节点demo.removeChild(aa); 从demo节点移除孩子节点aa。4.6克隆（复制）节点cloneNode() 复制节点括号里面可以跟参数，如果里面是true，则是深复制，除了复制盒子本身，还复制盒子子节点 ；如果是false则是浅复制，只复制该节点，不复制子节点。12345678910111213141516171819202122&lt;body&gt;&lt;div id=&quot;demo&quot;&gt; &lt;div id=&quot;one&quot;&gt;&lt;/div&gt; &lt;div id=&quot;two&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var demo = document.getElementById(&quot;demo&quot;); var one = document.getElementById(&quot;one&quot;); //创建节点 var three = document.createElement(&quot;div&quot;); //在后面添加节点 demo.appendChild(three); //在前面插入节点 demo.insertBefore(three,null); //删除节点 demo.removeChild(one); //深克隆节点 var cloneNode = demo.cloneNode(true); //克隆完要追加才能看到 demo.parentNode.appendChild(cloneNode);&lt;/script&gt;&lt;/body&gt; 5.布尔类型的真假 数据类型 真假 数字类型 除0之外所有数字均为真，0是假 字符串 所有字符串都是真，’’是假 对象 所有对象均为真，null是假 undefined Undefined类型只有undefined，是假 6.访问关系（重点）js中的访问关系有四种 父节点parentNode 兄弟节点nextSibling、nextElementSlibling、previousSibling、previousElementSibling 子节点firstChild、firstElementChild、lastChild、lastElementChild 所有子节点childNodes、children6.1父节点parentNode获取到的是元素的直接父节点（不包括爷爷），只有一个。1234567891011121314151617181920212223242526272829303132333435363738&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06二维码&lt;/title&gt; &lt;style&gt; .box&#123; width:107px; margin: 100px auto; position: relative; border: 1px solid #cccccc; &#125; #close&#123; width: 14px; height: 14px; font-size: 14px; position: absolute; line-height: 14px; top:0; left:-15px; border: 1px; cursor:pointer; display: block; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var close = document.getElementById(&quot;close&quot;); close.onclick = function()&#123; this.parentNode.style.display = &quot;none&quot;; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;images/taobao.jpg&quot;&gt; &lt;span id=&quot;close&quot;&gt;x&lt;/span&gt;&lt;/div&gt;&lt;/body&gt; 这个例子中当点击叉号时关闭页面，用到了parentNode,布局采用”子绝父相“，点击按钮时，根据当前节点，让它的父节点的display属性改为none即为隐藏。 6.2兄弟节点 nextSibling 下一个兄弟节点(不是所有的兄弟节点，只是当前节点的下一个兄弟)，IE6/7/8使用 nextElementSibling 跟上面意思一样，供高版本浏览器使用的。 previousSibling下一个兄弟节点(不是所有的兄弟节点，只是当前节点的下一个兄弟)，IE6/7/8使用 previousElementSibling 跟上面意思一样，供高版本浏览器使用的。基于以上的特点，我们在平时开发中一般用或(||)连接在一块使用，保证在IE6/7/8和高版本浏览器都是可用的。如：var div = one.nextElementSibling || one.nextSibling; 而且必须是高版本浏览器的在前，IE6/7/8的在后。6.3子节点 firstChild 第一个孩子节点，IE6/7/8使用 firstElementChild 第一个孩子节点，供高版本浏览器使用的。 lastChild 最后一个孩子节点，IE6/7/8使用（IE6/7/8大坑！！） previousElementSibling 最后一个孩子节点，供高版本浏览器使用的。为保证兼容可以这样使用：var div = one.firstElementChild || one.firstChild; 6.4孩子节点 childNodes 选出全部的孩子节点（亲的）。这个是js官方的，但是不太好用，因为在高版本浏览器中，会把换行也当做节点，还需要再根据nodeType判断一次（nodeType =1是元素节点）。 children 选出所有的孩子节点（只有元素）。这个是民间大神弄的，但是更好用，一般使用这个。需要注意一点的是，在IE678中会把注释也当做节点，计算节点个数的时候往往比正常浏览器多，避免的方法就是在要使用的元素代码里面不要写注释（第一次推荐不写注释）。1234567891011121314151617181920212223242526&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;孩子节点&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; var father = document.getElementsByTagName(&quot;ul&quot;)[0]; //如果使用第二种就不用判断了，方便alert(father.children.length); var cs = father.childNodes; for(var i=0;i&lt;cs.length;i++)&#123; if(cs[i].nodeType==1)&#123; //不加nodeType判断，在高版本浏览器会报错 cs[i].style.backgroundColor = &quot;pink&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;123&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; 代码地址：https://git.oschina.net/catchu/web-study]]></content>
      <categories>
        <category>前端—javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门—js第三天]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E2%80%94js%E7%AC%AC%E4%B8%89%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1.输入事件对于正常的浏览器oninput即可监听输入事件，但是对于IE6、7、8则需要使用onpropertychange来监听。之前我做过一个简单的@事件，就是这样使用的，当监听到输入框中输入@时，就弹出我关注人的列表。下面举例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01监听输入事件&lt;/title&gt; &lt;style&gt; .search&#123; width: 300px; height: 30px; margin: 30px auto; position: relative; &#125; .search input&#123; width: 250px; height: 26px; &#125; .search label&#123; position: absolute; left: 10px; top: 8px; font-size: 12px; cursor: text; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; //定义id函数（共用） function $(id)&#123; return document.getElementById(id); &#125; //oninput 支持大部分浏览器 检测用户表单输入内容 //onpropertychange 支持IE678 检测用户表单输入内容 $(&quot;txt&quot;).oninput = $(&quot;txt&quot;).onpropertychange = function()&#123; if(this.value == &quot;&quot;)&#123; $(&quot;message&quot;).style.display = &quot;block&quot;; &#125;else&#123; $(&quot;message&quot;).style.display = &quot;none&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;search&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;label for=&quot;txt&quot; id=&quot;message&quot;&gt;七夕礼物&lt;/label&gt;&lt;/div&gt;&lt;/body&gt; 在这里因为同一事件源的事件用的同一事件处理程序，中间可以使用连等来兼容不同的浏览器，label的for属性值值等于input的id属性值，可以在点击label的使用把鼠标定位到input中，之后采用定位（字绝父相）将label定位到输入框中（h5中使用placeholder可以更方便实现），cursor: text;可以在获取焦点后将光标变为输入样式。1&lt;input type=&quot;text&quot; placeholder=&quot;七夕礼物&quot;/&gt; 2.数组2.1声明数组 使用[]; 如：var arr1 = [1,2,3,4,5]; 使用Array关键字；如：var arr2 = new Array(1,3,5,7,9);2.2使用数组使用数组的方法是：数组名[索引值]。但是需要注意的是索引值是从0开始算的。如：arr1[1] = 2;2.3数组长度计算数组长度的方法是：数组名.length。例如：arr1.length = 5.2.4数组遍历数组的遍历使用for循环。123456789for(var i = 0; i&lt;arr1.length;i++) // 遍历数组&#123; console.log(arr1[i]);&#125;或for(var i= 0, len = arr1.length; i&lt;len;i++) // 遍历数组&#123; console.log(arr1[i]);&#125; 其中下面这种效率更高，因为它只计算了一次len长度，但是我经常采用上面的那种，习惯了。下面看一个隔行变色的例子，就是使用到了数组的相关知识123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02隔行变色&lt;/title&gt; &lt;style&gt; .box&#123; width: 360px; &#125; .box ul&#123; line-height: 30px; list-style-type: none; &#125; .box li span&#123; margin: 8px; &#125; .now&#123; background-color: #aaa!important; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; //获取所有li并遍历，隔行换颜色。 var lis = document.getElementsByTagName(&quot;li&quot;); for(var i=0;i&lt;lis.length;i++)&#123; if(i%2==0)&#123; lis[i].style.backgroundColor = &quot;#eee&quot;; &#125;else&#123; lis[i].style.backgroundColor = &quot;#ddd&quot;; &#125; lis[i].onmouseover = function()&#123; //鼠标经过变颜色,this代表事件的调用者lis[i] this.className = &quot;now&quot;; &#125; lis[i].onmouseout = function () &#123; //鼠标划出变原来的样式 this.className = &quot;&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;中国核建&lt;/span&gt;&lt;span&gt;增仓59199&lt;/span&gt;&lt;span&gt;13.35&lt;/span&gt;&lt;span&gt;9.97%&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; 使用this.className,this代表事件的调用者。className后面如果有值则给这个元素添加样式，如果没有值则将元素的样式清空。这里当鼠标经过时给元素添加now样式，鼠标划出移除样式，而在now样式中通过important来提高权重，使这个颜色生效。 3.input输入表单所有通过input输入取过来的值均是String类型，即使输入的是Number类型也不行，这点在类型转换时或相加时需要注意。1234567891011121314151617&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03input输入类型&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; var txt = document.getElementById(&quot;txt&quot;); document.getElementsByTagName(&quot;button&quot;)[0].onclick = function()&#123; alert(typeof txt.value); //string alert(typeof Number(txt.value)); //number &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt;&lt;button&gt;点击&lt;/button&gt;&lt;/body&gt; getElementsByTagName获取到的是标签的数组列表，要想使用某一个记得不要忘记后面的索引号，设置获取input输入框的值js中用value，jq中用val()。 4.三目运算表达式?结果1:结果2;意思是如果表达式的结果成立，则执行结果1，不成立则执行结果2。等价于if else语句。看下面的全选，反选，取消示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04全选和反选&lt;/title&gt; &lt;style&gt; #box ul&#123; list-style-type: none; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var btns = document.getElementsByTagName(&quot;button&quot;); //获取id是box的元素下面的所有input元素。 var inputs = document.getElementById(&quot;box&quot;).getElementsByTagName(&quot;input&quot;); //封装公共的全选或取消按钮 function all(flag)&#123; for(var i=0;i&lt;inputs.length;i++)&#123; inputs[i].checked = flag; &#125; &#125; btns[0].onclick = function()&#123; all(true); //全选 &#125; btns[1].onclick = function()&#123; all(false); //取消 &#125; //反选 btns[2].onclick = function()&#123; for(var i=0;i&lt;inputs.length;i++) &#123; inputs[i].checked == true ? inputs[i].checked = false : inputs[i].checked = true; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;top&quot;&gt; &lt;button&gt;全选&lt;/button&gt; &lt;button&gt;取消&lt;/button&gt; &lt;button&gt;反选&lt;/button&gt;&lt;/div&gt;&lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;li&gt;选项：&lt;input type=&quot;checkbox&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; 5.排他思想排他思想的指的是先干掉所有人（包括自己），然后再选中自己。123456789101112131415161718192021222324252627282930313233&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05排他思想&lt;/title&gt; &lt;style&gt; .me&#123; background-color: pink; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var btns = document.getElementsByTagName(&quot;button&quot;); for(var i=0;i&lt;btns.length;i++)&#123; btns[i].index = i; //给每个button都定义一个index属性,这里用不到，但之后用索引号的话就需要 btns[i].onclick = function()&#123; //点击时清除掉所有样式，包括自己的 for(var j=0;j&lt;btns.length;j++)&#123; btns[j].className=&quot;&quot;; &#125; //清除完之后再选定自己 this.className=&quot;me&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;排他思想&lt;/button&gt;&lt;button&gt;排他思想&lt;/button&gt;&lt;button&gt;排他思想&lt;/button&gt;&lt;button&gt;排他思想&lt;/button&gt;&lt;button&gt;排他思想&lt;/button&gt;&lt;/body&gt; 6.变量和属性js中变量是自由的，独立存在的；而属性和方法是属于对象的。如：1234var index = 10; //变量 独立存在的，谁都可以使用var arr = []; // 数组，是一个对象arr.index = 20; // 自定义属性 他是arr的属性，只能在arr 中能使用alert(arr.index); 再如我们在上面排他思想中定义的，btns[i].index = i;。这个index就是btns的属性，只能btns有权利使用。下面是一个tabs栏切换的示例，就用到了自定义属性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;06tab栏切换&lt;/title&gt; &lt;style&gt; .box&#123; width: 400px; margin: 100px auto; border: 1px solid #ccc; &#125; #bottom div&#123; width: 100%; height: 300px; background-color: pink; display: none; &#125; .green&#123; background-color: green; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var btns = document.getElementsByTagName(&quot;button&quot;); var divs = document.getElementById(&quot;bottom&quot;).getElementsByTagName(&quot;div&quot;); for(var i=0;i&lt;btns.length;i++)&#123; btns[i].index = i; // 给button设置index属性，下面可以用，这是本例的难点 btns[i].onclick = function()&#123; //alert(this.index); //把所有按钮和所有div的样式去掉 for(var j=0;j&lt;btns.length;j++)&#123; btns[j].className=&quot;&quot;; &#125; for(var k=0;k&lt;btns.length;k++)&#123; divs[k].style.display = &quot;none&quot;; &#125; //给当前按钮添加样式 this.className=&quot;green&quot;; //获取当前点击的那个按钮的索引号，把对应索引号的div的样式显示。 divs[this.index].style.display = &quot;block&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;div id=&quot;top&quot;&gt; &lt;button&gt;第一个&lt;/button&gt; &lt;button&gt;第二个&lt;/button&gt; &lt;button&gt;第三个&lt;/button&gt; &lt;button&gt;第四个&lt;/button&gt; &lt;button&gt;第五个&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;bottom&quot;&gt; &lt;div style=&quot;display: block&quot;&gt;1号盒子&lt;/div&gt; &lt;div&gt;2号盒子&lt;/div&gt; &lt;div&gt;3号盒子&lt;/div&gt; &lt;div&gt;4号盒子&lt;/div&gt; &lt;div&gt;5号盒子&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 友情提示，如果控制台报这样的错（Uncaught TypeError: Cannot read property ‘getElementsByTagName’ of null），十有八九是因为没有写入口函数window.onload，导致页面还没加载完毕就开始执行了。代码地址：https://git.oschina.net/catchu/web-study]]></content>
      <categories>
        <category>前端—javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门—js第二天]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E2%80%94js%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1.函数1.1函数声明js中可以通过以下三种方法定义函数： 自定义函数 直接量声明（函数表达式声明） 使用Function函数构造法（参数必须加引号）。区别：自定义函数和直接量声明是有区别的，自定义函数调用函数在定义之前之后都是可以了；而直接量声明只能在声明函数之后调用，否则会报错（像我下面的fun2就会报错）。1234567891011121314//1.自定义函数function fun1()&#123;alert(&quot;我是自定义函数&quot;);&#125;//函数声明之后需要调用，不然不会自动执行，执行函数可以在声明之前也可以在声明之后//fun1();//2.直接量声明//fun2() //调用函数var fun2 = function()&#123;alert(&quot;我是直接量声明&quot;);&#125;//3.使用Function关键字var fun3 = new Function(&quot;var a=10,b=20;alert(a+b);&quot;);fun3() 1.2变量提升变量提升指的是在函数体内会把变量的声明提升到函数体的最前面，只声明但是并不给变量赋值。例如1234567891011function fun()&#123; console.log(num); var num = 20;&#125;相当于function fun()&#123; var num; console.log(num); num = 20;&#125;所以结果可想而知，在这里会报undefined的异常。 下面的输出结果是undefined和20,就是执行了变量提升，尽管前面声明了num，但是在函数里面先声明num，而且没有给赋值。1234567var num=10;function fun1()&#123; alert(num); var num = 20; alert(num);&#125;fun1(); //调用函数 1.3函数参数js在创建函数的同时会创建一个arguments对象用来存储函数调用时传过来的实参，arguments对象的长度由传入实参的个数决定。函数名.length可以获取函数形参的个数。根据这一方法可以判断实参和形参个数是否相同。函数实参个数多于形参个数可以调用，小于则会报错（相当于一个形参undefined）123456function fun(a,b)&#123; console.log(a+b);&#125;fun(1,2); //3fun(5); //NaNfun(4,5,6); //9 下面判断形参和实参个数123456789function fun(a,b)&#123; if(fun.length == arguments.length)&#123; console.log(a+b);&#125;else&#123; console.error(&quot;传递参数不匹配&quot;)&#125;&#125;fun(1,2); //3fun(1,2,3); //传递参数不匹配 1.4两种定义变量的区别var a=1,b=1和var a=b=1。前者相当于var a=1;var b=1;两个变量均是局部变量。而后一个a是局部变量，b则是全局变量（隐式的全局变量）var a=1和a=1前者如果是在函数内声明属于局部变量，如果在函数外声明属于全局变量。后者跟上面说的一样，属于隐式的全局变量。 2.returnreturn有两个作用：一是设置返回值，另一个是终止代码的执行。在函数内部使用return来设置返回值，一个函数只能有一个返回值，自定义的函数默认没有返回值。同时return后跟逗号可以终止代码的执行（比如提交表单之前的校验）。12345678function fun(a,b)&#123; if(a&gt;b)&#123; //return 不仅返回函数运行的结果，如果直接用return后跟分号，是终止当前函数的执行。 return; &#125;return a+b;&#125;console.log(fun(2,1)); 3.++运算i++:先使用i，执行完再运算i=i+1;++i:先运算i=i+1,然后在执行运算。123456var a=10, b=20 , c=30;++a;a++;e=++a+(++b)+(c++)+a++;alert(e);弹出结果是：77 4.thisthis自己的，主要指事件的调用者。innerHTML更换盒子的内容value获取和设置表单的值下面说一个小技巧，页面加载完毕之后自动获取焦点（例如百度搜索），鼠标滑过之后自动选中文本内容，便于用户删除搜索框的内容dom.focus()获取dom焦点，onfocus()获取焦点触发事件,dom.select()选中dom。1234567891011121314151617181920&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;09两个表单小方法&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; //页面加载完毕自动获取焦点 var focus = document.getElementById(&quot;focus&quot;); focus.focus(); //鼠标经过自动选中文本内容，方便用户删除 var sel = document.getElementById(&quot;sel&quot;); sel.onmouseover = function()&#123; this.select(); //this指事件的调用者 &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;focus&quot;&gt;&lt;br&gt;&lt;input type=&quot;text&quot; id=&quot;sel&quot;&gt;&lt;/body&gt; 4.1输入框表单校验（基本的表单校验）123456789101112131415161718192021222324252627282930 &lt;script&gt; window.onload = function () &#123; var txt = document.getElementById(&quot;name&quot;); txt.onfocus = function()&#123; //清空 this.value = &quot;&quot;; &#125; //失去焦点判断输入内容 txt.onblur = function()&#123; if(this.value==&quot;&quot;)&#123; this.value=&quot;请输入...&quot;; &#125; &#125; document.getElementsByTagName(&quot;button&quot;)[0].onclick = function()&#123; if(txt.value==&quot;&quot; || txt.value==&quot;请输入...&quot;)&#123; txt.value=&quot;请输入...&quot;; alert(&quot;请输入内容&quot;); return; //终止代码继续向下执行 &#125; alert(&quot;正在搜索，请稍后&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;search&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;请输入...&quot; id=&quot;name&quot;&gt; &lt;button&gt;&lt;/button&gt;&lt;/div&gt;&lt;/body&gt; 4.2金字塔在页面输出一个金字塔的形状，可以使用for循环，使用百分比来控制hr的宽度。1234567&lt;script&gt;for(i=1;i&lt;=100;i+=3)&#123; document.write(&quot;&lt;hr width=&quot;+i+&quot;%&gt;&quot;);&#125;&lt;/script&gt;&lt;body&gt;&lt;/body&gt; 代码地址：https://git.oschina.net/catchu/web-study]]></content>
      <categories>
        <category>前端—javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门—js第一天]]></title>
    <url>%2F2017%2F12%2F14%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E2%80%94js%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[0.写在前面因为上周五临时走的急，没有带电脑，周末两天在家没有更新笔记，今天继续。js是连接前后端的桥梁，在项目开发中至关重要，从今天开始写一些js的入门笔记。 1.体验js1.1Alert弹框window.alert(“我是弹框”)；window窗口对象，一般是可以省略的。alert弹框可以在调试js代码时使用。 1.2console控制台输出console.log(“输出”)控制台输出，普通输出语句。console.info(“输出”)控制台输出信息。console.warn() 控制台警示。console.error();错误提示。一般常用console.info()输出到控制台来调试js代码。 1.3document.write()文档打印输出document文档对象，不可以省略，document.write()可以直接输出信息到页面。比如可以用它来做倒计时，每隔一秒输出新的时间一次。 2.变量2.1变量的命名 变量命名必须以字母或是下标符号”_”或者”$”为开头。 变量名长度不能超过255个字符。 变量名中不允许使用空格。 不用使用脚本语言中保留的关键字及保留符号作为变量名。 变量名区分大小写。 2.2作用域变量分为局部变量和全局变量。全局变量：1.在方法外声明的变量；2.在方法内没有使用var声明，直接使用的变量（这种属于隐式全局变量）。局部变量：在方法内声明的变量（作用域是方法内）。例如： 123456789101112var a = 10;function fun()&#123; a = &quot;global&quot;;&#125;console.log(a); //输出 ？var a;function fun()&#123; a = &quot;global&quot;; &#125;fun();console.log(a); 则上面的输出：10，下面的输出global。原因是上面输出的时候并没有调用fun函数，输出的10，下面调用了fun函数，a被覆盖成了global（函数不调用不会执行）。看下面一个例子： 12345678 var a = 1function func() &#123; a = b = 2 &#125; func() alert(a) alert(b) 输出的a.b都是2，而不是a是2，b报错，因为这里a开始等于1后来调用func函数，a被覆盖为2，而2没有用var声明，属于隐式的全局变量，出了func函数照样可以用的，所以不会报错。 3.Js事件Js事件三要素：事件源，事件，事件处理程序 3.1事件源事件源是事件的发起者（一般是个名词），谁触发了某次事件，那么谁就是事件源。 3.2事件事件指触发的操作（一般是个动词）。常见的事件如下：| 事件名 | 说明 || ———– | —————– || onclick | 鼠标单击 || ondblclick | 鼠标双击 || onkeyup | 按下并释放键盘上的一个键时触发 || onchange | 文本内容或下拉菜单中的选项发生改变 || onfocus | 获得焦点，表示文本框等获得鼠标光标 || onblur | 失去焦点，表示文本框等失去鼠标光标 || onmouseover | 鼠标经过，即鼠标划过图片等的上方 || onmouseout | 鼠标移出，即离开图片等所在的区域 || onload | 网页文档加载事件 || onunload | 关闭网页时触发 || onsubmit | 表单提交事件 || onreset | 重置表单事件 | 3.3事件处理程序事件触发之后的处理操作，一般是函数。结构如下：事件源.事件 = function(){ //事件处理程序}例子：1234567891011121314151617181920212223&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #demo&#123; width: 200px; height: 200px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;改变宽度&lt;/button&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var demo = document.getElementById(&quot;demo&quot;); var btn = document.getElementById(&quot;btn&quot;); btn.onclick = function()&#123; demo.style.width = &quot;400px&quot;; &#125;&lt;/script&gt;目的：点击btn按钮时让demo盒子的宽度变成400px。注意：宽度是通过style标签控制的，如果要改变它也是通过style标签,改变demo.style.width。如果修改背景图片可以用：demo.style.backgroundImage = &quot;url(images/1.jpg)&quot; 4.隐藏显示1234567display:none 隐藏display:block 显示visibility:hidden 隐藏visibility:visible 显示overflow:hidden 溢出隐藏注意：display跟visibility的隐藏有区别，dispaly:none隐藏不占位置；visibility:hidden隐藏占有位置（占茅坑不拉屎） 5.入口函数（window.onload）123window.onload = function()&#123; //需要执行的js&#125; 把script标签放在head中时可能会导致页面没有加载完毕就去执行js代码了，结果导致报错，这时就可以使用window.onload函数了，它会等到我们页面加载完毕（页面的结构，样式，节点）之后才去执行function里面的代码。注意：一个页面中只能有一个window.onload入口函数，如果写多个，则最后一个会覆盖前面的，导致前面的不生效。这点跟jquery里面的$(function(){})是有区别的，后者在一个页面可以写多个。 6.模态框现在有个需求：当我们浏览京东，淘宝这些网站的时候，细心点就会发现，当点击登录时整个窗口都会变灰色，而且弹出一个模态框让我们输入用户名密码，怎么实现这个效果呢。实现原理：做一个大的遮罩和一个弹出的模态框，大遮罩定位使用fixed（好处：不会随着滚动条滚动），颜色灰色，不点击登录时隐藏，z-index：999保证它可以覆盖着当前窗口。而弹出这个模态框z-index：1000大于刚才的那个遮罩（会覆盖到遮罩上面）；而关闭按钮使用绝对定位定位在由上角（”字绝父相”）。当点击登录按钮时让这两个弹框显示即可。效果如图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354html部分：&lt;!--遮罩--&gt;&lt;div id=&quot;mask&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box&quot;&gt; &lt;span id=&quot;close_all&quot;&gt;×&lt;/span&gt;&lt;/div&gt;css部分：/*******遮罩*******/#mask&#123; width: 100%; height: 100%; position: fixed; top: 0; left: 0; background:rgba(0,0,0,.5); display: none; z-index: 999;&#125;#box&#123; width: 400px; height: 250px; position: fixed; top: 50%; left: 50%; margin: -125px 0 0 -200px; background-color: #fff; z-index: 1000; display: none;&#125;#close_all&#123; position: absolute; width: 20px; height: 20px; font-size: 20px; top: 10px; right:10px; cursor: pointer;&#125;js部分：window.onload = function()&#123; var login = document.getElementById(&quot;login&quot;) var mask = document.getElementById(&quot;mask&quot;); var box = document.getElementById(&quot;box&quot;); var closeAll = document.getElementById(&quot;close_all&quot;); login.onclick = function()&#123; mask.style.display = &quot;block&quot;; box.style.display = &quot;block&quot;; &#125; closeAll.onclick = function()&#123; mask.style.display = &quot;none&quot;; box.style.display = &quot;none&quot;; &#125;&#125; 7.数据类型js中有五种基本数据类型（String，Number,Boolean,NUll,Undefined）和混合数据类型（Object）,使用typeof可以检测变量的数据类型（输出的是一个关于数据类型的字符串），返回如下字符串：string,number,boolean,object,undefined,function。12345678910111213141516171819var x = 1;console.log(typeof x);//numbervar a = undefined;console.log(typeof a);//undefinedvar b = null;console.log(typeof b);//object，（其实这是js最初的错误，后来被ECMAscript沿用了下来，我们可以理解null是空对象引用）。var c = new Object();console.log(typeof c);//objectvar e = [1,2,3];console.log(typeof e);//object var d = function()&#123; // ... 语句块&#125;console.log(typeof d);//function 7.1字符型（String）转换为字符型： 变量后加双引号或单引号（js中字符型双引号和单引号效果一样，java中不一样）。 使用函数String()，即使是null和undefined也可以使用，转换后是null和undefined 使用函数toString(),只能是非空的才能用，null和undefined使用会报错。12345678910var bc = &quot;zhangsan&quot;;var bd = null;var be = undefined;console.log(bc.toString());//console.log(bd.toString());//error 报错//console.log(be.toString());//error 报错console.log(&quot;------&quot;);console.log(String(bc));console.log(String(bd));console.log(String(be)); 7.2数值型（Number）Number类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值。浮点数将会自动转换为整数。12var num = 1.00;console.log(num);//1，自动转换为整数 浮点数的最高精度是17位，看下面的例子，结果不是0.3，其他编程语言，有的也会遇到这种情况（浮点数计算会产生舍入误差问题）。这里也警示我们，如果涉及到金额计算不要用浮点数，同时尽量在后台处理，所有的金额乘以100，即以分为单位进行计算入库，浮点数无法进行金额精确计算，风险极高。123456789101112console.log(0.1+0.2); //0.30000000000000004 解释：js做小数运算会出现错误，一般推荐转为整数在进行计算，比如这里输出就错了console.log((0.1*10+0.2*10)/10); 0.3var num=020;console.log(num); //16 解释：0开头的是八进制，这里输出八进制20，是十进制的16var result = &quot;20&quot;;var aa = result-10;console.log(aa); //10 解释：js字符串和数值相减时先将字符串转为数值型，在运行减法，结果为number型console.log(typeof aa);//numbervar bb = result+10;console.log(bb); //2010console.log(typeof bb); //string 解释：js字符串与数值相加值，返回结果为字符串行拼接 NaN:非数字类型（not a num字面意思：不是一个数字）。特点：① 涉及到的 任何关于NaN的操作，都会返回NaN ② NaN不等于自身。123var ab = &quot;a1&quot;;console.log(ab/10);// NaNconsole.log(NaN == NaN);// false; isNaN()函数，用于判断是否是一个非数字类型。如果传入的参数是一个非数字类型，那么返回true；否则返回false;isNaN()函数，传入一个参数，函数会先将参数转换为数值。如果参数类型为对象类型，会先调用对象的valueOf()方法， 再确定该方法返回的值是否可以转换为数值类型。如果不能，再调用对象的toString()方法，再确定返回值。其它类型转化为数值型的方法： 利用 - * / 都可以转换 (+不行，字符串跟数字相加结果是字符串拼接) 利用Number( ) parseInt()，将值转换为整型 parseFloat()；将值转换为浮点型。看下面列子：1234567console.log(parseInt(19.11)); //19console.log(parseInt(19.99)); //19console.log(parseInt(&quot;25px&quot;)); //25 解释：只转化数字的那部分console.log(parseInt(&quot;px25px&quot;)); //NaN 解释：parseInt只能将以数字开头的字符串转化为数字console.log(parseInt(110,2)); //6 解释：把二进制的110转化为十进制var a=&quot;15.15abc&quot; , b=&apos;10.15&apos; , c=&apos;10.0abc&apos;;console.log(parseInt(a)+Number(b)+parseFloat(c)); //15+10.15+10.0=35.15 7.3布尔型（Boolean）有两个值：true和false转换为布尔型的方法： 利用 !! 利用 Boolean() 123var num =10;console.log(typeof !!num); //booleanconsole.log(!!num); //true false、undefined 、null、0、”” 为 falsetrue、1、”somestring”、[Object] 为 true 7.4NUllnull类型被看做空对象指针，前文说到null类型也是空的对象引用。只有一个值，即null值，所以，在你 用typeof 操作符去检测null类型的值时，结果是object类型。如果你定义了一个变量，但是想在以后把这个变量当做一个对象来用，那么最好将该对象初始化为null值。实际上，undefined值是派生自null值的，因此ECMA-262规定对他们的相等测试要返回true。1alert(null == undefined) //true 7.5UndefinedUndefined类型只有一个值undefined,表示“缺少值”，就是此处应该有值，但是未给。用法如下： 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。1234567var a;var b = null;console.log(a); //undefinedconsole.log(a==b); //trueconsole.log(a===b); //falseconsole.log(b+10); //10console.log(a+10); //NaN 7.6Object类型Object是对象类型（也叫引用类型），创建方法： 使用new操作符后跟Object构造函数 123var person = new Object(); //创建Object引用类型的一个新实例，并且把该实例保存在变量person中。person.name = &quot;CC&quot;;person.age = 23; 使用对象字面量表达式:对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。 1234var person = &#123; name : &quot;CC&quot;, age : 23&#125;; 代码地址：https://git.oschina.net/catchu/web-study]]></content>
      <categories>
        <category>前端—javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring.xm中配置文件使用占位符]]></title>
    <url>%2F2017%2F12%2F14%2Fspring-xml%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[在spring中，可以使用PropertyPlaceholderConfigurer引入以properties的配置文件，在配置文件中定义key，value形式的键值对，之后在xml中读取${key}的值，可以灵活的配置常用参数。 1.定义.properties的配置文件这里定义一个mysql数据库连接的配置文件做测试。1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://192.168.49.127\:3306/test?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;useSSL=truejdbc.username=rootjdbc.password=root 2.在.xml中引入.properties配置文件12345678&lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath*:jdbc.properties&lt;/value&gt; &lt;value&gt;/WEB-INF/mail.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 注意上面一种classpath是引用src目录下的文件写法，下面一种是引入在WEB-INF下面的文件。如果引入单个文件，还可以不用list。1234567&lt;bean id=&quot;propertyConfigurerForProject1&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;location&quot;&gt; &lt;value&gt;classpath:/com/catchu/me/jdbc.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 3.使用配置文件123456&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/bean&gt; 使用时直接使用${}就可以了，类似于EL表达式。]]></content>
      <categories>
        <category>后台—spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro进阶—与项目整合]]></title>
    <url>%2F2017%2F12%2F14%2Fshiro%E8%BF%9B%E9%98%B6%E2%80%94%E4%B8%8E%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[0.数据库原型数据库原型如下图所示： 1.引入jar 除在入门中引入的jar包之外，在web项目中如果用到shiro，还需要引入以下jar：shiro-web-1.2.3.jarshiro-spring-1.2.3.jarshiro-quartz-1.2.3.jarquartz-1.6.1.jarehcache-core-2.5.0.jarshiro-ehcache-1.2.3.jar 2.在web.xml中配置shiro的filter 在web项目中也通过filter(过滤器)拦截shiro，filter拦截后将操作权交给在spring.xml中配置的过滤器链（fliterchain）处理，shiro中提供许多过滤器。在web.xml中配置shiro过滤器的web.xml完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;permission1110&lt;/display-name&gt; &lt;!-- 配置spring容器监听器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springmvc配置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 配置文件的地址 如果不配置contextConfigLocation， 默认查找的配置文件名称classpath下的：servlet名称+&quot;-serlvet.xml&quot;即：springmvc-serlvet.xml --&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 可以配置/ ，此工程 所有请求全部由springmvc解析，此种方式可以实现 RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析 可以配置*.do或*.action，所有请求的url扩展名为.do或.action由springmvc解析，此种方法常用 不可以/*，如果配置/*，返回jsp也由springmvc解析，这是不对的。 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--这里就是配置的shiro过滤器--&gt; &lt;!-- shiro的filter --&gt; &lt;!-- shiro过虑器，DelegatingFilterProxy通过代理模式将spring容器中的bean和filter关联起来 --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;!-- 设置true由servlet容器控制filter的生命周期 --&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 设置spring容器filter的bean id，如果不设置则找与filter-name一致的bean--&gt; &lt;init-param&gt; &lt;param-name&gt;targetBeanName&lt;/param-name&gt; &lt;param-value&gt;shiroFilter&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- post乱码处理 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 3. 在spring-shiro.xml中配置web.xml中过滤器对应spring容器中的bean. 配置代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt; &lt;!-- web.xml中shiro的filter对应的bean --&gt; &lt;!-- Shiro 的Web过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由formAuthenticationFilter进行表单认证 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.action&quot; /&gt; &lt;!-- 认证成功统一跳转到first.action，建议不配置，shiro会自动在认证成功后跳转到到上一个请求路径 --&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/first.action&quot;/&gt; &lt;!-- 通过unauthorizedUrl指定没有权限操作时跳转页面--&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/refuse.jsp&quot; /&gt; &lt;!-- 过滤器链定义，从上向下顺序执行，一般将/**放在最下边 --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &lt;!-- 对静态资源设置匿名访问 --&gt; /images/** = anon /js/** = anon /styles/** = anon &lt;!-- 验证码，可匿名访问 --&gt; /validatecode.jsp = anon &lt;!-- 请求 logout.action地址，shiro去清除session--&gt; /logout.action = logout &lt;!-- 配置记住我或认证通过可以访问的地址 --&gt; /index.jsp = user /first.action = user /welcome.jsp = user &lt;!-- /** = authc 所有url都必须认证通过才可以访问--&gt; /** = authc &lt;!-- /** = anon所有url都可以匿名访问 --&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- securityManager安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;customRealm&quot; /&gt; &lt;/bean&gt;&lt;!-- 自定义realm --&gt;&lt;bean id=&quot;customRealm&quot; class=&quot;com.catchu.ssm.shiro.CustomRealm&quot;&gt; &lt;!-- 将凭证匹配器设置到realm中，realm按照凭证匹配器的要求进行散列 --&gt; &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt;&lt;/bean&gt;&lt;!-- 凭证匹配器 --&gt; &lt;bean id=&quot;credentialsMatcher&quot; class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot; /&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;1&quot; /&gt;&lt;/bean&gt;&lt;/beans&gt; 我把自定义realm也放在了这一步进行配置 4.自定义realm进行认证 我们在上一步spring-shiro.xml中配置了loginUrl，当用户没有登录时将会请求此地址进行登录，FormAuthenticationFilter会拦截到用户的请求，获取到username,password(默认，可以进行配置)，之后调用我们自定义的Realm进行认证。自定义realm代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @Description 用于认证 * @Author 刘俊重 * @date 2017年8月1日 */@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //从token获取principal（身份信息）,token中存的是用户名和密码 String userCode = (String) token.getPrincipal(); //根据用户名查询用户信息 SysUser sysUser = null; try &#123; sysUser = sysService.findSysUserByUserCode(userCode); &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; //用户不存在返回null if(null== sysUser)&#123; return null; &#125; //用户存在，获取用户散列后的密码，盐 String password = sysUser.getPassword(); String salt = sysUser.getSalt(); //activeUser就是用户的身份信息 ActiveUser activeUser = new ActiveUser(); activeUser.setUserid(&quot;zhangsan&quot;); activeUser.setUsercode(&quot;zhangsan&quot;); activeUser.setUsername(&quot;zhangsan&quot;); //根据用户id查询菜单 List&lt;SysPermission&gt; menuList = null; try &#123; menuList = sysService.findMenuListByUserId(&quot;zhangsan&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; activeUser.setMenus(menuList); //将用户身份信息activeUser设置到SimpleAuthenticationInfo中 SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(activeUser, password,ByteSource.Util.bytes(salt),getName()); return simpleAuthenticationInfo;&#125; 在这里要注意的是：我们从token中获取到的是用户输入请求过来的用户名和密码，然后根据用户名查询数据库获得的用户信息并封装成ActiveUser，放在SimpleAuthenticationInfo中，之后ActiveUser就是主体的身份信息而不是username(你在SimpleAuthenticationInfo把谁放进去了，谁就是主体的身份信息)。 5.自定义Realm进行授权 直接入正题，我们这里采用注解进行springmvc的授权操作，注解中填权限标识符。首先需要在spring-mvc.xml中配置对shiro注解的支持。在原有spring-mvc.xml的代码中加入以下配置：1234567&lt;!-- 开启aop，对类代理 --&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt;&lt;/aop:config&gt;&lt;!-- 开启shiro注解支持 --&gt;&lt;bean class=&quot; org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt;&lt;/bean&gt; 在请求的Controller方法中配置@RequiresPermissions注解（里面填权限标识符），示例代码如下：12345678910111213//商品信息方法@RequestMapping(&quot;/queryItem&quot;)@RequiresPermissions(&quot;item:query&quot;) //表明请求这个queryItem时需要item:query权限，会调用自定义realm（调用数据库）查询主体拥有的权限，判断是否有访问本请求的权限public ModelAndView queryItems(HttpServletRequest request) throws Exception &#123; System.out.println(request.getParameter(&quot;id&quot;)); //调用service查询商品列表 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;itemsList&quot;, itemsList); // 指定逻辑视图名 modelAndView.setViewName(&quot;itemsList&quot;); return modelAndView;&#125; 比如当请求/queryItem过来时，看到有RequiresPermissions注解，表明本请求需要要权限才能访问，就会调用自定义的realm查询本主体（subject）所有的权限，看这个权限标识符是否在该主体拥有的权限标识符中，自定义realm进行授权代码如下：12345678910111213141516171819202122232425262728/** * @Description 用于授权 * @Author 刘俊重 * @date 2017年8月1日 */@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; //从principals中获取主身份信息。在上一步认证中把身份信息activeUser放进了SimpleAuthenticationInfo，这里再取出来。 ActiveUser activeUser = (ActiveUser) principals.getPrimaryPrincipal(); //从数据库中根据身份信息查询到的权限信息 List&lt;SysPermission&gt; permissionList = null; try &#123; permissionList = sysService.findPermissionListByUserId(activeUser.getUserid()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; List&lt;String&gt; permissions = new ArrayList&lt;String&gt;(); if(permissionList!=null &amp;&amp; permissionList.size()&gt;0)&#123; for(SysPermission permission:permissionList)&#123; //将用户权限标识符放在list之后填充到SimpleAuthorizationInfo并返回 permissions.add(permission.getPercode()); &#125; &#125; //构建授权信息，并返回 SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); simpleAuthorizationInfo.addStringPermissions(permissions); return simpleAuthorizationInfo;&#125; 6.常用的shiro过滤器 常用的shiro过滤器如下，可以关联源码，在shiro-web包下查看源代码：| 过滤器简称 | 对应的java类 || ———- | —————————————- || anon | org.apache.shiro.web.filter.authc.AnonymousFilter || authc | org.apache.shiro.web.filter.authc.FormAuthenticationFilter || authcBasic | org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter || perms | org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter || port | org.apache.shiro.web.filter.authz.PortFilter || rest | org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter || roles | org.apache.shiro.web.filter.authz.RolesAuthorizationFilter || ssl | org.apache.shiro.web.filter.authz.SslFilter || user | org.apache.shiro.web.filter.authc.UserFilter || logout | org.apache.shiro.web.filter.authc.LogoutFilter | anon:例子/admins/=anon 没有参数，表示可以匿名使用。 authc:例如/admins/user/=authc表示需要认证(登录)才能使用，FormAuthenticationFilter是表单认证，没有参数 perms：例子/admins/user/*=perms[user:add:],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，例如/admins/user/=perms[“user:add:,user:modify:“]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。 user:例如/admins/user/**=user没有参数表示必须存在用户, 身份认证通过或通过记住我认证通过的可以访问，当登入操作时不做检查 7.Jsp标签授权 在jsp或者html页面中，如果开发者想对项目控制的粒度更加精细，可以在页面中使用标签授权（类似于ifelse的判断形式），Jsp页面添加：1&lt;%@ tagliburi=&quot;http://shiro.apache.org/tags&quot; prefix=&quot;shiro&quot; %&gt; 标签名称 标签条件（均是显示标签内容） shiro:authenticated(左右两边的尖括号省略) 登录之后 shiro:notAuthenticated 不在登录状态时 shiro:guest 用户在没有RememberMe时 shiro:user 用户在RememberMe时 shiro:hasAnyRoles name=”abc,123” 在有abc或者123角色时 shiro:hasRole name=”abc” 拥有角色abc shiro:lacksRole name=”abc” 没有角色abc shiro:hasPermission name=”abc” 拥有权限资源abc shiro:lacksPermission name=”abc” 没有abc权限资源 shiro:principal 显示用户身份()名称 到这里其实shiro跟web项目的整合已经配置完成了，正常使用是没有问题的，下面涉及到的都是优化的操作 8.shiro缓存 通过上一步打断点我们会看出，只要用户发请求了，而且controller中有RequiresPermissions注解了，都会重复调用自定义realm的授权方法，重复的查询数据库，我们就想到了用缓存来提高速度。 shiro中提供了对认证信息和授权信息的缓存。shiro默认是关闭认证信息缓存的，对于授权信息的缓存shiro默认开启的。主要研究授权信息缓存，因为授权的数据量大。 用户认证通过。 该用户第一次授权：调用realm查询数据库 该用户第二次授权：不调用realm查询数据库，直接从缓存中取出授权信息（权限标识符）。 添加ehcache的jar，并且配置shiro-ehcache.xml,代码如下： 12345678910111213141516&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!--diskStore：缓存数据持久化的目录 地址 --&gt; &lt;diskStore path=&quot;F:\develop\ehcache&quot; /&gt; &lt;defaultCache maxElementsInMemory=&quot;1000&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 在spring-shiro.xml配置文件中，配置安全管理器（securityManger）中引入shiro-ehcache.xml: 1234567891011 &lt;!-- securityManager安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;customRealm&quot; /&gt; &lt;!-- 注入缓存管理器 --&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;/bean&gt; &lt;!-- 缓存管理器 --&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:shiro-ehcache.xml&quot;/&gt;&lt;/bean&gt; 清空缓存：如果用户正常退出，缓存自动清空。如果用户非正常退出，缓存自动清空。如果修改了用户的权限，而用户不退出系统，修改的权限无法立即生效。需要手动进行编程实现：在权限修改后调用自定义realm的clearCache方法清除缓存。在自定义Realm定义的清空缓存的方法如下： 12345//清除缓存public void clearCached() &#123; PrincipalCollection principals = SecurityUtils.getSubject().getPrincipals(); super.clearCache(principals);&#125; 在修改完用户的权限之后的serviceImpl层中可以直接调用清除缓存：12345678910//注入realm@Autowiredprivate CustomRealm customRealm;@RequestMapping(&quot;/clearShiroCache&quot;)public String clearShiroCache()&#123; //清除缓存，将来正常开发要在service调用customRealm.clearCached() customRealm.clearCached(); return &quot;success&quot;;&#125; 9.自定义表单认证过滤器 现在有一个需求，就是用户登录时不止提交有用户名，密码，还有验证码。那么原有的表单验证拦截器只验证用户名和密码就不行了。我们继承FormAuthenticationFilter拦截器实现自己的拦截器即可。代码如下：123456789101112131415161718192021222324252627282930313233343536package com.catchu.ssm.shiro;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;/** * @author 刘俊重 * @Description 自定义FormAuthenticationFilter，认证之前实现 验证码校验 * @date 2017年8月4日 */public class CustomFormAuthenticationFilter extends FormAuthenticationFilter &#123; //原FormAuthenticationFilter的认证方法 @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; //在这里进行验证码的校验 //从session获取正确验证码 HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpSession session =httpServletRequest.getSession(); //取出session的验证码（正确的验证码） String validateCode = (String) session.getAttribute(&quot;validateCode&quot;); //取出页面的验证码 //输入的验证和session中的验证进行对比 String randomcode = httpServletRequest.getParameter(&quot;randomcode&quot;); if(randomcode!=null &amp;&amp; validateCode!=null &amp;&amp; !randomcode.equals(validateCode))&#123; //如果校验失败，将验证码错误失败信息，通过shiroLoginFailure设置到request中 httpServletRequest.setAttribute(&quot;shiroLoginFailure&quot;, &quot;randomCodeError&quot;); //拒绝访问，不再校验账号和密码 return true; &#125; return super.onAccessDenied(request, response); &#125; &#125; 在spring-shiro.xml中配置代码如下：1234567891011&lt;!-- 自定义form认证过虑器 --&gt;&lt;!-- 基于Form表单的身份验证过滤器，不配置将也会注册此过虑器，表单中的用户账号、密码及loginurl将采用默认值，建议配置 --&gt;&lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;com.catchu.ssm.shiro.CustomFormAuthenticationFilter &quot;&gt; &lt;!-- 表单中账号的input名称 --&gt; &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot; /&gt; &lt;!-- 表单中密码的input名称 --&gt; &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot; /&gt; &lt;!-- 记住我input的名称 --&gt; &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt; &lt;/bean&gt; 注入到安全管理器（securitymanager）1234567&lt;!-- 自定义filter配置 --&gt;&lt;property name=&quot;filters&quot;&gt; &lt;map&gt; &lt;!-- 将自定义 的FormAuthenticationFilter注入shiroFilter中 --&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot; /&gt; &lt;/map&gt;&lt;/property&gt; 10.配置rememberMe有时用户登录之后需要记住用户名和密码，保存在cookie中，下次登录可以直接访问。 jsp中页面代码如下： 1234&lt;tr&gt;&lt;TD&gt;&lt;/TD&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; /&gt;自动登陆&lt;/td&gt;&lt;/tr&gt; ActiveUser类要实现序列化（用户身份信息，存入session 由于tomcat将session会序列化在本地硬盘上，所以使用Serializable接口）： 12345public class ActiveUser implements java.io.Serializable &#123; private String userid;//用户id（主键） private String usercode;// 用户账号 private String username;// 用户名称 &#125; spring-shiro.xml中配置rememberMeManager管理器 1234567891011&lt;!-- rememberMeManager管理器，写cookie，取出cookie生成用户信息 --&gt; &lt;bean id=&quot;rememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt; &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot; /&gt; &lt;/bean&gt; &lt;!-- 记住我cookie --&gt; &lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;!-- rememberMe是cookie的名字 --&gt; &lt;constructor-arg value=&quot;rememberMe&quot; /&gt; &lt;!-- 记住我cookie生效时间30天 --&gt; &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot; /&gt; &lt;/bean&gt; 使用UserFilter如果设置记住我，下次访问某些url时可以不用登陆。将记住我即可访问的地址配置让UserFilter拦截。在spring-shiro.xml中配置如下： 1234&lt;!-- 配置记住我或认证通过可以访问的地址 --&gt; /index.jsp = user /first.action = user /welcome.jsp = user 都配置完成之后，在浏览器的cookie中查看即可看到cookie信息。附：spring-shiro.xml中所有配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt; &lt;!-- web.xml中shiro的filter对应的bean --&gt; &lt;!-- Shiro 的Web过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由formAuthenticationFilter进行表单认证 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.action&quot; /&gt; &lt;!-- 认证成功统一跳转到first.action，建议不配置，shiro会自动在认证成功后跳转到到上一个请求路径 --&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/first.action&quot;/&gt; &lt;!-- 通过unauthorizedUrl指定没有权限操作时跳转页面--&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/refuse.jsp&quot; /&gt; &lt;!-- 自定义filter配置 --&gt; &lt;property name=&quot;filters&quot;&gt; &lt;map&gt; &lt;!-- 将自定义 的FormAuthenticationFilter注入shiroFilter中 --&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 过滤器链定义，从上向下顺序执行，一般将/**放在最下边 --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &lt;!-- 对静态资源设置匿名访问 --&gt; /images/** = anon /js/** = anon /styles/** = anon &lt;!-- 验证码，可匿名访问 --&gt; /validatecode.jsp = anon &lt;!-- 请求 logout.action地址，shiro去清除session--&gt; /logout.action = logout &lt;!--商品查询需要商品查询权限 ，取消url拦截配置，使用注解授权方式 --&gt; &lt;!-- /item/queryItem.action = perms[item:query] /items/editItems.action = perms[item:edit] --&gt; &lt;!-- 配置记住我或认证通过可以访问的地址 --&gt; /index.jsp = user /first.action = user /welcome.jsp = user &lt;!-- /** = authc 所有url都必须认证通过才可以访问--&gt; /** = authc &lt;!-- /** = anon所有url都可以匿名访问 --&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- securityManager安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;customRealm&quot; /&gt; &lt;!-- 注入缓存管理器 --&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;!-- 注入session管理器 --&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot; /&gt; &lt;!-- 记住我 --&gt; &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt; &lt;/bean&gt;&lt;!-- 自定义realm --&gt;&lt;bean id=&quot;customRealm&quot; class=&quot;com.catchu.ssm.shiro.CustomRealm&quot;&gt; &lt;!-- 将凭证匹配器设置到realm中，realm按照凭证匹配器的要求进行散列 --&gt; &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt;&lt;/bean&gt;&lt;!-- 凭证匹配器 --&gt; &lt;bean id=&quot;credentialsMatcher&quot; class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot; /&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;1&quot; /&gt;&lt;/bean&gt;&lt;!-- 缓存管理器 --&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:shiro-ehcache.xml&quot;/&gt;&lt;/bean&gt;&lt;!-- 会话管理器 --&gt;&lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;!-- session的失效时长，单位毫秒 --&gt; &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;5000&quot;/&gt; &lt;!-- 删除失效的session --&gt; &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt;&lt;!-- 自定义form认证过虑器 --&gt;&lt;!-- 基于Form表单的身份验证过滤器，不配置将也会注册此过虑器，表单中的用户账号、密码及loginurl将采用默认值，建议配置 --&gt;&lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;com.catchu.ssm.shiro.CustomFormAuthenticationFilter &quot;&gt; &lt;!-- 表单中账号的input名称 --&gt; &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot; /&gt; &lt;!-- 表单中密码的input名称 --&gt; &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot; /&gt; &lt;!-- 记住我input的名称 --&gt; &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt; &lt;/bean&gt;&lt;!-- rememberMeManager管理器，写cookie，取出cookie生成用户信息 --&gt; &lt;bean id=&quot;rememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt; &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot; /&gt; &lt;/bean&gt; &lt;!-- 记住我cookie --&gt; &lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;!-- rememberMe是cookie的名字 --&gt; &lt;constructor-arg value=&quot;rememberMe&quot; /&gt; &lt;!-- 记住我cookie生效时间30天 --&gt; &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 代码地址：http://git.oschina.net/catchu/permission-shiro]]></content>
      <categories>
        <category>后台—shiro</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro入门—授权]]></title>
    <url>%2F2017%2F12%2F14%2FShiro%E5%85%A5%E9%97%A8%E2%80%94%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[授权流程 三种授权方式 Shiro 支持三种方式的授权： 编程式：通过写if/else 授权代码块完成： 123456Subject subject = SecurityUtils.getSubject();if(subject.hasRole(“admin”)) &#123; //有权限&#125; else &#123; //无权限&#125; 注解式：通过在执行的Java方法上放置相应的注解完成： 1234@RequiresRoles(&quot;admin&quot;)public void hello() &#123; //有权限&#125; JSP/GSP 标签：在JSP/GSP 页面通过相应的标签完成： 123&lt;shiro:hasRole name=&quot;admin&quot;&gt; &lt;!— 有权限—&gt;&lt;/shiro:hasRole&gt; ​ 授权入门程序 进行授权之前首先要进行上一节学习的认证操作，认证通过之后才能进行授权。授权的单元测试代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @Description 测试角色授权，资源授权 * @Author 刘俊重 * @date 2017年8月3日 * @return void */ @Test public void testAuthorization()&#123; //授权之前需要先进行认证 //创建SecurityManager工厂 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-permission.ini&quot;); //创建SecurityManager SecurityManager securityManager = factory.getInstance(); //将SecurityManager设置到当前页面中 SecurityUtils.setSecurityManager(securityManager); //从SecurityUtils中构建subject（主体） Subject subject = SecurityUtils.getSubject(); //构建token UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;123456&quot;); //提交认证 try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //认证结果 System.out.println(&quot;认证结果：&quot;+subject.isAuthenticated()); //认证通过后执行授权 //基于角色的授权，括号内放的是角色 boolean hasRole = subject.hasRole(&quot;role1&quot;); System.out.println(&quot;单一角色授权：&quot;+hasRole); //如果没有拥有该角色会抛出异常 //subject.checkRole(&quot;role3&quot;); boolean hasAllRoles = subject.hasAllRoles(Arrays.asList(&quot;role1&quot;,&quot;role2&quot;)); System.out.println(&quot;多个角色授权：&quot;+hasAllRoles); //==========分隔符============ //基于资源的授权，括号内放的是权限标识符 boolean permitted = subject.isPermitted(&quot;user:create&quot;); System.out.println(&quot;单个资源的授权：&quot;+permitted); //使用check方法进行授权，如果授权不通过会抛出异常 subject.checkPermission(&quot;user:update&quot;); boolean permittedAll = subject.isPermittedAll(&quot;user:create&quot;,&quot;user:update&quot;); System.out.println(&quot;多个资源的授权：&quot;+permittedAll); &#125; shiro-permission.ini的配置文件如下： 1234567891011121314#用户[users]#用户zhang的密码是123456，此用户具有role1和role2两个角色zhangsan=123456,role1,role2wang=123,role2#权限[roles]#角色role1对资源user拥有create、update权限role1=user:create,user:update#角色role2对资源user拥有create、delete权限role2=user:create,user:delete#角色role3对资源user拥有create权限role3=user:create 权限标识符号规则：资源:操作:实例(中间使用半角冒号分隔) user:create:01 表示对用户资源的01实例进行create操作。 user:create 表示对用户资源进行create操作，相当于user:create:*，对所有用户资源实例进行create操作。 user:*:01 表示对用户资源实例01进行所有操作。 自定义Realm进行授权 在上边的程序中我们通过shiro-permission.ini配置对权限信息进行了静态配置，但是在实际开发中往往需要从数据库中获取权限信息，这时就需要自定义realm，由realm从数据库查询权限数据。realm根据用户身份查询权限数据，将权限数据返回给authorizer（授权器）。 自定义Realm如下（认证信息跟上一节的一样，这里改动的只是授权信息）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.catchu.realm;import java.util.ArrayList;import java.util.List;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * @author 刘俊重 * @Description 自定义Realm * @date 2017年8月1日 */public class CustomRealm extends AuthorizingRealm &#123; /** * @Description 用于授权 * @Author 刘俊重 * @date 2017年8月1日 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; //从principals中获取主身份信息 //将getPrimaryPrincipal方法值强转为真实的身份信息，即在上面认证时填充到SimpleAuthenticationInfo的身份信息 String usercode = (String) principals.getPrimaryPrincipal(); //模拟从数据库中根据身份信息查询到的权限信息（实际开发中这一步是根据身份信息从数据库中查询出来的） List&lt;String&gt; permissions = new ArrayList&lt;String&gt;(); permissions.add(&quot;user:create&quot;);//用户的创建 permissions.add(&quot;items:add&quot;);//商品添加权限 //构建授权信息，并返回 SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); simpleAuthorizationInfo.addStringPermissions(permissions); return simpleAuthorizationInfo; &#125; /** * @Description 用于认证 * @Author 刘俊重 * @date 2017年8月1日 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //从token获取principal（身份信息） String principal = (String) token.getPrincipal(); //模拟从数据库中获取到了credentials（授权信息） String credentials = &quot;111111&quot;; SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(principal, credentials, getName()); return simpleAuthenticationInfo; &#125;&#125; 单元测试代码如下： 12345678910111213141516171819202122232425262728293031323334// 自定义realm进行资源授权测试 @Test public void testAuthorizationCustomRealm() &#123; // 创建SecurityManager工厂 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory( &quot;classpath:shiro-realm.ini&quot;); // 创建SecurityManager SecurityManager securityManager = factory.getInstance(); // 将SecurityManager设置到系统运行环境，和spring后将SecurityManager配置spring容器中，一般单例管理 SecurityUtils.setSecurityManager(securityManager); // 创建subject Subject subject = SecurityUtils.getSubject(); // 创建token令牌 UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;111111&quot;); // 执行认证 try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;认证状态：&quot; + subject.isAuthenticated()); // 认证通过后执行授权 // 基于资源的授权，调用isPermitted方法会调用CustomRealm从数据库查询正确权限数据 // isPermitted传入权限标识符，判断user:create:1是否在CustomRealm查询到权限数据之内 boolean isPermitted = subject.isPermitted(&quot;user:create:1&quot;); System.out.println(&quot;单个权限判断&quot; + isPermitted); boolean isPermittedAll = subject.isPermittedAll(&quot;user:create:1&quot;, &quot;user:create&quot;); System.out.println(&quot;多个权限判断&quot; + isPermittedAll); // 使用check方法进行授权，如果授权不通过会抛出异常 //subject.checkPermission(&quot;items:add:1&quot;); &#125; shiro-realm.ini的配置文件如下： 12345[main]#自定义 realmcustomRealm=com.catchu.realm.CustomRealm#将realm设置到securityManager，相当 于spring中注入securityManager.realms=$customRealm 授权流程文字描述： 对subject进行授权，调用方法isPermitted（”权限标识符”） SecurityManager执行授权，通过ModularRealmAuthorizer执行授权 ModularRealmAuthorizer执行realm（自定义的CustomRealm）从数据库查询权限数据，调用realm的授权方法：doGetAuthorizationInfo realm从数据库查询权限数据，返回ModularRealmAuthorizer ModularRealmAuthorizer调用PermissionResolver进行权限串比对 如果比对后，isPermitted中”权限标识符”在realm查询到权限数据中，说明用户访问permission串有权限，否则没有权限，抛出异常。 ​]]></content>
      <categories>
        <category>后台—shiro</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro入门—认证]]></title>
    <url>%2F2017%2F12%2F14%2FShiro%E5%85%A5%E9%97%A8%E2%80%94%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[什么是shiroshiro是apache的一个开源权限管理框架，实现用户认证、用户授权。spring中有spring security (原名Acegi)，是一个权限框架，它和spring依赖过于紧密，没有shiro使用简单。shiro不依赖于spring，shiro不仅可以实现 web应用的权限管理，还可以实现c/s系统，分布式系统权限管理，shiro属于轻量框架，使用shiro实现系统权限管理，可以有效提高开发效率，降低开发成本。先看一下认证和授权时的关键对象：subject：主体。理解为用户,可能是程序，要去访问系统的资源，系统需要对subject进行身份认证。principal：身份信息。通常是唯一的，一个主体还有多个身份信息，但是都有一个主身份信息（primary principal）credential：凭证信息。可以是密码 、证书、指纹。主体在进行身份认证时需要提供身份信息和凭证信息。 shiro架构subject：主体。可以是用户也可以是程序，主体访问系统，系统对主体进行认证、授权。securityManager：安全管理器。主体进行认证和授权都 是通过securityManager进行。authenticator：认证器。主体进行认证最终通过authenticator进行的。authorizer：授权器。主体进行授权最终通过authorizer进行的。sessionManager：web应用中一般是用web容器（如Tomcat）对session进行管理，shiro也提供了一套session管理的方式。SessionDao： 通过SessionDao管理session数据，针对个性化的session数据存储需要使用sessionDao。cache Manager：缓存管理器。主要对session和授权数据进行缓存，比如将授权数据通过cacheManager进行缓存管理，和ehcache整合对缓存数据进行管理。realm：域，领域。相当于数据源，通过realm存取认证、授权相关数据。注意：在realm中存储授权和认证的逻辑。cryptography：密码管理。提供了一套加密/解密的组件。比如提供常用的散列、加/解密等功能（如Md5）。 shiro认证流程 shiro认证入门程序 123456789101112131415161718192021222324252627282930313233/** * @Description 测试登录登出 * @Author 刘俊重 * @date 2017年8月1日 * @return void */@Testpublic void testLoginAndLogout()&#123; //通过ini配置文件创建SecurityManager工厂 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-first.ini&quot;); //使用SecurityManagerFactory获取SecurityManager对象 SecurityManager securityManager = factory.getInstance(); //将SecurityManager设置在当前运行环境中 SecurityUtils.setSecurityManager(securityManager); //从SecurityUtils中创建一个subject(主体) Subject subject = SecurityUtils.getSubject(); //在认证提交前准备token UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;,&quot;111111&quot;); //提交主体认证 try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //获取认证结果 boolean result = subject.isAuthenticated(); System.out.println(&quot;是否认证通过&quot;+result); //退出操作 subject.logout(); //再次获取认证结果 boolean againResult = subject.isAuthenticated(); System.out.println(&quot;第二次认证结果&quot;+againResult);&#125; 通过shiro-first.ini配置文件创建SecurityManager工厂，配置文件代码如下： 12345#对用户信息进行配置[users]#用户账号和密码 zhangsan=111111lisi=22222 上面程序的执行流程如下：1通过ini配置文件创建securityManager2调用subject.login方法主体提交认证，提交的token3securityManager进行认证，securityManager最终由ModularRealmAuthenticator进行认证。4ModularRealmAuthenticator调用IniRealm(给realm传入token) 去ini配置文件中查询用户信息5IniRealm根据输入的token（UsernamePasswordToken）从 shiro-first.ini查询用户信息，根据账号查询用户信息（账号和密码） 如果查询到用户信息，就给ModularRealmAuthenticator返回用户信息（账号和密码） 如果查询不到，就给ModularRealmAuthenticator返回null6ModularRealmAuthenticator接收IniRealm返回Authentication认证信息 如果返回的认证信息是null，ModularRealmAuthenticator抛出异常（org.apache.shiro.authc.UnknownAccountException） 如果返回的认证信息不是null（说明inirealm找到了用户），对IniRealm返回用户密码 （在ini文件中存在）和 token中的密码 进行对比，如果不一致抛出异常（org.apache.shiro.authc.IncorrectCredentialsException） 自定义Realm实际开发需要realm从数据库中查询用户信息。所以需要自定义Realm。1234567891011121314151617181920212223242526272829303132333435363738package com.catchu.realm;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * @author 刘俊重 * @Description 自定义Realm * @date 2017年8月1日 */public class CustomRealm extends AuthorizingRealm &#123; /** * @Description 用于授权 * @Author 刘俊重 * @date 2017年8月1日 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; return null; &#125; /** * @Description 用于认证 * @Author 刘俊重 * @date 2017年8月1日 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //从token获取principal（身份信息） String principal = (String) token.getPrincipal(); //模拟从数据库中获取到了credentials（授权信息） String credentials = &quot;111111&quot;; SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(principal, credentials, getName()); return simpleAuthenticationInfo; &#125;&#125; 单元测试代码如下：12345678910111213141516171819202122232425262728/** * @Description 测试自定义realm * @Author 刘俊重 * @date 2017年8月1日 * @return void */ @Test public void testCustomRealm()&#123; //生成SecurityManager工厂 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm.ini&quot;); //使用SecurityManager工厂获取SecurityManager SecurityManager securityManager = factory.getInstance(); //将Securitymanager设置在当前运行环境中 SecurityUtils.setSecurityManager(securityManager); //从SecurityUtils中生成subject(主体) Subject subject = SecurityUtils.getSubject(); //在认证前准备token，将来由用户输入 UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;,&quot;111111&quot;); //提交认证 try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //获取授权结果 boolean result = subject.isAuthenticated(); System.out.println(&quot;认证结果：&quot;+result); &#125; shiro-realm.ini配置文件如下：12345[main]#自定义 realmcustomRealm=com.catchu.realm.CustomRealm#将realm设置到securityManager，相当 于spring中注入securityManager.realms=$customRealm 6.md5散列算法和盐实际开发中通常需要对密码进行散列，常用的有md5、sha。建议对md5进行散列时加salt（盐），进行加密相当于对原始密码+盐进行散列。正常使用时散列方法：在程序中对原始密码+盐进行散列，将散列值和盐存储到数据库中。在进行密码对比时，使用相同方法，将输入密码+盐进行散列，与数据库存储的散列值进行比对。1234567891011121314151617181920import org.apache.shiro.crypto.hash.Md5Hash;/** * @author 刘俊重 * @Description md5散列测试 * @date 2017年8月2日 */public class Md5Test &#123; public static void main(String[] args) &#123; //原始密码 String source = &quot;111111&quot;; //盐 String salt = &quot;qwerty&quot;; //散列次数（就是进行了几次md5加密） int hashIterations = 1; //散列一次的值：f3694f162729b7d0254c6e40260bf15c //散列两次的值：36f2dfa24d0a9fa97276abbe13e596fc Md5Hash md5Hash = new Md5Hash(source, salt, hashIterations); System.out.println(&quot;md5散列后的值：&quot;+md5Hash.toString()); &#125;&#125; 7.自定义Realm支持Md5散列自定义Realm如下：12345678910111213141516171819202122232425262728293031323334353637383940414243package com.catchu.realm;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;/** * @author 刘俊重 * @Description 自定义Ream实现md5散列加密 * @date 2017年8月2日 */public class CustomRealmMd5 extends AuthorizingRealm &#123; /** * @Description 用于授权 * @Author 刘俊重 * @date 2017年8月2日 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; // TODO Auto-generated method stub return null; &#125; /** * @Description 用于认证 * @Author 刘俊重 * @date 2017年8月2日 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //从token中获取principal(身份信息)，在这里指的就是用户名 String principal = (String) token.getPrincipal(); //模拟从数据库中获取到了credentials(授权信息)，在这里值的是密码在数据库中的散列值 String credentials = &quot;f3694f162729b7d0254c6e40260bf15c&quot;; //从数据库中获取salt(盐) String salt = &quot;qwerty&quot;; SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(principal, credentials, ByteSource.Util.bytes(salt),getName()); return simpleAuthenticationInfo; &#125;&#125; 单元测试代码如下：12345678910111213141516171819202122232425262728/** * @Description 测试自定义realm，Md5版 * @Author 刘俊重 * @date 2017年8月2日 * @return void */ @Test public void testCustomRealmMd5()&#123; //根据ini配置文件生成SecurityManager工厂类 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm-md5.ini&quot;); //生成SecurityManager（安全管理器） SecurityManager securityManager = factory.getInstance(); //将安全管理器设置在当前运行环境中 SecurityUtils.setSecurityManager(securityManager); //从SecurityUtils中生成subject(主体) Subject subject = SecurityUtils.getSubject(); //在认证前准备token(令牌)，正式环境中由用户输入 UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;,&quot;111111&quot;); //提交认证 try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); &#125; //是否认证通过 boolean isAuthenticated = subject.isAuthenticated(); System.out.println(&quot;是否认证通过&quot;+isAuthenticated); &#125; 其中生成SecurityManager工厂类的配置文件shiro-realm-md5.ini如下：1234567891011[main]#定义凭证匹配器credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher#散列算法credentialsMatcher.hashAlgorithmName=md5#散列次数credentialsMatcher.hashIterations=1#将凭证匹配器设置到realmcustomRealm=com.catchu.realm.CustomRealmMd5customRealm.credentialsMatcher=$credentialsMatchersecurityManager.realms=$customRealm 8.引入jar上面忘记说了，与其它java开源框架类似，将shiro的jar包加入项目就可以使用shiro提供的功能了。shiro-core是核心包必须选用，还提供了与web整合的shiro-web、与spring整合的shiro-spring、与任务调度quartz整合的shiro-quartz等，下边是shiro各jar包的maven坐标。12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; 也可以通过引入shiro-all包括shiro所有的包：12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; 参考代码：http://download.csdn.net/detail/u014532775/9920343]]></content>
      <categories>
        <category>后台—shiro</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
</search>
